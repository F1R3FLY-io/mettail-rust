# Runtime Evaluation

**Source files:** `repl/src/repl.rs`, `runtime/src/language.rs`,
`macros/src/gen/mod.rs`, `macros/src/gen/runtime/language.rs`,
`macros/src/gen/term_ops/normalize.rs`

This document traces the complete execution path from a source string
to a displayed result, covering all six runtime stages.

## The Six Stages

```
 Source     Token       AST         Normalized     Ascent        Results
 ------------------------------------------------------------------------------
 String  →  Stream   →  Tree    →   AST         →  Fixpoint  →   (rewrites,
            (lex)       (parse)     (normalize)    (run)          equivalences,
                                                                  folds)
```

## Entry Points

There are two main entry points:

1. **REPL** (`repl/src/repl.rs`): the user types an expression, the REPL calls
   `language.parse_term()`, then `language.normalize_term()`, optionally
   `language.try_direct_eval()`, and finally `language.run_ascent()`.

2. **Programmatic** (`Language::run_ascent()`): any Rust code can call
   `RhoCalcLanguage.run_ascent(term)` directly.

Both paths go through the same generated `Language` trait implementation.

## Stage 1: Lexing

**Generated by:** `prattail/src/automata/codegen.rs`

The generated `next_token()` function (see [03-lexer-generation.md](03-lexer-generation.md))
converts the source string into a token stream.

### Example: `3 + 4`

```
Input:  "3 + 4"

Tokens: [Integer("3"), Plus, Integer("4"), Eof]
         ↑             ↑     ↑             ↑
         pos=0         pos=2 pos=4         pos=5
```

### Example: `{ @({}) ! ({}) | *(@({})) }`

```
Input:  "{ @({}) ! ({}) | *(@({})) }"

Tokens: [LBrace, At, LParen, Braces, RParen, Bang, LParen, Braces, RParen,
         Pipe, Star, LParen, At, LParen, Braces, RParen, RParen, RBrace, Eof]
```

Zero-copy: `Integer("3")` borrows the `"3"` slice from the input string.
No heap allocations occur during lexing.

## Stage 2: Parsing

**Generated by:** `prattail/src/trampoline.rs` + `macros/src/gen/mod.rs`

The `Proc::parse(input)` method is the entry point.  It lexes the input and
then calls the trampolined parser:

```rust
// Generated code (simplified)
impl Proc {
    pub fn parse(input: &str) -> Result<Proc, ParseError> {
        let tokens = lex(input);       // Stage 1
        let mut pos = 0;
        let result = parse_proc(&tokens, &mut pos, 0)?;  // Trampolined Pratt
        if pos < tokens.len() - 1 {   // EOF check: verify all tokens consumed
            return Err(ParseError::UnexpectedToken { ... });
        }
        Ok(result)
    }
}
```

### Example: `3 + 4`

The Pratt parser (see [04-parser-generation.md](04-parser-generation.md)) produces:

```
Proc::Add(
    Box::new(Proc::CastInt(Box::new(Int::NumLit(3)))),
    Box::new(Proc::CastInt(Box::new(Int::NumLit(4))))
)
```

### Example: `{ @({}) ! ({}) | *(@({})) }`

```
Proc::PPar(HashBag {
    Proc::POutput(
        Box::new(Name::NQuote(Box::new(Proc::PZero))),
        Box::new(Proc::PZero)
    ),
    Proc::PDrop(
        Box::new(Name::NQuote(Box::new(Proc::PZero)))
    )
})
```

Note: `@({})` is `Name::NQuote(Box::new(Proc::PZero))` — `{}` is `PZero`.

## Stage 3: Normalization

**Generated by:** `macros/src/gen/term_ops/normalize.rs`

`Language::normalize_term()` performs beta-reduction before Ascent seeding:

- `ApplyProc(LamProc(scope), arg)` → substitute `arg` for the bound variable in the scope body
- `MApplyProc(MLamProc(scope), args)` → substitute each arg for its corresponding bound variable
- Nested normalizations are applied recursively

For `3 + 4`, normalization is a no-op — there are no lambda applications.

For expressions involving dollar syntax like `$proc(^x.{x}, {})`:
1. Parse produces `Proc::ApplyProc(LamProc(^x.{x}), PZero)`
2. `normalize_term()` substitutes: `^x.{x}` applied to `PZero` → `{PZero}` → `PZero`

## Stage 4: Seeding Ascent

**Generated by:** `macros/src/gen/runtime/language.rs`

The parsed (and normalized) AST is seeded into the Ascent struct:

```rust
// Generated code (simplified)
fn run_ascent(&self, term: &dyn Term) -> Result<AscentResults, String> {
    let term = term.as_any().downcast_ref::<RhoCalcTerm>()
        .expect("wrong term type").0.clone();

    let mut ascent = RhoCalcAscent::default();

    // Seed the primary category relation
    ascent.proc.push((term.clone(),));

    // Seed step_term for the iteration driver
    ascent.step_term.push((term,));

    // Run the fixpoint
    ascent.run();

    // Extract results...
}
```

For `3 + 4`:
- `proc` is seeded with `(Add(CastInt(3), CastInt(4)),)`
- `step_term` is seeded with `(Add(CastInt(3), CastInt(4)),)`

## Stage 5: Ascent Fixpoint

**Engine:** the Ascent `run()` method

The fixpoint computation iterates until no new facts are derived.  For `3 + 4`:

**Iteration 1:**
```
Category exploration fires:
  proc(CastInt(NumLit(3)))
  proc(CastInt(NumLit(4)))
  int(NumLit(3))
  int(NumLit(4))

Fold rule fires for Add:
  fold_proc(Add(CastInt(3), CastInt(4)), CastInt(NumLit(7)))

Fold promoted to rewrite:
  rw_proc(Add(CastInt(3), CastInt(4)), CastInt(NumLit(7)))

Step-term propagation:
  step_term(CastInt(NumLit(7)))
  proc(CastInt(NumLit(7)))
  int(NumLit(7))
```

**Iteration 2:**
```
No new facts derived → FIXPOINT REACHED
```

For the communication rule `{ @({}) ! ({}) | *(@({})) }`:

**Iteration 1:**
```
Category exploration decomposes PPar → discovers POutput, PDrop, NQuote, PZero
QuoteDrop equation fires: eq_name(@(*(@({}))), @({}))
Exec rule fires: rw_proc(*(@({})), {})      [= PDrop(NQuote(PZero)) ~> PZero]
```

**Iteration 2:**
```
Comm rule fires: the PPar with POutput and matching PInput (if present)
  rewrites to the substituted body
Congruence rules propagate rewrites through PPar
```

**Iterations 3+:**
```
Further rewrites and congruences until fixpoint
```

### Short-Circuit: `try_direct_eval()`

Before running Ascent, the REPL checks if the term can be evaluated directly:

```rust
if let Some(result_term) = language.try_direct_eval(term.as_ref()) {
    // Skip Ascent entirely — display result immediately
}
```

`try_direct_eval()` handles pure native-type expressions (e.g., `3 + 4` where
both operands are literals) without the overhead of Ascent.  It recursively
evaluates fold rules on ground (variable-free) terms.

When `try_direct_eval()` returns `Some(result)`, the REPL wraps it in a
trivial `AscentResults::from_single_term()` and skips Stage 5 entirely.

## Stage 6: Result Extraction

After the fixpoint, results are extracted from the Ascent struct into
`AscentResults`:

```rust
pub struct AscentResults {
    pub all_terms: Vec<TermInfo>,
    pub rewrites: Vec<Rewrite>,
    pub equivalences: Vec<EquivClass>,
    pub custom_relations: HashMap<String, RelationData>,
}
```

### TermInfo

```rust
pub struct TermInfo {
    pub term_id: u64,       // hash-based unique ID
    pub display: String,    // Display representation
    pub category: String,   // "Proc", "Name", etc.
}
```

Every term in the `proc`, `name`, `int`, etc. relations is collected.

### Rewrite

```rust
pub struct Rewrite {
    pub from_id: u64,
    pub to_id: u64,
    pub from_display: String,
    pub to_display: String,
    pub rule_name: Option<String>,
}
```

Every `(src, dst)` pair in `rw_proc`, `rw_name` is collected.

### EquivClass

```rust
pub struct EquivClass {
    pub terms: Vec<TermInfo>,
}
```

The `eq_proc`, `eq_name` relations are partitioned into equivalence classes
(groups of mutually equivalent terms).

### Custom Relations

The `path` and `trans` relations from the `logic { ... }` block are extracted
into `custom_relations` by name, accessible for query or display.

## REPL Display

The REPL (`repl/src/repl.rs`) displays results depending on the command:

- **`exec <expr>`**: shows the normal form (a term reachable from the input via
  `rw_proc` that has no outgoing rewrites)
- **`step <expr>`**: shows the initial term and lists available rewrites;
  the user can `apply N` to step through them
- **`equations`**: shows equivalence classes
- **`rewrites`**: shows all rewrite pairs
- **`terms`**: shows all discovered terms
- **Queries** (`query <ascent-expr>`): evaluates custom Ascent expressions
  against the `AscentResults`

## Full Trace: `3 + 4`

```
┌────────────────────────────────────────────────────────────────┐
│ REPL input: exec 3 + 4                                         │
└──────────────────────────────┬─────────────────────────────────┘
                               │
                               ▼
┌────────────────────────────────────────────────────────────────┐
│ Stage 1 — Lex                                                  │
│   "3 + 4" → [Integer("3"), Plus, Integer("4"), Eof]            │
└──────────────────────────────┬─────────────────────────────────┘
                               │
                               ▼
┌────────────────────────────────────────────────────────────────┐
│ Stage 2 — Parse                                                │
│   → Add(CastInt(NumLit(3)), CastInt(NumLit(4)))                │
└──────────────────────────────┬─────────────────────────────────┘
                               │
                               ▼
┌────────────────────────────────────────────────────────────────┐
│ Stage 3 — Normalize                                            │
│   (no-op: no lambda applications)                              │
└──────────────────────────────┬─────────────────────────────────┘
                               │
                               ▼
┌────────────────────────────────────────────────────────────────┐
│ Stage 4 — try_direct_eval()                                    │
│   Add(CastInt(3), CastInt(4))                                  │
│   → both operands are ground native ints                       │
│   → evaluate: 3 + 4 = 7                                        │
│   → return CastInt(NumLit(7))                                  │
│   (Ascent SKIPPED)                                             │
└──────────────────────────────┬─────────────────────────────────┘
                               │
                               ▼
┌────────────────────────────────────────────────────────────────┐
│ Stage 6 — Display                                              │
│   "7"                                                          │
└────────────────────────────────────────────────────────────────┘
```

## Full Trace: `{ @({}) ! ({}) | *(@({})) }`

```
┌────────────────────────────────────────────────────────────────┐
│ REPL input: exec { @({}) ! ({}) | *(@({})) }                   │
└──────────────────────────────┬─────────────────────────────────┘
                               │
                               ▼
┌────────────────────────────────────────────────────────────────┐
│ Stage 1 — Lex                                                  │
│   → [LBrace, At, LParen, Braces, RParen, Bang, LParen,         │
│      Braces, RParen, Pipe, Star, LParen, At, LParen,           │
│      Braces, RParen, RParen, RBrace, Eof]                      │
└──────────────────────────────┬─────────────────────────────────┘
                               │
                               ▼
┌────────────────────────────────────────────────────────────────┐
│ Stage 2 — Parse                                                │
│   → PPar({                                                     │
│       POutput(NQuote(PZero), PZero),  // @({}) ! ({})          │
│       PDrop(NQuote(PZero))            // *(@({}))              │
│     })                                                         │
└──────────────────────────────┬─────────────────────────────────┘
                               │
                               ▼
┌────────────────────────────────────────────────────────────────┐
│ Stage 3 — Normalize                                            │
│   (no-op: no lambda applications)                              │
└──────────────────────────────┬─────────────────────────────────┘
                               │
                               ▼
┌────────────────────────────────────────────────────────────────┐
│ Stage 4 — try_direct_eval()                                    │
│   Not a pure native expression → returns None                  │
└──────────────────────────────┬─────────────────────────────────┘
                               │
                               ▼
┌────────────────────────────────────────────────────────────────┐
│ Stage 5 — Ascent Fixpoint                                      │
│                                                                │
│ Seed:                                                          │
│   proc(PPar({POutput(@({}),{}), *(@({}))}))                    │
│   step_term(PPar({POutput(@({}),{}), *(@({}))}))               │
│                                                                │
│ Iteration 1:                                                   │
│   Category exploration → proc(POutput(...)), proc(PDrop(...)), │
│     name(NQuote(PZero)), proc(PZero)                           │
│   Exec fires: rw_proc(PDrop(NQuote(PZero)), PZero)             │
│     ≡ *(@({})) ~> {}                                           │
│   QuoteDrop: eq_name(NQuote(PDrop(NQuote(PZero))),             │
│                      NQuote(PZero))                            │
│                                                                │
│ Iteration 2+:                                                  │
│   ParCong propagates: the PPar rewrites with PDrop reduced     │
│   Further reductions until fixpoint                            │
│                                                                │
│ Result:                                                        │
│   rw_proc(PPar({POutput(@({}),{}), *(@({}))}), ...)            │
│   Normal forms identified                                      │
└──────────────────────────────┬─────────────────────────────────┘
                               │
                               ▼
┌────────────────────────────────────────────────────────────────┐
│ Stage 6 — Extract & Display                                    │
│   Normal form reachable from input displayed                   │
│   Rewrites chain shown if requested (step mode)                │
└────────────────────────────────────────────────────────────────┘
```

## Summary

The full pipeline from source text to result:

| Stage          | Component              | Time             | Output              |
|----------------|------------------------|------------------|---------------------|
| 1. Lex         | Generated DFA lexer    | O(n)             | Token stream        |
| 2. Parse       | Trampolined Pratt+RD   | O(n)             | AST tree            |
| 3. Normalize   | Beta reduction         | O(n) typical     | Normalized AST      |
| 4. Direct eval | Native fold (optional) | O(n)             | Result term or None |
| 5. Ascent      | Datalog fixpoint       | O(n²) worst case | Relations (facts)   |
| 6. Extract     | Relation scan          | O(facts)         | AscentResults       |

For pure arithmetic like `3 + 4`, `try_direct_eval()` short-circuits stages
5-6, making evaluation effectively O(n).  For process-algebraic terms with
rewrites, the full Ascent fixpoint runs.

---

**Back to:** [00-overview.md](00-overview.md)

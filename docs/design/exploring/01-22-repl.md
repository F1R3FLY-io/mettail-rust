# REPL Redesign Plan

> Date: 2025-01-22  
> Status: Design Phase

## Summary

The REPL module (`repl/`) was an early prototype and needs significant architectural improvements. This document outlines a plan to make the REPL a first-class component of the MeTTaIL framework by:

1. Auto-deriving the `Language` trait from the `language!` macro
2. Enriching the `info` command to display full language specifications
3. Making the REPL generic over language types for better type safety

---

## Current Problems

### 1. `info` Command Shows Only Counts

```rust
// Current output:
Language: rhocalc
  Types: 2
  Terms: 8
  Equations: 1
  Rewrites: 3
```

This is nearly useless for understanding a language. Users need to see the actual:
- Type definitions
- Term constructors with their concrete syntax
- Equations (in user syntax)
- Rewrite rules (in user syntax)

### 2. Language Trait is Manually Implemented

Each language requires ~200 lines of boilerplate in `repl/src/languages/*.rs`:

```rust
impl Language for RhoCalculusLanguage {
    fn types(&self) -> Vec<String> {
        vec!["Proc".to_string(), "Name".to_string()]  // Manual!
    }
    fn term_count(&self) -> usize { 8 }  // Hardcoded!
    fn equation_count(&self) -> usize { 1 }     // Hardcoded!
    // ... 150+ more lines of manual implementation
}
```

The `language!` macro already has all this information—it should generate the implementation.

### 3. Type Erasure Everywhere

The current design uses `Box<dyn Term>` and `Box<dyn Any>` throughout:

```rust
fn parse_term(&self, input: &str) -> Result<Box<dyn Term>>;
fn run_ascent(&self, term: Box<dyn Term>) -> Result<AscentResults>;
fn add_to_env(&self, env: &mut dyn Any, name: &str, term: &dyn Term) -> Result<()>;
```

This leads to fragile downcasting and runtime errors that could be caught at compile time.

---

## Proposed Solution

### Phase 1: Language Metadata Generation

**Goal**: The `language!` macro generates a `LanguageMetadata` struct containing introspectable definitions, with equations and rewrites displayed in **user syntax** (the concrete syntax users type).

```rust
// Generated by language! macro:
pub struct RhoCalcMetadata;

impl LanguageMetadata for RhoCalcMetadata {
    fn name() -> &'static str { "RhoCalc" }
    
    fn types() -> &'static [TypeDef] {
        &[
            TypeDef { name: "Proc", native_type: None, is_primary: true },
            TypeDef { name: "Name", native_type: None, is_primary: false },
        ]
    }
    
    fn terms() -> &'static [TermDef] {
        &[
            TermDef {
                name: "PZero",
                type_name: "Proc",
                syntax: "0",
                fields: &[],
            },
            TermDef {
                name: "PInput",
                type_name: "Proc",
                syntax: "n?x.{p}",  // User syntax!
                fields: &[
                    FieldDef { name: "n", ty: "Name" },
                    FieldDef { name: "x", ty: "binder" },
                    FieldDef { name: "p", ty: "Proc" },
                ],
            },
            // ...
        ]
    }
    
    fn equations() -> &'static [EquationDef] {
        &[
            EquationDef {
                conditions: &[],
                lhs: "@(*N)",      // User syntax, not (NQuote (PDrop N))
                rhs: "N",
            },
        ]
    }
    
    fn rewrites() -> &'static [RewriteDef] {
        &[
            RewriteDef {
                name: Some("communication"),
                conditions: &[],
                premise: None,
                // User syntax, not macro pattern syntax:
                lhs: "{n?x.{p} | n!(q) | ...rest}",
                rhs: "{p[@(q)/x] | ...rest}",
            },
            // ...
        ]
    }
}
```

**User Syntax Generation**: The macro has access to grammar rules (terminals like `"?"`, `"!"`, `"@"`, etc.), so it can reconstruct the concrete syntax for display. The `codegen/display.rs` module already does something similar for `Display` impls.

**Implementation**: Extend `macros/src/codegen/` with a new module `metadata.rs` that:
1. Captures the `LanguageDef` structure at compile time
2. Formats patterns using grammar terminals (like display.rs does)
3. Generates static metadata as `&'static` data

### Phase 2: Generic Language Trait

**Goal**: Make the REPL generic over language types for better type safety, eliminating `dyn Any` and reducing downcasting.

```rust
// Core trait with associated types
pub trait Language: Send + Sync + 'static {
    /// The primary term type (first type in the language)
    type Term: Term + Clone + Send + Sync;
    
    /// The environment type
    type Env: Default + Send + Sync;
    
    /// Static metadata
    fn metadata() -> &'static dyn LanguageMetadata;
    
    /// Parse a term from user input
    fn parse(input: &str) -> Result<Self::Term>;
    
    /// Parse without clearing var cache (for environment definitions)
    fn parse_for_env(input: &str) -> Result<Self::Term>;
    
    /// Run the Ascent rewrite engine
    fn run_ascent(term: &Self::Term) -> AscentResults<Self::Term>;
    
    /// Apply environment substitution
    fn substitute_env(term: &Self::Term, env: &Self::Env) -> Self::Term;
}

// Generated by language! macro:
pub struct RhoCalc;

impl Language for RhoCalc {
    type Term = Proc;
    type Env = RhoCalcEnv;
    
    fn metadata() -> &'static dyn LanguageMetadata {
        &RhoCalcMetadata
    }
    
    fn parse(input: &str) -> Result<Proc> {
        mettail_runtime::clear_var_cache();
        rhocalc::ProcParser::new()
            .parse(input)
            .map_err(|e| anyhow::anyhow!("Parse error: {:?}", e))
    }
    
    fn parse_for_env(input: &str) -> Result<Proc> {
        rhocalc::ProcParser::new()
            .parse(input)
            .map_err(|e| anyhow::anyhow!("Parse error: {:?}", e))
    }
    
    fn run_ascent(term: &Proc) -> AscentResults<Proc> {
        let prog = ascent_run! {
            include_source!(rhocalc_source);
            proc(term.clone());
        };
        // Extract results...
    }
    
    fn substitute_env(term: &Proc, env: &RhoCalcEnv) -> Proc {
        term.substitute_env(env)
    }
}
```

**Benefits**:
- No `Box<dyn Term>` or `dyn Any` in language-specific code
- Compile-time type checking for term/env operations
- IDE autocomplete and type inference work properly
- Runtime errors become compile-time errors

### Phase 3: REPL Architecture

**Goal**: Support both generic (type-safe) and dynamic (multi-language) operation.

```rust
// Type-safe session for a single language
pub struct Session<L: Language> {
    term: Option<L::Term>,
    env: L::Env,
    results: Option<AscentResults<L::Term>>,
    history: Vec<HistoryEntry<L::Term>>,
}

impl<L: Language> Session<L> {
    pub fn exec(&mut self, input: &str) -> Result<()> {
        let term = L::parse(input)?;
        let term = L::substitute_env(&term, &self.env);
        let results = L::run_ascent(&term);
        self.term = Some(term);
        self.results = Some(results);
        Ok(())
    }
    
    pub fn assign(&mut self, name: &str, input: &str) -> Result<()> {
        let term = L::parse_for_env(input)?;
        self.env.set(name, term);  // Env trait method
        Ok(())
    }
}

// Dynamic wrapper for registry (multi-language support)
pub trait DynLanguage: Send + Sync {
    fn name(&self) -> &'static str;
    fn metadata(&self) -> &'static dyn LanguageMetadata;
    fn create_session(&self) -> Box<dyn DynSession>;
}

// Registry stores boxed dynamic languages
pub struct LanguageRegistry {
    languages: HashMap<String, Box<dyn DynLanguage>>,
}
```

This design gives us:
- **Type safety within a session**: Once you load a language, all operations are strongly typed
- **Dynamic dispatch for registry**: Can still store multiple languages and switch between them
- **No more downcasting**: The `DynSession` trait handles the boundary

### Phase 4: Enhanced `info` Command

**Goal**: Display the full language specification in user syntax.

```
rhocalc> info

═══════════════════════════════════════════════════════════════════════════════
                              RhoCalc Language
═══════════════════════════════════════════════════════════════════════════════

TYPES
  Proc    (primary)
  Name

TERMS (7)
  Proc:
    0                           nil process
    *n                          drop (dereference name)
    n!(p)                       output p on channel n  
    n?x.{p}                     input from n, bind to x in p
    (n1?x1, n2?x2, ...).{p}     multi-input (join pattern)
    {p | q | ...}               parallel composition

  Name:
    @(p)                        quote (reify process as name)

EQUATIONS (1)
  @(*N) = N                     quote-drop identity

REWRITES (4)
  communication:
    {n?x.{p} | n!(q) | ...rest} ~> {p[@(q)/x] | ...rest}

  multi-communication:
    {(n1?x1, n2?x2).{p} | n1!(q1) | n2!(q2) | ...rest}
      ~> {p[@(q1)/x1, @(q2)/x2] | ...rest}

  drop-quote:
    *@(p) ~> p

  parallel-congruence:
    if S ~> T then {S | ...rest} ~> {T | ...rest}

═══════════════════════════════════════════════════════════════════════════════
```

---

## Implementation Roadmap

### Step 1: Define Metadata Types (in `runtime/` or shared crate)

```rust
// Needs to be accessible from both macro-generated code and REPL
// Could go in mettail_runtime or a new mettail_core crate

pub trait LanguageMetadata: 'static + Send + Sync {
    fn name(&self) -> &'static str;
    fn types(&self) -> &'static [TypeDef];
    fn terms(&self) -> &'static [TermDef];
    fn equations(&self) -> &'static [EquationDef];
    fn rewrites(&self) -> &'static [RewriteDef];
    
    fn primary_type(&self) -> &'static TypeDef {
        self.types().first().expect("language must have at least one type")
    }
}

#[derive(Debug, Clone)]
pub struct TypeDef {
    pub name: &'static str,
    pub native_type: Option<&'static str>,
    pub is_primary: bool,
}

#[derive(Debug, Clone)]
pub struct TermDef {
    pub name: &'static str,
    pub type_name: &'static str,
    pub syntax: &'static str,        // User syntax
    pub description: Option<&'static str>,
    pub fields: &'static [FieldDef],
}

#[derive(Debug, Clone)]
pub struct FieldDef {
    pub name: &'static str,
    pub ty: &'static str,
    pub is_binder: bool,
}

#[derive(Debug, Clone)]
pub struct EquationDef {
    pub conditions: &'static [&'static str],
    pub lhs: &'static str,           // User syntax
    pub rhs: &'static str,           // User syntax
}

#[derive(Debug, Clone)]
pub struct RewriteDef {
    pub name: Option<&'static str>,
    pub conditions: &'static [&'static str],
    pub premise: Option<(&'static str, &'static str)>,
    pub lhs: &'static str,           // User syntax
    pub rhs: &'static str,           // User syntax
}
```

### Step 2: Generate Metadata in Macro

Add `macros/src/codegen/metadata.rs`:

```rust
pub fn generate_metadata(language: &LanguageDef) -> TokenStream {
    let name = &language.name;
    let name_str = name.to_string();
    let metadata_name = format_ident!("{}Metadata", name);
    
    // Generate type definitions
    let types = generate_type_defs(language);
    
    // Generate term definitions with user syntax
    let terms = generate_term_defs(language);
    
    // Generate equations with user syntax
    let equations = generate_equation_defs(language);
    
    // Generate rewrites with user syntax
    let rewrites = generate_rewrite_defs(language);
    
    quote! {
        pub struct #metadata_name;
        
        impl mettail_runtime::LanguageMetadata for #metadata_name {
            fn name(&self) -> &'static str { #name_str }
            fn types(&self) -> &'static [mettail_runtime::TypeDef] { &#types }
            fn terms(&self) -> &'static [mettail_runtime::TermDef] { &#terms }
            fn equations(&self) -> &'static [mettail_runtime::EquationDef] { &#equations }
            fn rewrites(&self) -> &'static [mettail_runtime::RewriteDef] { &#rewrites }
        }
    }
}

/// Format a pattern as user syntax using grammar terminals
fn pattern_to_user_syntax(pattern: &Pattern, language: &LanguageDef) -> String {
    // Similar to display.rs logic - use grammar terminals to format
    match pattern {
        Pattern::Term(pt) => pattern_term_to_syntax(pt, language),
        Pattern::Collection { elements, rest, .. } => {
            // Format as {elem1 | elem2 | ...rest}
        }
        // ...
    }
}
```

### Step 3: Generate Language Impl

Add to `macros/src/codegen/mod.rs`:

```rust
pub fn generate_language_impl(language: &LanguageDef) -> TokenStream {
    let name = &language.name;
    let name_lower = name.to_string().to_lowercase();
    let metadata_name = format_ident!("{}Metadata", name);
    let env_name = format_ident!("{}Env", name);
    
    // First type is primary
    let primary_type = &language.types[0].name;
    let parser_name = format_ident!("{}Parser", primary_type);
    let source_name = format_ident!("{}_source", name_lower);
    
    quote! {
        impl mettail_repl::Language for #name {
            type Term = #primary_type;
            type Env = #env_name;
            
            fn metadata() -> &'static dyn mettail_runtime::LanguageMetadata {
                &#metadata_name
            }
            
            fn parse(input: &str) -> anyhow::Result<Self::Term> {
                mettail_runtime::clear_var_cache();
                #name_lower::#parser_name::new()
                    .parse(input)
                    .map_err(|e| anyhow::anyhow!("Parse error: {:?}", e))
            }
            
            fn parse_for_env(input: &str) -> anyhow::Result<Self::Term> {
                #name_lower::#parser_name::new()
                    .parse(input)
                    .map_err(|e| anyhow::anyhow!("Parse error: {:?}", e))
            }
            
            fn run_ascent(term: &Self::Term) -> mettail_repl::AscentResults<Self::Term> {
                use ascent::*;
                let prog = ascent_run! {
                    include_source!(#source_name);
                    #name_lower(term.clone());
                };
                // ... extract results
            }
            
            fn substitute_env(term: &Self::Term, env: &Self::Env) -> Self::Term {
                term.substitute_env(env)
            }
        }
    }
}
```

### Step 4: Refactor REPL

Update `repl/src/`:

1. **`language.rs`**: Define generic `Language` trait and `Session<L>`
2. **`repl.rs`**: Use `DynSession` for command dispatch
3. **`registry.rs`**: Store `Box<dyn DynLanguage>`, create typed sessions on demand
4. **Remove `repl/src/languages/`**: All impl code now generated by macro

### Step 5: Update `info` Command

```rust
fn cmd_info(&self) -> Result<()> {
    let session = self.current_session()?;
    let meta = session.metadata();
    
    // Header
    println!("\n{}", format!("{} Language", meta.name()).bold());
    
    // Types
    println!("\n{}", "TYPES".yellow());
    for ty in meta.types() {
        let primary = if ty.is_primary { " (primary)" } else { "" };
        println!("  {}{}", ty.name, primary.dimmed());
    }
    
    // Terms grouped by type
    println!("\n{} ({})", "TERMS".yellow(), meta.terms().len());
    for ty in meta.types() {
        let terms: Vec<_> = meta.terms().iter()
            .filter(|t| t.type_name == ty.name)
            .collect();
        if !terms.is_empty() {
            println!("  {}:", ty.name);
            for term in terms {
                println!("    {:<28} {}", 
                    term.syntax.cyan(),
                    term.description.unwrap_or("").dimmed()
                );
            }
        }
    }
    
    // Equations
    println!("\n{} ({})", "EQUATIONS".yellow(), meta.equations().len());
    for eq in meta.equations() {
        println!("  {} = {}", eq.lhs.green(), eq.rhs.green());
    }
    
    // Rewrites
    println!("\n{} ({})", "REWRITES".yellow(), meta.rewrites().len());
    for rw in meta.rewrites() {
        if let Some(name) = rw.name {
            println!("  {}:", name.cyan());
        }
        if let Some((s, t)) = rw.premise {
            println!("    if {} ~> {} then", s, t);
        }
        println!("    {} ~> {}", rw.lhs.green(), rw.rhs.green());
    }
    
    Ok(())
}
```

---

## Additional Improvements

### 1. Syntax Highlighting Hints

The metadata could include token classification for syntax highlighting:

```rust
pub struct TermDef {
    // ...
    pub syntax_tokens: &'static [SyntaxToken],
}

pub enum SyntaxToken {
    Keyword(&'static str),      // "for", "if"
    Operator(&'static str),     // "!", "?", "|"
    Delimiter(&'static str),    // "{", "}", "(", ")"
    Metavar(&'static str),      // "n", "p", "x"
    Literal(&'static str),      // "0"
}
```

### 2. Term Descriptions from Comments

Allow inline documentation in the macro:

```rust
terms {
    /// Nil process - does nothing
    PZero . |- "0" : Proc;
    
    /// Output process - sends q on channel n
    POutput . n:Name, q:Proc |- n "!" "(" q ")" : Proc;
}
```

Extract doc comments into `TermDef.description`.

### 3. Structured Error Messages

With full metadata, parse errors can be more helpful:

```
Parse error: unexpected '!' at position 5
  
  Input: n!x.{p}
            ^
  
  Did you mean:
    n!(x)      output x on channel n
    n?x.{p}    input from n, bind x
```

### 4. Tab Completion

Metadata enables context-aware completion in the REPL:

```
rhocalc> {n?
          ↳ n?x.{...}  (input pattern)
```

---

## Design Decisions

| Question | Decision | Rationale |
|----------|----------|-----------|
| Generic vs dyn Term? | **Generic** with dyn boundary | Type safety within sessions; flexibility at registry level |
| Runtime-constructible metadata? | **No** (static only) | Simpler, no allocation, guaranteed consistency |
| Primary type selection? | **First type** in `types {}` | Convention over configuration |
| Display syntax source? | **Generated from grammar** | Macro has full info; user syntax is what users see |

---

## Dependencies

| File | Change |
|------|--------|
| `runtime/src/lib.rs` | Add metadata types |
| `macros/src/codegen/mod.rs` | Add `metadata.rs`, `language_impl.rs` |
| `macros/src/lib.rs` | Generate metadata + Language impl |
| `repl/src/language.rs` | Generic `Language` trait |
| `repl/src/repl.rs` | Use typed sessions |
| `repl/src/registry.rs` | Dynamic language wrapper |
| `repl/src/languages/` | **Delete** (generated now) |

---

## Success Criteria

1. **Zero boilerplate**: Adding a language to REPL = `registry.register::<RhoCalc>()`
2. **Full introspection**: `info` shows complete language spec in user syntax
3. **Type safety**: No `dyn Any`, compile-time term type checking
4. **Consistent display**: Equations/rewrites shown exactly as users would type them

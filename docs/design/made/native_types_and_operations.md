# Native Types and Operations: Design Overview

**Date**: January 2026

---

## Vision

Enable theories to use **Rust native types** (like `i32`, `String`, `bool`) directly with:
1. **Zero-cost abstractions** - Direct use of Rust primitives
2. **Simplified syntax** - Automatic generation from concise declarations
3. **Native operator support** - Use Rust operators directly via semantics
4. **User control** - Choose between constant folding and step-by-step evaluation

---

## Current Implementation Status

### What Works (v0.1)

**Native Type Declaration:**
```rust
exports { ![i32] as Int }
```

**Generated Structure:**
```rust
pub enum Int {
    NumLit(i32),           // Native i32 directly in field
    VarRef(OrdVar),        // Variable reference (explicit)
    Add(Box<Int>, Box<Int>),
    Sub(Box<Int>, Box<Int>),
}
```

**Semantics Block:**
```rust
semantics {
    Add: +,  // Maps to Rust's + operator
    Sub: -,
}
```

**Generates:**
- `eval()` method for direct evaluation
- Constant folding rules in Ascent: `Add(NumLit(3), NumLit(4))` → `NumLit(7)`
- Congruence rules for step-by-step evaluation

**Supported:**
- `i32` and `i64` native types fully implemented
- 10 operators: `+`, `-`, `*`, `/`, `%`, `&`, `|`, `^`, `<<`, `>>`
- Automatic literal parsing via `Integer` keyword
- **Multi-base integer literal support:** Hexadecimal (`0xFF`, `0x4A`), octal (`0o77`), binary (`0b1111`), and decimal (`255`) formats
- Environment variable queries
- Type-safe code generation

### Current Limitations

- Only `i32` fully tested
- Reserved `Integer` keyword required (should be automatic)
- Explicit `NumLit . Int ::= Integer` boilerplate
- Native types use `VarRef`, non-native use auto-generated `Var` (inconsistent)
- No user control over constant folding vs step-by-step evaluation
- No standard methods library

---

## Design: Simplified Native Type Syntax

### Goal Syntax

```rust
Type = rust_type [(method_specification), ...]
```

**Example:**
```rust
Int = i32 [
    (+, "a+b", =>),
    (*, "a*b", =>),
    (-, "a-b", =>),
    (/, "a/b", =>)
]
```

### What Gets Auto-Generated

1. **Literal constructor** - No need to write `NumLit . Int ::= Integer`
2. **Operation constructors** - `Add`, `Mul`, `Sub`, `Div` from operators
3. **Parser rules** - Token parsing for literals
4. **eval() method** - Direct evaluation using native operations
5. **Rewrite rules** - Based on evaluation mode

### Benefits

- **80% less boilerplate** - No manual constructor declarations
- **No reserved keywords** - `Integer` keyword eliminated
- **Uniform syntax** - Same pattern for all native types
- **Clear semantics** - Operations explicit in declaration

---

## Design: Variable Handling Unification

### Current State: Inconsistent Variables

**Native types:**
```rust
VarRef . Int ::= Var;  // Explicit constructor, user must define
```

**Non-native types:**
```rust
// Auto-generated by system
pub enum Proc {
    PVar(OrdVar),  // Auto-generated variant
    // ...
}
```

### Goal State: Uniform Variables

**All types should have auto-generated `Var`:**
```rust
// For Int (native):
pub enum Int {
    IVar(OrdVar),     // Auto-generated, just like non-native
    NumLit(i32),
    Add(Box<Int>, Box<Int>),
}

// For Proc (non-native):
pub enum Proc {
    PVar(OrdVar),     // Already auto-generated
    PZero,
    PPar(HashBag<Proc>),
}
```

### What's Needed

**Implementation locations:**
- `macros/src/codegen/ast_gen.rs` (lines 85-96): Remove native type check
- `macros/src/codegen/parser/lalrpop.rs`: Generate `Var` parser for all types
- `macros/src/ascent/mod.rs` (lines 296-310): Update variable retrieval rules

**Changes:**
1. Remove condition `if export.native_type.is_none()` that blocks Var generation
2. Auto-generate Var variant for ALL exported categories
3. Remove need for explicit `VarRef . Int ::= Var` in theories
4. Update environment query rules to use consistent Var labels

---

## Design: Evaluation Mode Control

### Problem

Currently generates **both** constant folding AND step-by-step rules:

```rust
// Constant folding (automatic)
Add(NumLit(3), NumLit(4)) → NumLit(7)

// Step-by-step congruence (from user rewrites)
if S => T then (Add S R) => (Add T R)
```

**User cannot choose** which evaluation strategy to use.

### Solution: Mode Annotations

```rust
Int = i32 [
    (+, "a+b", =>),     // Both folding and congruence (default)
    (+, "a+b", fold),   // Constant folding only
    (+, "a+b", step),   // Step-by-step only
]
```

### Evaluation Modes

**`=>` (default - backward compatible):**
- Generates constant folding: `Add(NumLit(3), NumLit(4))` → `NumLit(7)`
- Generates congruence: `if S => T then (Add S R) => (Add T R)`
- **Use case**: Flexible, works for most scenarios

**`fold` (production):**
- Generates constant folding only
- No congruence rules
- **Use case**: Fast evaluation, simpler rewrite graph
- **Example**: `(3+4)+5` → `7` → `12` (2 steps)

**`step` (educational):**
- Generates congruence rules only
- No constant folding
- **Use case**: See all intermediate steps in REPL
- **Example**: `(3+4)+5` shows every sub-reduction

### Implementation Roadmap

**Phase 1: AST Extension**
```rust
pub enum EvalMode {
    Both,   // Default
    Fold,   // Constant folding only
    Step,   // Congruence only
}

pub struct SemanticRule {
    pub constructor: Ident,
    pub operation: SemanticOperation,
    pub mode: EvalMode,  // NEW
}
```

**Phase 2: Conditional Generation**
- `macros/src/ascent/mod.rs::generate_semantic_rules()`: Check mode before folding
- `macros/src/ascent/mod.rs::generate_rewrite_rules()`: Check mode before congruence

**Phase 3: Parser Updates**
- Parse `=>`, `fold`, `step` tokens in method specifications

---

## Standard Methods Library

### Primitive Types

#### Integer Types (`i32`, `i64`, `u32`, etc.)

**Arithmetic:**
- `+` (Add) - Addition
- `-` (Sub) - Subtraction  
- `*` (Mul) - Multiplication
- `/` (Div) - Division
- `%` (Rem) - Remainder

**Bitwise:**
- `&` (BitAnd) - Bitwise AND
- `|` (BitOr) - Bitwise OR
- `^` (BitXor) - Bitwise XOR
- `<<` (Shl) - Left shift
- `>>` (Shr) - Right shift

**Comparison (future):**
- `==`, `!=`, `<`, `>`, `<=`, `>=`

**Methods (future):**
- `abs: Int -> Int` - Absolute value
- `pow: Int -> Int -> Int` - Exponentiation
- `min: Int -> Int -> Int` - Minimum
- `max: Int -> Int -> Int` - Maximum

#### String Type

**Operations (future):**
- `++` (Concat) - String concatenation
- `substring: String -> Int -> Int -> String` - Extract substring
- `to_upper: String -> String` - Convert to uppercase
- `to_lower: String -> String` - Convert to lowercase
- `trim: String -> String` - Remove whitespace

#### Boolean Type (future)

**Logical:**
- `&&` (And) - Logical AND
- `||` (Or) - Logical OR
- `!` (Not) - Logical NOT

### Cross-Type Methods

**Type conversions:**
- `to_string: Int -> String` - Convert integer to string
- `to_int: String -> Result<Int, Error>` - Parse string to integer
- `to_float: Int -> Float` - Convert integer to float

**String operations:**
- `length: String -> Int` - Get string length
- `char_at: String -> Int -> Char` - Get character at index
- `contains: String -> String -> Bool` - Check substring

**Collection operations:**
- `length: Vec<T> -> Int` - Get vector length
- `is_empty: Vec<T> -> Bool` - Check if empty

### Generic/Collection Types (Advanced)

**Map/Dictionary:**
- `get: Map<K,V> -> K -> Option<V>` - Get value by key
- `insert: Map<K,V> -> K -> V -> Map<K,V>` - Insert key-value pair
- `remove: Map<K,V> -> K -> Map<K,V>` - Remove key
- `contains_key: Map<K,V> -> K -> Bool` - Check key exists

**Vector/List:**
- `get: Vec<T> -> Int -> Option<T>` - Get element at index
- `push: Vec<T> -> T -> Vec<T>` - Append element
- `pop: Vec<T> -> (Option<T>, Vec<T>)` - Remove last element
- `concat: Vec<T> -> Vec<T> -> Vec<T>` - Concatenate vectors

**Option:**
- `unwrap: Option<T> -> T` - Extract value (unsafe)
- `unwrap_or: Option<T> -> T -> T` - Extract or default
- `map: Option<T> -> (T -> U) -> Option<U>` - Transform value

### Implementation Status

| Type | Status | Priority |
||------|--------|----------|
|| `i32`/`i64` arithmetic | Implemented | - |
|| `i32`/`i64` bitwise | Implemented | - |
|| Multi-base integer literals | Implemented | - |
|| `i32`/`i64` comparison | Planned | High |
|| `i32`/`i64` methods | Future | Medium |
|| `String` basic | Future | High |
|| `bool` logic | Future | High |
|| Cross-type | Future | Medium |
|| Generic collections | Future | Low |

---

## Type Conversions

### Problem

Different native types need conversion: `3 / 2` gives `1` (i32), but `3.0 / 2.0` gives `1.5` (f64). Mixed operations like `3 / 2.0` require type conversion.

**Current state**: No conversion support - operations only work with matching types.

### Design

**Explicit conversions:**
```rust
conversions {
    Int -> Float: |x: i32| x as f64,    // Lossless
    Float -> Int: |x: f64| x as i32,    // Lossy (truncates)
}
```

Generates conversion constructors:
```rust
ToFloat . Float ::= "float" "(" Int ")" ;
ToInt . Int ::= "int" "(" Float ")" ;
```

**Usage:** `float(3) / 2.0` → `1.5`

### Implementation Phases

1. **Manual conversions** - User defines conversion constructors
2. **Conversion registry** - Auto-generate from `conversions { }` block
3. **Implicit conversions** - Parser auto-inserts for type mismatches
4. **Fallible conversions** - Support `Result<T, Error>` for `String -> Int`

### Standard Conversions

- **Numeric**: `i32 <-> i64`, `i32 <-> f64`, `f64 -> i32` (truncate)
- **String**: `Int -> String`, `String -> Int` (fallible), `Bool -> String`
- **Collections**: `Vec<T> -> HashSet<T>`, `Option<T> -> Result<T, Error>`

**Priority**: High (numeric), Medium (string), Low (implicit/generic)

---

## Roadmap: Explicit Algebraic Properties

### Vision

When importing native operators, **auto-generate equations** that make implicit properties explicit.

### Example: Addition Operator

**User writes:**
```rust
Int = i32 [(+, "a+b", =>)]
```

**System generates "full theory" file:**
```rust
// Generated full theory for Int
theory! {
    name: IntFull,
    exports { Int },
    
    terms {
        // Generated constructors
        NumLit . Int ::= i32;
        Add . Int ::= Int "+" Int;
    },
    
    equations {
        // Commutativity
        (Add a b) == (Add b a);
        
        // Associativity  
        (Add (Add a b) c) == (Add a (Add b c));
        
        // Identity
        (Add a (NumLit 0)) == a;
        (Add (NumLit 0) a) == a;
    },
    
    semantics {
        Add: +,
    }
}
```

### Algebraic Properties by Operator

**Addition (`+`):**
- Commutativity: `a+b = b+a`
- Associativity: `(a+b)+c = a+(b+c)`
- Identity: `a+0 = 0+a = a`

**Multiplication (`*`):**
- Commutativity: `a*b = b*a`
- Associativity: `(a*b)*c = a*(b*c)`
- Identity: `a*1 = 1*a = a`
- Zero: `a*0 = 0*a = 0`
- Distributivity: `a*(b+c) = a*b + a*c`

**Boolean AND (`&&`):**
- Commutativity: `a && b = b && a`
- Associativity: `(a && b) && c = a && (b && c)`
- Identity: `a && true = true && a = a`
- Zero: `a && false = false && a = false`

**String concatenation (`++`):**
- Associativity: `(a ++ b) ++ c = a ++ (b ++ c)`
- Identity: `a ++ "" = "" ++ a = a`
- NOT commutative: `a ++ b ≠ b ++ a`

### Use Cases

1. **Educational**: Students see complete algebraic structure
2. **Verification**: Formal proofs using equational reasoning
3. **Optimization**: Rewrite engine can use properties for simplification
4. **Documentation**: Clear specification of operator behavior

### Implementation Strategy

**Phase 1: Property Database**
- Create registry of algebraic properties for each operator
- Store as templates with placeholders

**Phase 2: Generation**
- When native operator imported, lookup properties
- Instantiate templates with theory's types
- Write to `{theory}_full.rs` or similar

**Phase 3: Integration**
- Option to include properties in main theory
- Option to generate separate "theory + axioms" file
- REPL can show/hide derived properties

### Timeline

- Not urgent - infrastructure must stabilize first
- Requires: simplified syntax, evaluation modes, standard methods
- Estimated: Phase 3-4 of native types implementation

---

## Migration Path

### Phase 1: Current → Simplified Syntax (Breaking)

**Before:**
```rust
theory! {
    exports { ![i32] as Int },
    terms {
        VarRef . Int ::= Var;
        NumLit . Int ::= Integer;
        Add . Int ::= Int "+" Int;
    },
    semantics {
        Add: +,
    }
}
```

**After:**
```rust
theory! {
    Int = i32 [
        (+, "a+b", =>),
    ]
}
```

### Phase 2: Unified Variables (Non-Breaking)

**Before:**
```rust
// Native: explicit VarRef
VarRef . Int ::= Var;

// Non-native: auto-generated PVar
// (implicit in code generation)
```

**After:**
```rust
// All types: auto-generated Var
// (implicit in code generation for all types)
```

### Phase 3: Evaluation Modes (Non-Breaking)

**Before:**
```rust
semantics {
    Add: +,  // Generates both folding and congruence
}
```

**After:**
```rust
Int = i32 [
    (+, "a+b", fold),  // Explicit mode control
]
```

### Phase 4: Standard Methods (Additive)

**Gradually add methods:**
```rust
Int = i32 [
    (+, "a+b", =>),
    (abs, "|a|", =>),      // New method
    (pow, "a^b", =>),      // New method
]

String = String [
    (++, "a++b", =>),      // Concat
    (length, "|a|", =>),   // Cross-type to Int
]
```

### Phase 5: Explicit Properties (Opt-In)

**User request:**
```rust
#[generate_full_theory]
Int = i32 [(+, "a+b", =>)]
```

**System generates:**
- Main theory file (concise)
- Full theory file with equations

---

## Implementation Files Reference

### Current Implementation

**AST and Parsing:**
- `macros/src/ast/types.rs` - `Export` with `native_type` field, `SemanticRule`
- `macros/src/utils.rs` - `has_native_type()` helper

**Code Generation:**
- `macros/src/codegen/ast_gen.rs` - AST enum and eval() generation
- `macros/src/codegen/parser/lalrpop.rs` - Parser with `Integer` token
- `macros/src/codegen/subst.rs` - Substitution (skips native types)
- `macros/src/codegen/display.rs` - Display implementation
- `macros/src/codegen/mod.rs` - `generate_var_label()` helper

**Ascent Generation:**
- `macros/src/ascent/mod.rs` - Semantic rules and rewrite orchestration
- `macros/src/ascent/relations.rs` - Relations with native types
- `macros/src/ascent/rewrites/*.rs` - Pattern and RHS with native types

**Example Theory:**
- `theories/src/calculator.rs` - Working `i32` example

**Generated Output:**
- `theories/src/generated/calculator.lalrpop` - Generated parser
- `theories/src/generated/calculator-datalog.rs` - Generated Ascent code

---

## Open Design Questions

### Q1: Should congruence rules be auto-generated?

**Current**: User writes explicit congruence:
```rust
if S => T then (Add S R) => (Add T R);
```

**Proposed**: Auto-generate from semantics mode:
```rust
Int = i32 [(+, "a+b", step)]  // Auto-generates congruence
```

**Decision**: Auto-generate to reduce boilerplate

### Q2: Theory-level vs per-operator mode?

**Option A**: Theory-level default:
```rust
theory! {
    mode: fold,  // Default for all
    Int = i32 [
        (+, "a+b", step),  // Override
    ]
}
```

**Option B**: Per-operator only:
```rust
Int = i32 [
    (+, "a+b", fold),  // Explicit per operator
]
```

**Decision**: Support both (theory-level default, per-operator override)

### Q3: How to handle eval() errors?

**Current**: Panics on variables or incomplete evaluation

**Proposed**: Return `Result<T, EvalError>`
```rust
pub fn eval(&self) -> Result<i32, EvalError> {
    match self {
        Int::NumLit(n) => Ok(*n),
        Int::IVar(_) => Err(EvalError::UnboundVariable),
        Int::Add(a, b) => Ok(a.eval()? + b.eval()?),
    }
}
```

**Decision**: Future enhancement (breaking change required)

### Q4: Should standard methods be opt-in?

**Option A**: Auto-include all methods for type:
```rust
Int = i32  // Gets +, -, *, /, %, abs, pow, etc.
```

**Option B**: Explicit method selection:
```rust
Int = i32 [
    (+, "a+b", =>),
    (abs, "|a|", =>),
]
```

**Decision**: Explicit selection (Option B) - user controls surface area

---

**Last Updated**: January 2026  

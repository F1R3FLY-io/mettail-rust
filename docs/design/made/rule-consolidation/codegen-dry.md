# Codegen DRY Improvements

Alongside the rule consolidation, five DRY improvements were made to the codegen source code itself, reducing duplication and improving maintainability.

---

## DRY-A: `RelationNames` Struct

**File**: `macros/src/logic/common.rs`

**Problem**: Every module that needed relation names (e.g., `rw_int`, `eq_proc`, `fold_bool`) was independently calling `format_ident!` to construct them. The same 4-5 `format_ident!` calls were duplicated across `categories.rs`, `equations.rs`, `congruence.rs`, `rules.rs`, and `mod.rs`.

**Solution**: A `RelationNames` struct pre-computes all relation identifiers for a category:

```rust
pub struct RelationNames {
    pub cat: Ident,          // e.g., Int
    pub cat_lower: Ident,    // e.g., int
    pub rw_rel: Ident,       // e.g., rw_int
    pub eq_rel: Ident,       // e.g., eq_int
    pub fold_rel: Ident,     // e.g., fold_int
}

pub fn relation_names(category: &Ident) -> RelationNames { ... }
```

**Impact**: Eliminated ~30 scattered `format_ident!` calls across 6 files. Each call site now does `let rn = relation_names(category)` and accesses `rn.rw_rel`, `rn.cat_lower`, etc.

---

## DRY-B: `literal_label_for()`

**File**: `macros/src/logic/common.rs`

**Problem**: Finding the literal label for a category (e.g., `NumLit` for `Int`, `BoolLit` for `Bool`, `StringLit` for `Str`) required looking up the language type, checking for a native type, then searching grammar rules for a literal rule. This 5-line lookup was duplicated in `mod.rs` (semantic rules, fold rules) and `equations.rs`.

**Solution**: A single shared function:

```rust
pub fn literal_label_for(language: &LanguageDef, category: &Ident) -> Option<Ident> {
    let lang_type = language.types.iter().find(|t| t.name == *category)?;
    let native_type = lang_type.native_type.as_ref()?;
    let label = language.terms.iter()
        .find(|r| r.category == *category && is_literal_rule(r))
        .map(|r| r.label.clone())
        .unwrap_or_else(|| generate_literal_label(native_type));
    Some(label)
}
```

**Impact**: Replaced 4 duplicated lookup sequences. Also reduced the chance of inconsistency between different lookup sites.

---

## DRY-C: `builtin_op_token()` and `builtin_op_expr()`

**File**: `macros/src/logic/common.rs`

**Problem**: Mapping `BuiltinOp` variants to Rust operator tokens (e.g., `Add` -> `+`) was duplicated between the semantic rule generator and the fold rule resolver. The same `match` statement appeared in two places with slightly different forms.

**Solution**: Two shared functions:

```rust
/// Returns the operator token: Add -> `+`, Sub -> `-`, etc.
pub fn builtin_op_token(op: &BuiltinOp) -> Option<TokenStream> { ... }

/// Returns the full expression: Add -> `a + b`, Sub -> `a - b`, etc.
pub fn builtin_op_expr(op: &BuiltinOp) -> Option<TokenStream> { ... }
```

**Impact**: A single source of truth for operator mappings, used by `generate_semantic_rules` and `resolve_fold_expr`.

---

## DRY-D: Unified Clause Assembly

**File**: `macros/src/logic/rules.rs` (`generate_rule_clause_with_category`)

**Problem**: Generating the body of an Ascent rule clause required assembling multiple parts: the source matching clause (`cat(s)` or `eq_cat(s_orig, s)`), LHS pattern matching clauses, equational checks, condition clauses, and the RHS binding. This assembly logic was duplicated between equation rule generation and rewrite rule generation, with an 8-branch `if-else` deciding the assembly order.

**Solution**: A single builder-style assembly with a unified function:

```rust
pub fn generate_rule_clause_with_category(
    left: &Pattern,
    right: &Pattern,
    conditions: &[Condition],
    relation_name: &syn::Ident,
    category: &syn::Ident,
    language: &LanguageDef,
    use_equation_matching: bool,  // true for rewrites, false for equations
) -> TokenStream {
    // 1. Generate LHS matching clauses
    // 2. Generate condition checks
    // 3. Generate RHS construction
    // 4. Assemble: first_clause + LHS pattern + eq_checks + conditions + RHS
    let mut body = Vec::new();
    body.push(first_clause);
    body.extend(clauses);
    body.extend(eq_checks);
    body.extend(condition_clauses);
    body.push(rhs_binding);
    quote! { #head <-- #(#body),*; }
}
```

The `use_equation_matching` flag controls whether the rule matches via `eq_cat(s_orig, s)` (rewrites) or `cat(s)` (equations), which is the only structural difference between the two.

**Impact**: Eliminated ~40 lines of duplicated assembly code. Both `generate_equation_rules` and `generate_base_rewrites` now call this single function.

---

## DRY-E: Semantic Rule Unification

**File**: `macros/src/logic/mod.rs` (`generate_semantic_rules`)

**Problem**: Step-mode semantic rules were generated by three separate loops with substantially duplicated logic:
1. Binary builtin operators (e.g., `Add(NumLit(a), NumLit(b)) => NumLit(a + b)`)
2. Binary `rust_code` rules (user-defined code with 2 args)
3. Unary `rust_code` rules (user-defined code with 1 arg)

Each loop independently searched for constructors, extracted fields, and built the Ascent rule. The field extraction logic (binding `a_ref`, `b_ref`, cloning, etc.) was nearly identical.

**Solution**: A single iteration over `language.terms` with `match` dispatch on arity:

```rust
for rule in &language.terms {
    if rule.rust_code.is_none() { continue; }
    // ... shared filtering logic ...

    match non_terminal_count {
        2 => { /* binary step rule */ }
        1 => { /* unary step rule */ }
        _ => { /* N-ary step rule */ }
    }
}
```

The binary/unary/N-ary rules are collected into separate vecs (`binary_rust_rules`, `unary_rust_rules`, `nary_rust_rules`) to preserve output ordering, then extended into the result.

**Impact**: Eliminated ~60 lines of duplicated constructor lookup and filtering logic. Also added N-ary support (3+ arguments) which was previously missing.

# Prediction WFSTs

**Feature gate:** `wfst`

**Date:** 2026-02-22

The prediction WFST encodes, for each grammar category, the mapping from a
lookahead token to a ranked list of dispatch actions. Where the static
dispatch table returns actions in declaration order, the prediction WFST
returns them sorted by tropical weight — lower weight meaning "try this
first." Callers that need all alternatives for backtracking see the same
information; callers that set a beam width see a pruned subset that discards
unlikely alternatives before any work is done.

---

## Table of Contents

1. [Why Weight Dispatch?](#1-why-weight-dispatch)
2. [2-State WFST Architecture](#2-2-state-wfst-architecture)
3. [Weight Assignment](#3-weight-assignment)
4. [Beam Pruning Semantics](#4-beam-pruning-semantics)
5. [Weighted Dispatch Codegen](#5-weighted-dispatch-codegen)
6. [Example: Static vs Weighted Dispatch](#6-example-static-vs-weighted-dispatch)
7. [Source Reference](#7-source-reference)

---

## 1. Why Weight Dispatch?

The static dispatch generated by the unweighted pipeline orders match arms by
the order rules were declared in the grammar. Declaration order is a proxy for
priority — the grammar author writes more important rules first — but it is a
fragile proxy. Consider a grammar with:

- `Ident` → could be a variable reference (cheap, always works)
- `Ident` → could begin a cross-category cast (needs position save/restore)
- `Ident` → could be a lookahead-disambiguated rule (reads two tokens)

In declaration order, the backtracking arm may be tried before the direct arm,
wasting position saves. With weights, the direct arm gets weight 0.0, the
cross-category arm gets 0.5, and the lookahead arm gets 1.0+. The parser
always tries the cheapest path first without the grammar author needing to
manually order their rules.

---

## 2. 2-State WFST Architecture

Each `PredictionWfst` is a simple two-level weighted finite-state transducer:
a single start state (state 0) and one final accepting state per registered
action. Each transition from state 0 carries a token label, an action index
into the action table, and a tropical weight.

```
  ┌──────────────────────────────────────────────────────────┐
  │  PredictionWfst for category Expr                        │
  │                                                          │
  │   Plus/0.0/Direct(Add)    ┌─────────┐                    │
  │   ┌────────────────────── │ State 0 │                    │
  │   ▼                       │ (start) │                    │
  │  ┌───┐                    │         │                    │
  │  │ 1 │ (final)            │         │                    │
  │  └───┘                    │         │                    │
  │                           │         │                    │
  │   Minus/0.0/Direct(Sub)   │         │                    │
  │   ┌────────────────────── │         │                    │
  │   ▼                       │         │                    │
  │  ┌───┐                    │         │ ─────────┐         │
  │  │ 2 │ (final)            │         │          │         │
  │  └───┘                    │         │  Ident/  │         │
  │                           │         │  0.5/    │         │
  │   LParen/0.0/Grouping     │         │  Cross   │         │
  │   ┌────────────────────── │         │          ▼         │
  │   ▼                       │         │         ┌───┐      │
  │  ┌───┐                    │         │         │ 3 │(fin) │
  │  │ 4 │ (final)            └─────────┘         └───┘      │
  │  └───┘                                                   │
  │                                                          │
  │   Ident/2.0/Variable      ┌─────────┐                    │
  │   ┌────────────────────── │ State 0 │ ── · · ·           │
  │   ▼                       └─────────┘                    │
  │  ┌───┐                                                   │
  │  │ 5 │ (final)                                           │
  │  └───┘                                                   │
  └──────────────────────────────────────────────────────────┘

  ──────────────────── beam threshold (width 1.5) ───────────
  Actions with weight ≤ best + 1.5 pass through the beam.
  Variable at 2.0 is pruned when best = 0.0 and beam = 1.5.
```

The `states` vector always has exactly `1 + num_actions` entries: index 0 is
the start state, and indices `1..=num_actions` are the per-action final states.
Each final state carries a final weight of `TropicalWeight::one()` (zero cost
to accept), meaning the total path cost is simply the transition weight from
state 0.

The `actions` vector is indexed by `action_idx` carried on each transition.
This indirection allows multiple transitions (different tokens) to share the
same action entry — for example, both `Integer` and `Ident` might point to the
same `Variable` action.

---

## 3. Weight Assignment

The function `compute_action_weight` in `wfst.rs` maps each `DispatchAction`
variant to a tropical weight. Lower weight means "try first."

| Action Kind                       | Weight            | Rationale                                                                            |
|-----------------------------------|-------------------|--------------------------------------------------------------------------------------|
| `Direct`                          | 0.0               | Unambiguous token-to-rule mapping. No backtracking possible.                         |
| `Grouping`                        | 0.0               | Structural delimiter — always valid at this position.                                |
| `CrossCategory` (no backtrack)    | 0.0               | Unique token in source category; deterministic.                                      |
| `CrossCategory` (needs backtrack) | 0.5               | Token shared between categories; try source path first.                              |
| `Cast`                            | 0.5               | Type coercion; slightly penalized versus direct dispatch.                            |
| `Lookahead`                       | 1.0 + order × 1.0 | Requires reading one extra token; order breaks ties between multiple lookahead arms. |
| `Variable`                        | 2.0               | Last resort; matches any identifier regardless of context.                           |

The `order` parameter to `compute_action_weight` is the 0-based index of the
token in the category's dispatch table (after sorting by key). This provides a
stable tiebreaker: if two actions have the same kind, the one declared earlier
gets a lower weight.

For `Lookahead`, the weight is `1.0 + order as f64`. This means if there are
three lookahead arms for the same token (say for the `Ident` token), they
receive weights 1.0, 2.0, 3.0 respectively, giving a clear ordering.

The resulting weights live entirely in the tropical semiring `(ℝ ∪ {+∞}, min,
+, +∞, 0)`. Lower weight means higher priority; the tropical "zero" element
(`+∞`) represents unreachable transitions. `TropicalWeight::one()` is 0.0 (the
additive identity for cost addition), and `TropicalWeight::zero()` is `+∞`
(used for unreachable states and the initial infinity in Dijkstra-style
shortest-path).

---

## 4. Beam Pruning Semantics

The two core query methods on `PredictionWfst` are:

**`predict(token)`**
Returns all `WeightedAction` entries matching `token`, sorted by ascending
weight. No pruning is applied. This is the complete action list.

**`predict_pruned(token)`**
Returns only those actions whose weight falls within the beam threshold:

```
threshold = best_weight + beam_width
keep action a iff a.weight ≤ threshold
```

Where `best_weight` is the minimum weight among all actions matching `token`.
The best action is always returned regardless of beam width.

The beam width is stored in the `PredictionWfst` itself as
`Option<TropicalWeight>`. When `None`, `predict_pruned` behaves identically to
`predict`.

The `BeamWidthConfig` enum (from `lib.rs`) determines how the beam width is
applied at grammar level:

| `BeamWidthConfig` variant | Behaviour                                                                          |
|---------------------------|------------------------------------------------------------------------------------|
| `Disabled` (default)      | No beam; all actions returned. Equivalent to `predict()`.                          |
| `Explicit(v)`             | Apply beam width `v`. DSL: `beam_width: 1.5`.                                      |
| `Auto`                    | Default beam width 2.0. Requires `wfst-log` feature and `log_semiring_model_path`. |

`BeamWidthConfig::to_option()` converts to `Option<f64>`, which the pipeline
wraps in `TropicalWeight::new(v)` before calling `set_beam_width()`.

The beam does not affect correctness — it is a speed optimization. Actions
pruned by the beam would have been tried and failed after more expensive
work (position save, token lookahead). Pruning them early avoids that overhead.
For grammars where all actions for a given token have the same weight (e.g.,
all `Direct`), the beam has no effect since `best + width ≥ all weights`.

---

## 5. Weighted Dispatch Codegen

`generate_weighted_dispatch` in `wfst.rs` produces a comment block emitted
into the generated parser source. It groups actions by token, sorts each group
by weight, and annotates ambiguous tokens with a weight summary:

```rust
// WFST prediction for Expr: 4 tokens (3 deterministic, 1 ambiguous)
// Ident: [w=0.5, w=2.0]
```

The actual arm reordering in the generated Rust `match` expression is handled
by `write_prefix_match_arms` (in `prattail_bridge.rs`), which queries the
prediction WFST for each token and emits arms in ascending weight order.

The first arm for each token group receives no position save/restore code —
it is the "fast path." Subsequent arms get a `let saved_pos = *pos;` before
and a `*pos = saved_pos;` on failure. This means the most-likely arm runs
with zero overhead, and only fallback paths pay the cost of backtracking.

The function `write_category_dispatch_weighted` in `dispatch.rs` applies the
same principle to cross-category dispatch: for each token that dispatches into
a cross-category parse, the dispatch arms are ordered by the WFST weight of
the corresponding `CrossCategory` action.

---

## 6. Example: Static vs Weighted Dispatch

Consider an `Expr` category with three rules triggered by `Ident`:

1. `Cross` — cross-category parse of `Name`, `needs_backtrack: true` → weight 0.5
2. `Var` — direct variable reference → weight 0.0
3. `FuncCall` — lookahead `(` after ident → weight 1.0

**Static dispatch (declaration order):**

```rust
match tokens.peek() {
    Token::Ident(_) => {
        // Try Cross first (declared first in grammar)
        let saved_pos = *pos;
        if let Ok(result) = try_cross_category_parse(tokens, pos) {
            return Ok(Expr::Cross(result));
        }
        *pos = saved_pos;
        // Try Var next
        let saved_pos = *pos;
        if let Ok(result) = parse_name(tokens, pos, 0) {
            return Ok(Expr::Var(result));
        }
        *pos = saved_pos;
        // Try FuncCall last
        let name = parse_ident(tokens, pos)?;
        expect_token(tokens, pos, Token::LParen, "(")?;
        // ...
    }
}
```

Every branch saves position, even the direct `Var` parse that cannot fail once
the `Ident` token is confirmed.

**Weighted dispatch (WFST-ordered):**

```rust
match tokens.peek() {
    Token::Ident(_) => {
        // w=0.0: Var — fast path, no position save needed
        // (Direct action: unambiguous once Ident is seen)
        if let Ok(result) = parse_var(tokens, pos, 0) {
            return Ok(Expr::Var(result));
        }
        // w=0.5: Cross — needs backtrack
        let saved_pos = *pos;           // save only for fallback arms
        if let Ok(result) = try_cross_category_parse(tokens, pos) {
            return Ok(Expr::Cross(result));
        }
        *pos = saved_pos;
        // w=1.0: FuncCall — lookahead required
        let saved_pos = *pos;
        let name = parse_ident(tokens, pos)?;
        if tokens.peek() == Token::LParen {
            // ...
        }
        *pos = saved_pos;
    }
}
```

The `Var` arm runs without any save/restore overhead because the WFST places
it first. The position save is deferred to the first fallback arm.

---

## 7. Runtime Prediction via Static Embedding

In addition to compile-time dispatch arm reordering, the pipeline can
embed prediction WFSTs as static data in the generated code for runtime
consultation.

### 7.1 CSR Serialization Format

`emit_prediction_wfst_static()` in `pipeline.rs` flattens each
`PredictionWfst` into three static arrays using Compressed Sparse Row
(CSR) format:

```rust
static WFST_TRANSITIONS_Expr: &[(u16, u32, f64)] = &[
    (0, 1, 0.0), (1, 2, 0.5), (1, 3, 2.0), ...
];
static WFST_STATE_OFFSETS_Expr: &[(usize, usize, bool, f64)] = &[
    (0, 3, false, f64::INFINITY),  // state 0: 3 transitions starting at offset 0
    (3, 0, true,  0.0),            // state 1: final, 0 transitions
    ...
];
static WFST_TOKEN_NAMES_Expr: &[&str] = &["Plus", "Ident", "LParen", ...];
```

A `LazyLock<PredictionWfst>` reconstructs the WFST on first access via
`PredictionWfst::from_flat()`. The reconstruction is O(states + transitions)
and happens exactly once per process lifetime.

### 7.2 `from_flat()` Constructor

```rust
pub fn from_flat(
    category: &str,
    state_offsets: &[(usize, usize, bool, f64)],
    transitions: &[(u16, u32, f64)],
    token_names: &[&str],
    beam_width: Option<f64>,
) -> Self
```

Reconstructs the `Vec<WfstState>`, `Vec<WeightedAction>`, and `TokenIdMap`
from the flat arrays. The action table is rebuilt from the transition targets.

### 7.3 Trained Model Weight Override

`PredictionWfst::with_trained_weights()` (requires `wfst-log`) replaces
heuristic weights with learned weights from a `TrainedModel`:

```rust
pub fn with_trained_weights(&mut self, model: &TrainedModel)
```

For each rule label in the model's `rule_weights`, all matching transitions
in the WFST have their weights updated. Non-matching transitions retain
their original heuristic weights.

This enables a two-phase pipeline:
1. Build WFST with heuristic weights (compile time)
2. Override with trained weights (runtime, from `include_str!` JSON)

### 7.4 `TrainedModel::from_embedded()`

```rust
pub fn from_embedded(json_str: &str) -> Result<Self, serde_json::Error>
```

Deserializes a `TrainedModel` from a JSON string, intended for use with
`include_str!()` to embed the model at compile time:

```rust
static TRAINED_MODEL: LazyLock<TrainedModel> = LazyLock::new(|| {
    TrainedModel::from_embedded(include_str!("path/to/model.json"))
        .expect("invalid trained model JSON")
});
```

---

## 8. Source Reference

| Symbol                                 | Location                   |
|----------------------------------------|----------------------------|
| `PredictionWfst`                       | `prattail/src/wfst.rs`     |
| `PredictionWfstBuilder`                | `prattail/src/wfst.rs`     |
| `WeightedAction`                       | `prattail/src/wfst.rs`     |
| `WeightedTransition`                   | `prattail/src/wfst.rs`     |
| `WfstState`                            | `prattail/src/wfst.rs`     |
| `compute_action_weight`                | `prattail/src/wfst.rs`     |
| `build_prediction_wfsts`               | `prattail/src/wfst.rs`     |
| `generate_weighted_dispatch`           | `prattail/src/wfst.rs`     |
| `PredictionWfst::from_flat`            | `prattail/src/wfst.rs`     |
| `PredictionWfst::with_trained_weights` | `prattail/src/wfst.rs`     |
| `emit_prediction_wfst_static`          | `prattail/src/pipeline.rs` |
| `TrainedModel::from_embedded`          | `prattail/src/training.rs` |
| `write_category_dispatch_weighted`     | `prattail/src/dispatch.rs` |
| `BeamWidthConfig`                      | `prattail/src/lib.rs`      |

Test count: 16 (in `prattail/src/wfst.rs` `#[cfg(test)]` module).

See also:
- [../theory/viterbi-and-forward-backward.md](../theory/viterbi-and-forward-backward.md) — how predicted actions feed the token lattice
- [../theory/semirings.md](../theory/semirings.md) — tropical semiring axioms
- [error-recovery.md](error-recovery.md) — WFST recovery construction (uses same token map)

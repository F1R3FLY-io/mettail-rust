// Generated Ascent Datalog for ambient theory
// This file is generated by the theory! macro and is for inspection only.
// Do not edit manually - changes will be overwritten.

ascent_source! {
    ambient_source:

    // Relations
relation proc(Proc);

#[ds(crate::eqrel)] relation eq_proc(Proc, Proc);

relation rw_proc(Proc, Proc);

relation name(Name);

#[ds(crate::eqrel)] relation eq_name(Name, Name);

relation rw_name(Name, Name);

relation step_term(Proc);

relation ppar_contains(Proc, Proc);


    // Category rules
proc(sub.clone()) <--
    proc(t),
    for sub in { std::thread_local! { static POOL_PROC_PROC : std::cell::Cell < Vec < Proc >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_PROC.with(| p | p.take()); buf.clear(); match t {
        Proc::PIn(_, ref f1) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Proc::POut(_, ref f1) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Proc::POpen(_, ref f1) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Proc::PAmb(_, ref f1) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Proc::PNew(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::ApplyProc(ref lam, ref arg) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Proc::MApplyProc(ref lam, ref args) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.extend(args.iter().cloned());
        },
        Proc::LamProc(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::MLamProc(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::ApplyName(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyName(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::LamName(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::MLamName(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_PROC.with(| p | p.set(buf)); iter_buf }.into_iter();

name(sub.clone()) <--
    proc(t),
    for sub in { std::thread_local! { static POOL_PROC_NAME : std::cell::Cell < Vec < Name >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_NAME.with(| p | p.take()); buf.clear(); match t {
        Proc::PIn(ref f0, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Proc::POut(ref f0, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Proc::POpen(ref f0, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Proc::PAmb(ref f0, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Proc::ApplyName(_, ref arg) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Proc::MApplyName(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_NAME.with(| p | p.set(buf)); iter_buf }.into_iter();

name(sub.clone()) <--
    name(t),
    for sub in { std::thread_local! { static POOL_NAME_NAME : std::cell::Cell < Vec < Name >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_NAME_NAME.with(| p | p.take()); buf.clear(); match t {
        Name::ApplyProc(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::MApplyProc(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::LamProc(ref scope) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Name::MLamProc(ref scope) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Name::ApplyName(ref lam, ref arg) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Name::MApplyName(ref lam, ref args) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.extend(args.iter().cloned());
        },
        Name::LamName(ref scope) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Name::MLamName(ref scope) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_NAME_NAME.with(| p | p.set(buf)); iter_buf }.into_iter();

proc(c1.clone()) <--
    proc(c0),
    rw_proc(c0, c1);

ppar_contains(parent.clone(), elem.clone()) <--
    proc(parent),
    if let Proc::PPar(ref bag_field) = parent,
    for (elem, _count) in bag_field.iter();

proc(elem.clone()) <--
    ppar_contains(_parent, elem);

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Proc::ApplyProc(_, arg) => Proc::ApplyProc(Box::new(new_lam.clone()), arg.clone()),
    Proc::MApplyProc(_, args) => Proc::MApplyProc(Box::new(new_lam.clone()), args.clone()),
    Proc::ApplyName(_, arg) => Proc::ApplyName(Box::new(new_lam.clone()), arg.clone()),
    Proc::MApplyName(_, args) => Proc::MApplyName(Box::new(new_lam.clone()), args.clone()),
    _ => unreachable!(),
},) <--
    proc(t),
    for lam in { std::thread_local! { static POOL_PROC_CONG_LAM : std::cell::Cell < Vec < Proc >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_CONG_LAM.with(| p | p.take()); buf.clear(); match t {
        Proc::ApplyProc(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyProc(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::ApplyName(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyName(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_CONG_LAM.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_proc(lam, new_lam);

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Proc::ApplyProc(lam, _) => Proc::ApplyProc(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    proc(t),
    for arg in { std::thread_local! { static POOL_PROC_CONG_ARG_PROC : std::cell::Cell < Vec < Proc >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_CONG_ARG_PROC.with(| p | p.take()); buf.clear(); match t {
        Proc::ApplyProc(_, ref arg) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_CONG_ARG_PROC.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_proc(arg, new_arg);

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Proc::ApplyName(lam, _) => Proc::ApplyName(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    proc(t),
    for arg in { std::thread_local! { static POOL_PROC_CONG_ARG_NAME : std::cell::Cell < Vec < Name >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_CONG_ARG_NAME.with(| p | p.take()); buf.clear(); match t {
        Proc::ApplyName(_, ref arg) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_CONG_ARG_NAME.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_name(arg, new_arg);

name(c1.clone()) <--
    name(c0),
    rw_name(c0, c1);

rw_name(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Name::ApplyName(_, arg) => Name::ApplyName(Box::new(new_lam.clone()), arg.clone()),
    Name::MApplyName(_, args) => Name::MApplyName(Box::new(new_lam.clone()), args.clone()),
    _ => unreachable!(),
},) <--
    name(t),
    for lam in { std::thread_local! { static POOL_NAME_CONG_LAM : std::cell::Cell < Vec < Name >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_NAME_CONG_LAM.with(| p | p.take()); buf.clear(); match t {
        Name::ApplyName(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::MApplyName(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_NAME_CONG_LAM.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_name(lam, new_lam);

rw_name(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Name::ApplyName(lam, _) => Name::ApplyName(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    name(t),
    for arg in { std::thread_local! { static POOL_NAME_CONG_ARG_NAME : std::cell::Cell < Vec < Name >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_NAME_CONG_ARG_NAME.with(| p | p.take()); buf.clear(); match t {
        Name::ApplyName(_, ref arg) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_NAME_CONG_ARG_NAME.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_name(arg, new_arg);


    // Equation rules
eq_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    proc(t);

eq_name(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), < Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    name(t);

eq_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    proc(s),
    proc(t),
    for (s_f0, s_f1, t_f0, t_f1) in { std::thread_local! { static POOL_PROC_EQ_CONG_0 : std::cell::Cell < Vec < (Name, Proc, Name, Proc) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_EQ_CONG_0.with(| p | p.take()); buf.clear(); match (s, t) {
        (Proc::PIn(ref sf0, ref sf1), Proc::PIn(ref tf0, ref tf1)) => {
            buf.push((< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Proc::POut(ref sf0, ref sf1), Proc::POut(ref tf0, ref tf1)) => {
            buf.push((< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Proc::POpen(ref sf0, ref sf1), Proc::POpen(ref tf0, ref tf1)) => {
            buf.push((< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Proc::PAmb(ref sf0, ref sf1), Proc::PAmb(ref tf0, ref tf1)) => {
            buf.push((< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_EQ_CONG_0.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_name(s_f0, t_f0),
    eq_proc(s_f1, t_f1);

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc::PNew(ref s_f0) = s,
    let s_f0_binder = s_f0.unsafe_pattern().clone(),
    let s_f0_body_boxed = s_f0.unsafe_body(),
    let s_f0_body = &** s_f0_body_boxed,
    if let Proc::PNew(ref s_f0_body_f0) = s_f0_body,
    let s_f0_body_f0_binder = s_f0_body_f0.unsafe_pattern().clone(),
    let s_f0_body_f0_body_boxed = s_f0_body_f0.unsafe_body(),
    let s_f0_body_f0_body = &** s_f0_body_f0_body_boxed,
    let t = (Proc::PNew(mettail_runtime::Scope::from_parts_unsafe(s_f0_body_f0_binder.clone().clone(), Box::new(Proc::PNew(mettail_runtime::Scope::from_parts_unsafe(s_f0_binder.clone().clone(), Box::new((s_f0_body_f0_body.clone()).clone()))))))).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc::PNew(ref s_f0) = s,
    let s_f0_binder = s_f0.unsafe_pattern().clone(),
    let s_f0_body_boxed = s_f0.unsafe_body(),
    let s_f0_body = &** s_f0_body_boxed,
    if let Proc::PNew(ref s_f0_body_f0) = s_f0_body,
    let s_f0_body_f0_binder = s_f0_body_f0.unsafe_pattern().clone(),
    let s_f0_body_f0_body_boxed = s_f0_body_f0.unsafe_body(),
    let s_f0_body_f0_body = &** s_f0_body_f0_body_boxed,
    let t = (Proc::PNew(mettail_runtime::Scope::from_parts_unsafe(s_f0_body_f0_binder.clone().clone(), Box::new(Proc::PNew(mettail_runtime::Scope::from_parts_unsafe(s_f0_binder.clone().clone(), Box::new((s_f0_body_f0_body.clone()).clone()))))))).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc::PPar(ref s_f0) = s,
    for (s_f0_e0, _count_0) in s_f0.iter(),
    if let Proc::PNew(ref s_f0_e0_f0) = s_f0_e0,
    let s_f0_e0_f0_binder = s_f0_e0_f0.unsafe_pattern().clone(),
    let s_f0_e0_f0_body_boxed = s_f0_e0_f0.unsafe_body(),
    let s_f0_e0_f0_body = &** s_f0_e0_f0_body_boxed,
    let s_f0_rest = { let mut bag = s_f0.clone(); bag.remove(& s_f0_e0); bag },
    if s_f0_rest.clone().clone().iter().all(| (elem, _) | ! mettail_runtime::BoundTerm::free_vars(elem).contains(& s_f0_e0_f0_binder.0.clone())),
    let t = (Proc::PNew(mettail_runtime::Scope::from_parts_unsafe(s_f0_e0_f0_binder.clone().clone(), Box::new(Proc::PPar({ let mut bag = (s_f0_rest.clone()).clone(); Proc::insert_into_ppar(& mut bag, (s_f0_e0_f0_body.clone()).clone()); bag }))))).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc::PNew(ref s_f0) = s,
    let s_f0_binder = s_f0.unsafe_pattern().clone(),
    let s_f0_body_boxed = s_f0.unsafe_body(),
    let s_f0_body = &** s_f0_body_boxed,
    if let Proc::PPar(ref s_f0_body_f0) = s_f0_body,
    for (s_f0_body_f0_e0, _count_0) in s_f0_body_f0.iter(),
    let s_f0_body_f0_rest = { let mut bag = s_f0_body_f0.clone(); bag.remove(& s_f0_body_f0_e0); bag },
    if s_f0_body_f0_rest.clone().clone().iter().all(| (elem, _) | ! mettail_runtime::BoundTerm::free_vars(elem).contains(& s_f0_binder.0.clone())),
    let t = (Proc::PPar({ let mut bag = (s_f0_body_f0_rest.clone()).clone(); Proc::insert_into_ppar(& mut bag, Proc::PNew(mettail_runtime::Scope::from_parts_unsafe(s_f0_binder.clone().clone(), Box::new((s_f0_body_f0_e0.clone()).clone())))); bag })).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc::PIn(ref s_f0, ref s_f1) = s,
    let s_f0_deref = &** s_f0,
    let s_f1_deref = &** s_f1,
    if let Proc::PNew(ref s_f1_deref_f0) = s_f1_deref,
    let s_f1_deref_f0_binder = s_f1_deref_f0.unsafe_pattern().clone(),
    let s_f1_deref_f0_body_boxed = s_f1_deref_f0.unsafe_body(),
    let s_f1_deref_f0_body = &** s_f1_deref_f0_body_boxed,
    if ! mettail_runtime::BoundTerm::free_vars(& s_f1_deref_f0_body.clone()).contains(& s_f1_deref_f0_binder.0.clone()),
    let t = (Proc::PNew(mettail_runtime::Scope::from_parts_unsafe(s_f1_deref_f0_binder.clone().clone(), Box::new(Proc::PIn(Box::new((s_f0_deref.clone()).clone()), Box::new((s_f1_deref_f0_body.clone()).clone())))))).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc::PNew(ref s_f0) = s,
    let s_f0_binder = s_f0.unsafe_pattern().clone(),
    let s_f0_body_boxed = s_f0.unsafe_body(),
    let s_f0_body = &** s_f0_body_boxed,
    if let Proc::PIn(ref s_f0_body_f0, ref s_f0_body_f1) = s_f0_body,
    let s_f0_body_f0_deref = &** s_f0_body_f0,
    let s_f0_body_f1_deref = &** s_f0_body_f1,
    if ! mettail_runtime::BoundTerm::free_vars(& s_f0_body_f1_deref.clone()).contains(& s_f0_binder.0.clone()),
    let t = (Proc::PIn(Box::new((s_f0_body_f0_deref.clone()).clone()), Box::new(Proc::PNew(mettail_runtime::Scope::from_parts_unsafe(s_f0_binder.clone().clone(), Box::new((s_f0_body_f1_deref.clone()).clone())))))).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc::POut(ref s_f0, ref s_f1) = s,
    let s_f0_deref = &** s_f0,
    let s_f1_deref = &** s_f1,
    if let Proc::PNew(ref s_f1_deref_f0) = s_f1_deref,
    let s_f1_deref_f0_binder = s_f1_deref_f0.unsafe_pattern().clone(),
    let s_f1_deref_f0_body_boxed = s_f1_deref_f0.unsafe_body(),
    let s_f1_deref_f0_body = &** s_f1_deref_f0_body_boxed,
    if ! mettail_runtime::BoundTerm::free_vars(& s_f1_deref_f0_body.clone()).contains(& s_f1_deref_f0_binder.0.clone()),
    let t = (Proc::PNew(mettail_runtime::Scope::from_parts_unsafe(s_f1_deref_f0_binder.clone().clone(), Box::new(Proc::POut(Box::new((s_f0_deref.clone()).clone()), Box::new((s_f1_deref_f0_body.clone()).clone())))))).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc::PNew(ref s_f0) = s,
    let s_f0_binder = s_f0.unsafe_pattern().clone(),
    let s_f0_body_boxed = s_f0.unsafe_body(),
    let s_f0_body = &** s_f0_body_boxed,
    if let Proc::POut(ref s_f0_body_f0, ref s_f0_body_f1) = s_f0_body,
    let s_f0_body_f0_deref = &** s_f0_body_f0,
    let s_f0_body_f1_deref = &** s_f0_body_f1,
    if ! mettail_runtime::BoundTerm::free_vars(& s_f0_body_f1_deref.clone()).contains(& s_f0_binder.0.clone()),
    let t = (Proc::POut(Box::new((s_f0_body_f0_deref.clone()).clone()), Box::new(Proc::PNew(mettail_runtime::Scope::from_parts_unsafe(s_f0_binder.clone().clone(), Box::new((s_f0_body_f1_deref.clone()).clone())))))).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc::POpen(ref s_f0, ref s_f1) = s,
    let s_f0_deref = &** s_f0,
    let s_f1_deref = &** s_f1,
    if let Proc::PNew(ref s_f1_deref_f0) = s_f1_deref,
    let s_f1_deref_f0_binder = s_f1_deref_f0.unsafe_pattern().clone(),
    let s_f1_deref_f0_body_boxed = s_f1_deref_f0.unsafe_body(),
    let s_f1_deref_f0_body = &** s_f1_deref_f0_body_boxed,
    if ! mettail_runtime::BoundTerm::free_vars(& s_f1_deref_f0_body.clone()).contains(& s_f1_deref_f0_binder.0.clone()),
    let t = (Proc::PNew(mettail_runtime::Scope::from_parts_unsafe(s_f1_deref_f0_binder.clone().clone(), Box::new(Proc::POpen(Box::new((s_f0_deref.clone()).clone()), Box::new((s_f1_deref_f0_body.clone()).clone())))))).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc::PNew(ref s_f0) = s,
    let s_f0_binder = s_f0.unsafe_pattern().clone(),
    let s_f0_body_boxed = s_f0.unsafe_body(),
    let s_f0_body = &** s_f0_body_boxed,
    if let Proc::POpen(ref s_f0_body_f0, ref s_f0_body_f1) = s_f0_body,
    let s_f0_body_f0_deref = &** s_f0_body_f0,
    let s_f0_body_f1_deref = &** s_f0_body_f1,
    if ! mettail_runtime::BoundTerm::free_vars(& s_f0_body_f1_deref.clone()).contains(& s_f0_binder.0.clone()),
    let t = (Proc::POpen(Box::new((s_f0_body_f0_deref.clone()).clone()), Box::new(Proc::PNew(mettail_runtime::Scope::from_parts_unsafe(s_f0_binder.clone().clone(), Box::new((s_f0_body_f1_deref.clone()).clone())))))).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc::PAmb(ref s_f0, ref s_f1) = s,
    let s_f0_deref = &** s_f0,
    let s_f1_deref = &** s_f1,
    if let Proc::PNew(ref s_f1_deref_f0) = s_f1_deref,
    let s_f1_deref_f0_binder = s_f1_deref_f0.unsafe_pattern().clone(),
    let s_f1_deref_f0_body_boxed = s_f1_deref_f0.unsafe_body(),
    let s_f1_deref_f0_body = &** s_f1_deref_f0_body_boxed,
    if ! mettail_runtime::BoundTerm::free_vars(& s_f1_deref_f0_body.clone()).contains(& s_f1_deref_f0_binder.0.clone()),
    let t = (Proc::PNew(mettail_runtime::Scope::from_parts_unsafe(s_f1_deref_f0_binder.clone().clone(), Box::new(Proc::PAmb(Box::new((s_f0_deref.clone()).clone()), Box::new((s_f1_deref_f0_body.clone()).clone())))))).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc::PNew(ref s_f0) = s,
    let s_f0_binder = s_f0.unsafe_pattern().clone(),
    let s_f0_body_boxed = s_f0.unsafe_body(),
    let s_f0_body = &** s_f0_body_boxed,
    if let Proc::PAmb(ref s_f0_body_f0, ref s_f0_body_f1) = s_f0_body,
    let s_f0_body_f0_deref = &** s_f0_body_f0,
    let s_f0_body_f1_deref = &** s_f0_body_f1,
    if ! mettail_runtime::BoundTerm::free_vars(& s_f0_body_f1_deref.clone()).contains(& s_f0_binder.0.clone()),
    let t = (Proc::PAmb(Box::new((s_f0_body_f0_deref.clone()).clone()), Box::new(Proc::PNew(mettail_runtime::Scope::from_parts_unsafe(s_f0_binder.clone().clone(), Box::new((s_f0_body_f1_deref.clone()).clone())))))).normalize();


    // Rewrite rules
rw_proc(s_orig.clone(), t) <--
    eq_proc(s_orig, s),
    if let Proc::PPar(ref s_f0) = s,
    for (s_f0_e0, _count_0) in s_f0.iter(),
    if let Proc::PAmb(ref s_f0_e0_f0, ref s_f0_e0_f1) = s_f0_e0,
    let s_f0_e0_f0_deref = &** s_f0_e0_f0,
    let s_f0_e0_f1_deref = &** s_f0_e0_f1,
    if let Proc::PPar(ref s_f0_e0_f1_deref_f0) = s_f0_e0_f1_deref,
    for (s_f0_e0_f1_deref_f0_e0, _count_1) in s_f0_e0_f1_deref_f0.iter(),
    if let Proc::PIn(ref s_f0_e0_f1_deref_f0_e0_f0, ref s_f0_e0_f1_deref_f0_e0_f1) = s_f0_e0_f1_deref_f0_e0,
    let s_f0_e0_f1_deref_f0_e0_f0_deref = &** s_f0_e0_f1_deref_f0_e0_f0,
    let s_f0_e0_f1_deref_f0_e0_f1_deref = &** s_f0_e0_f1_deref_f0_e0_f1,
    let s_f0_e0_f1_deref_f0_rest = { let mut bag = s_f0_e0_f1_deref_f0.clone(); bag.remove(& s_f0_e0_f1_deref_f0_e0); bag },
    for (s_f0_e1, _count_2) in s_f0.iter(),
    if & s_f0_e1 != & s_f0_e0,
    if let Proc::PAmb(ref s_f0_e1_f0, ref s_f0_e1_f1) = s_f0_e1,
    let s_f0_e1_f0_deref = &** s_f0_e1_f0,
    let s_f0_e1_f1_deref = &** s_f0_e1_f1,
    let s_f0_rest = { let mut bag = s_f0.clone(); bag.remove(& s_f0_e0); bag.remove(& s_f0_e1); bag },
    eq_name(s_f0_e0_f1_deref_f0_e0_f0_deref.clone(), s_f0_e1_f0_deref.clone()),
    let t = (Proc::PPar({ let mut bag = (s_f0_rest.clone()).clone(); Proc::insert_into_ppar(& mut bag, Proc::PAmb(Box::new((s_f0_e0_f1_deref_f0_e0_f0_deref.clone()).clone()), Box::new(Proc::PPar({ let mut bag = mettail_runtime::HashBag::new(); Proc::insert_into_ppar(& mut bag, Proc::PAmb(Box::new((s_f0_e0_f0_deref.clone()).clone()), Box::new(Proc::PPar({ let mut bag = (s_f0_e0_f1_deref_f0_rest.clone()).clone(); Proc::insert_into_ppar(& mut bag, (s_f0_e0_f1_deref_f0_e0_f1_deref.clone()).clone()); bag })))); Proc::insert_into_ppar(& mut bag, (s_f0_e1_f1_deref.clone()).clone()); bag })))); bag })).normalize();

rw_proc(s_orig.clone(), t) <--
    eq_proc(s_orig, s),
    if let Proc::PAmb(ref s_f0, ref s_f1) = s,
    let s_f0_deref = &** s_f0,
    let s_f1_deref = &** s_f1,
    if let Proc::PPar(ref s_f1_deref_f0) = s_f1_deref,
    for (s_f1_deref_f0_e0, _count_0) in s_f1_deref_f0.iter(),
    if let Proc::PAmb(ref s_f1_deref_f0_e0_f0, ref s_f1_deref_f0_e0_f1) = s_f1_deref_f0_e0,
    let s_f1_deref_f0_e0_f0_deref = &** s_f1_deref_f0_e0_f0,
    let s_f1_deref_f0_e0_f1_deref = &** s_f1_deref_f0_e0_f1,
    if let Proc::PPar(ref s_f1_deref_f0_e0_f1_deref_f0) = s_f1_deref_f0_e0_f1_deref,
    for (s_f1_deref_f0_e0_f1_deref_f0_e0, _count_1) in s_f1_deref_f0_e0_f1_deref_f0.iter(),
    if let Proc::POut(ref s_f1_deref_f0_e0_f1_deref_f0_e0_f0, ref s_f1_deref_f0_e0_f1_deref_f0_e0_f1) = s_f1_deref_f0_e0_f1_deref_f0_e0,
    let s_f1_deref_f0_e0_f1_deref_f0_e0_f0_deref = &** s_f1_deref_f0_e0_f1_deref_f0_e0_f0,
    let s_f1_deref_f0_e0_f1_deref_f0_e0_f1_deref = &** s_f1_deref_f0_e0_f1_deref_f0_e0_f1,
    let s_f1_deref_f0_e0_f1_deref_f0_rest = { let mut bag = s_f1_deref_f0_e0_f1_deref_f0.clone(); bag.remove(& s_f1_deref_f0_e0_f1_deref_f0_e0); bag },
    for (s_f1_deref_f0_e1, _count_2) in s_f1_deref_f0.iter(),
    if & s_f1_deref_f0_e1 != & s_f1_deref_f0_e0,
    let s_f1_deref_f0_rest = { let mut bag = s_f1_deref_f0.clone(); bag.remove(& s_f1_deref_f0_e0); bag.remove(& s_f1_deref_f0_e1); bag },
    eq_name(s_f0_deref.clone(), s_f1_deref_f0_e0_f1_deref_f0_e0_f0_deref.clone()),
    let t = (Proc::PPar({ let mut bag = (s_f1_deref_f0_rest.clone()).clone(); Proc::insert_into_ppar(& mut bag, Proc::PAmb(Box::new((s_f1_deref_f0_e0_f0_deref.clone()).clone()), Box::new(Proc::PPar({ let mut bag = (s_f1_deref_f0_e0_f1_deref_f0_rest.clone()).clone(); Proc::insert_into_ppar(& mut bag, (s_f1_deref_f0_e0_f1_deref_f0_e0_f1_deref.clone()).clone()); bag })))); Proc::insert_into_ppar(& mut bag, Proc::PAmb(Box::new((s_f0_deref.clone()).clone()), Box::new((s_f1_deref_f0_e1.clone()).clone()))); bag })).normalize();

rw_proc(s_orig.clone(), t) <--
    eq_proc(s_orig, s),
    if let Proc::PPar(ref s_f0) = s,
    for (s_f0_e0, _count_0) in s_f0.iter(),
    if let Proc::POpen(ref s_f0_e0_f0, ref s_f0_e0_f1) = s_f0_e0,
    let s_f0_e0_f0_deref = &** s_f0_e0_f0,
    let s_f0_e0_f1_deref = &** s_f0_e0_f1,
    for (s_f0_e1, _count_1) in s_f0.iter(),
    if & s_f0_e1 != & s_f0_e0,
    if let Proc::PAmb(ref s_f0_e1_f0, ref s_f0_e1_f1) = s_f0_e1,
    let s_f0_e1_f0_deref = &** s_f0_e1_f0,
    let s_f0_e1_f1_deref = &** s_f0_e1_f1,
    let s_f0_rest = { let mut bag = s_f0.clone(); bag.remove(& s_f0_e0); bag.remove(& s_f0_e1); bag },
    eq_name(s_f0_e0_f0_deref.clone(), s_f0_e1_f0_deref.clone()),
    let t = (Proc::PPar({ let mut bag = (s_f0_rest.clone()).clone(); Proc::insert_into_ppar(& mut bag, (s_f0_e0_f1_deref.clone()).clone()); Proc::insert_into_ppar(& mut bag, (s_f0_e1_f1_deref.clone()).clone()); bag })).normalize();

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* parent)), result) <--
    proc(parent),
    if let Proc::PPar(ref bag) = parent,
    for (elem, _count) in bag.iter(),
    rw_proc(elem.clone(), elem_rewritten),
    let result = Proc::PPar({ let mut new_bag = bag.clone(); new_bag.remove(elem); Proc::insert_into_ppar(& mut new_bag, elem_rewritten.clone()); new_bag });

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), rhs) <--
    proc(lhs),
    if let Proc::PNew(ref scope) = lhs,
    let binder = scope.unsafe_pattern().clone(),
    let body = scope.unsafe_body(),
    rw_proc((** body).clone(), body_rewritten),
    let rhs = Proc::PNew(mettail_runtime::Scope::from_parts_unsafe(binder.clone(), Box::new(body_rewritten.clone())));

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (Proc::PAmb(ref x0, _), 0usize) => Proc::PAmb(x0.clone(), Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    proc(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_PROC_SCONG_PROC : std::cell::Cell < Vec < (Proc, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_SCONG_PROC.with(| p | p.take()); buf.clear(); match lhs {
        Proc::PAmb(_, ref x1) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 0usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_SCONG_PROC.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_proc(field_val, t);

}

// Generated Ascent Datalog for ambient theory
// This file is generated by the theory! macro and is for inspection only.
// Do not edit manually - changes will be overwritten.

ascent_source! {
    ambient_source:

    // Relations
relation proc(Proc);

relation name(Name);

#[ds(crate :: eqrel)] relation eq_proc(Proc, Proc);

#[ds(crate :: eqrel)] relation eq_name(Name, Name);

relation rw_proc(Proc, Proc);

relation rw_name(Name, Name);

relation step_term(Proc);

relation ppar_contains(Proc, Proc);


    // Category rules
proc(c1.clone()) <--
    proc(c0),
    rw_proc(c0, c1);

name(field_0.as_ref().clone()),
proc(field_1.as_ref().clone()) <--
    proc(t),
    if let Proc :: PIn(field_0, field_1) = t;

name(field_0.as_ref().clone()),
proc(field_1.as_ref().clone()) <--
    proc(t),
    if let Proc :: POut(field_0, field_1) = t;

name(field_0.as_ref().clone()),
proc(field_1.as_ref().clone()) <--
    proc(t),
    if let Proc :: POpen(field_0, field_1) = t;

name(field_0.as_ref().clone()),
proc(field_1.as_ref().clone()) <--
    proc(t),
    if let Proc :: PAmb(field_0, field_1) = t;

proc(body_value) <--
    proc(t),
    if let Proc :: PNew(scope) = t,
    let body_value = scope.inner().unsafe_body.as_ref().clone();

proc(lam.as_ref().clone()),
proc(arg.as_ref().clone()) <--
    proc(t),
    if let Proc :: ApplyProc(lam, arg) = t;

proc(lam.as_ref().clone()) <--
    proc(t),
    if let Proc :: MApplyProc(lam, _) = t;

proc(arg.clone()) <--
    proc(t),
    if let Proc :: MApplyProc(_, args) = t,
    for arg in args.iter();

proc((* scope.inner().unsafe_body).clone()) <--
    proc(t),
    if let Proc :: LamProc(scope) = t;

proc((* scope.inner().unsafe_body).clone()) <--
    proc(t),
    if let Proc :: MLamProc(scope) = t;

proc(lam.as_ref().clone()),
name(arg.as_ref().clone()) <--
    proc(t),
    if let Proc :: ApplyName(lam, arg) = t;

proc(lam.as_ref().clone()) <--
    proc(t),
    if let Proc :: MApplyName(lam, _) = t;

name(arg.clone()) <--
    proc(t),
    if let Proc :: MApplyName(_, args) = t,
    for arg in args.iter();

proc((* scope.inner().unsafe_body).clone()) <--
    proc(t),
    if let Proc :: LamName(scope) = t;

proc((* scope.inner().unsafe_body).clone()) <--
    proc(t),
    if let Proc :: MLamName(scope) = t;

ppar_contains(parent.clone(), elem.clone()) <--
    proc(parent),
    if let Proc :: PPar(ref bag_field) = parent,
    for (elem, _count) in bag_field.iter();

proc(elem.clone()) <--
    ppar_contains(_parent, elem);

rw_proc(Proc :: ApplyProc(lam.clone(), arg.clone()), Proc :: ApplyProc(Box :: new(lam_new.clone()), arg.clone())) <--
    proc(t),
    if let Proc :: ApplyProc(ref lam, ref arg) = t,
    rw_proc(lam.as_ref().clone(), lam_new);

rw_proc(Proc :: ApplyProc(lam.clone(), arg.clone()), Proc :: ApplyProc(lam.clone(), Box :: new(arg_new.clone()))) <--
    proc(t),
    if let Proc :: ApplyProc(ref lam, ref arg) = t,
    rw_proc(arg.as_ref().clone(), arg_new);

rw_proc(Proc :: MApplyProc(lam.clone(), args.clone()), Proc :: MApplyProc(Box :: new(lam_new.clone()), args.clone())) <--
    proc(t),
    if let Proc :: MApplyProc(ref lam, ref args) = t,
    rw_proc(lam.as_ref().clone(), lam_new);

rw_proc(Proc :: ApplyName(lam.clone(), arg.clone()), Proc :: ApplyName(Box :: new(lam_new.clone()), arg.clone())) <--
    proc(t),
    if let Proc :: ApplyName(ref lam, ref arg) = t,
    rw_proc(lam.as_ref().clone(), lam_new);

rw_proc(Proc :: ApplyName(lam.clone(), arg.clone()), Proc :: ApplyName(lam.clone(), Box :: new(arg_new.clone()))) <--
    proc(t),
    if let Proc :: ApplyName(ref lam, ref arg) = t,
    rw_name(arg.as_ref().clone(), arg_new);

rw_proc(Proc :: MApplyName(lam.clone(), args.clone()), Proc :: MApplyName(Box :: new(lam_new.clone()), args.clone())) <--
    proc(t),
    if let Proc :: MApplyName(ref lam, ref args) = t,
    rw_proc(lam.as_ref().clone(), lam_new);

name(c1.clone()) <--
    name(c0),
    rw_name(c0, c1);

name(lam.as_ref().clone()),
proc(arg.as_ref().clone()) <--
    name(t),
    if let Name :: ApplyProc(lam, arg) = t;

name(lam.as_ref().clone()) <--
    name(t),
    if let Name :: MApplyProc(lam, _) = t;

proc(arg.clone()) <--
    name(t),
    if let Name :: MApplyProc(_, args) = t,
    for arg in args.iter();

name((* scope.inner().unsafe_body).clone()) <--
    name(t),
    if let Name :: LamProc(scope) = t;

name((* scope.inner().unsafe_body).clone()) <--
    name(t),
    if let Name :: MLamProc(scope) = t;

name(lam.as_ref().clone()),
name(arg.as_ref().clone()) <--
    name(t),
    if let Name :: ApplyName(lam, arg) = t;

name(lam.as_ref().clone()) <--
    name(t),
    if let Name :: MApplyName(lam, _) = t;

name(arg.clone()) <--
    name(t),
    if let Name :: MApplyName(_, args) = t,
    for arg in args.iter();

name((* scope.inner().unsafe_body).clone()) <--
    name(t),
    if let Name :: LamName(scope) = t;

name((* scope.inner().unsafe_body).clone()) <--
    name(t),
    if let Name :: MLamName(scope) = t;

rw_name(Name :: ApplyProc(lam.clone(), arg.clone()), Name :: ApplyProc(Box :: new(lam_new.clone()), arg.clone())) <--
    name(t),
    if let Name :: ApplyProc(ref lam, ref arg) = t,
    rw_name(lam.as_ref().clone(), lam_new);

rw_name(Name :: ApplyProc(lam.clone(), arg.clone()), Name :: ApplyProc(lam.clone(), Box :: new(arg_new.clone()))) <--
    name(t),
    if let Name :: ApplyProc(ref lam, ref arg) = t,
    rw_proc(arg.as_ref().clone(), arg_new);

rw_name(Name :: MApplyProc(lam.clone(), args.clone()), Name :: MApplyProc(Box :: new(lam_new.clone()), args.clone())) <--
    name(t),
    if let Name :: MApplyProc(ref lam, ref args) = t,
    rw_name(lam.as_ref().clone(), lam_new);

rw_name(Name :: ApplyName(lam.clone(), arg.clone()), Name :: ApplyName(Box :: new(lam_new.clone()), arg.clone())) <--
    name(t),
    if let Name :: ApplyName(ref lam, ref arg) = t,
    rw_name(lam.as_ref().clone(), lam_new);

rw_name(Name :: ApplyName(lam.clone(), arg.clone()), Name :: ApplyName(lam.clone(), Box :: new(arg_new.clone()))) <--
    name(t),
    if let Name :: ApplyName(ref lam, ref arg) = t,
    rw_name(arg.as_ref().clone(), arg_new);

rw_name(Name :: MApplyName(lam.clone(), args.clone()), Name :: MApplyName(Box :: new(lam_new.clone()), args.clone())) <--
    name(t),
    if let Name :: MApplyName(ref lam, ref args) = t,
    rw_name(lam.as_ref().clone(), lam_new);


    // Equation rules
eq_proc(t.clone(), t.clone()) <--
    proc(t);

eq_name(t.clone(), t.clone()) <--
    name(t);

eq_proc(s.clone(), t.clone()) <--
    proc(s),
    if let Proc :: PIn(ref s_f0, ref s_f1) = s,
    proc(t),
    if let Proc :: PIn(ref t_f0, ref t_f1) = t,
    eq_name(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_proc(s_f1.as_ref().clone(), t_f1.as_ref().clone());

eq_proc(s.clone(), t.clone()) <--
    proc(s),
    if let Proc :: POut(ref s_f0, ref s_f1) = s,
    proc(t),
    if let Proc :: POut(ref t_f0, ref t_f1) = t,
    eq_name(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_proc(s_f1.as_ref().clone(), t_f1.as_ref().clone());

eq_proc(s.clone(), t.clone()) <--
    proc(s),
    if let Proc :: POpen(ref s_f0, ref s_f1) = s,
    proc(t),
    if let Proc :: POpen(ref t_f0, ref t_f1) = t,
    eq_name(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_proc(s_f1.as_ref().clone(), t_f1.as_ref().clone());

eq_proc(s.clone(), t.clone()) <--
    proc(s),
    if let Proc :: PAmb(ref s_f0, ref s_f1) = s,
    proc(t),
    if let Proc :: PAmb(ref t_f0, ref t_f1) = t,
    eq_name(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_proc(s_f1.as_ref().clone(), t_f1.as_ref().clone());

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc :: PNew(ref s_f0) = s,
    let s_f0_binder = s_f0.unsafe_pattern().clone(),
    let s_f0_body_boxed = s_f0.unsafe_body(),
    let s_f0_body = & * * s_f0_body_boxed,
    if let Proc :: PNew(ref s_f0_body_f0) = s_f0_body,
    let s_f0_body_f0_binder = s_f0_body_f0.unsafe_pattern().clone(),
    let s_f0_body_f0_body_boxed = s_f0_body_f0.unsafe_body(),
    let s_f0_body_f0_body = & * * s_f0_body_f0_body_boxed,
    let t = (Proc :: PNew(mettail_runtime :: Scope :: from_parts_unsafe(s_f0_body_f0_binder.clone().clone(), Box :: new(Proc :: PNew(mettail_runtime :: Scope :: from_parts_unsafe(s_f0_binder.clone().clone(), Box :: new((s_f0_body_f0_body.clone()).clone()))))))).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc :: PNew(ref s_f0) = s,
    let s_f0_binder = s_f0.unsafe_pattern().clone(),
    let s_f0_body_boxed = s_f0.unsafe_body(),
    let s_f0_body = & * * s_f0_body_boxed,
    if let Proc :: PNew(ref s_f0_body_f0) = s_f0_body,
    let s_f0_body_f0_binder = s_f0_body_f0.unsafe_pattern().clone(),
    let s_f0_body_f0_body_boxed = s_f0_body_f0.unsafe_body(),
    let s_f0_body_f0_body = & * * s_f0_body_f0_body_boxed,
    let t = (Proc :: PNew(mettail_runtime :: Scope :: from_parts_unsafe(s_f0_body_f0_binder.clone().clone(), Box :: new(Proc :: PNew(mettail_runtime :: Scope :: from_parts_unsafe(s_f0_binder.clone().clone(), Box :: new((s_f0_body_f0_body.clone()).clone()))))))).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc :: PPar(ref s_f0) = s,
    for (s_f0_e0, _count_0) in s_f0.iter(),
    if let Proc :: PNew(ref s_f0_e0_f0) = s_f0_e0,
    let s_f0_e0_f0_binder = s_f0_e0_f0.unsafe_pattern().clone(),
    let s_f0_e0_f0_body_boxed = s_f0_e0_f0.unsafe_body(),
    let s_f0_e0_f0_body = & * * s_f0_e0_f0_body_boxed,
    let s_f0_rest = { let mut bag = s_f0.clone();

bag.remove(& s_f0_e0);

bag }, if s_f0_rest.clone().clone().iter().all(| (elem, _) | ! mettail_runtime :: BoundTerm :: free_vars(elem).contains(& s_f0_e0_f0_binder.0.clone())), let t = (Proc :: PNew(mettail_runtime :: Scope :: from_parts_unsafe(s_f0_e0_f0_binder.clone().clone(), Box :: new(Proc :: PPar({ let mut bag = (s_f0_rest.clone()).clone();

Proc :: insert_into_ppar(& mut bag, (s_f0_e0_f0_body.clone()).clone());

bag }))))).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc :: PNew(ref s_f0) = s,
    let s_f0_binder = s_f0.unsafe_pattern().clone(),
    let s_f0_body_boxed = s_f0.unsafe_body(),
    let s_f0_body = & * * s_f0_body_boxed,
    if let Proc :: PPar(ref s_f0_body_f0) = s_f0_body,
    for (s_f0_body_f0_e0, _count_0) in s_f0_body_f0.iter(),
    let s_f0_body_f0_rest = { let mut bag = s_f0_body_f0.clone();

bag.remove(& s_f0_body_f0_e0);

bag }, if s_f0_body_f0_rest.clone().clone().iter().all(| (elem, _) | ! mettail_runtime :: BoundTerm :: free_vars(elem).contains(& s_f0_binder.0.clone())), let t = (Proc :: PPar({ let mut bag = (s_f0_body_f0_rest.clone()).clone();

Proc :: insert_into_ppar(& mut bag, Proc :: PNew(mettail_runtime :: Scope :: from_parts_unsafe(s_f0_binder.clone().clone(), Box :: new((s_f0_body_f0_e0.clone()).clone()))));

bag })).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc :: PIn(ref s_f0, ref s_f1) = s,
    let s_f0_deref = & * * s_f0,
    let s_f1_deref = & * * s_f1,
    if let Proc :: PNew(ref s_f1_deref_f0) = s_f1_deref,
    let s_f1_deref_f0_binder = s_f1_deref_f0.unsafe_pattern().clone(),
    let s_f1_deref_f0_body_boxed = s_f1_deref_f0.unsafe_body(),
    let s_f1_deref_f0_body = & * * s_f1_deref_f0_body_boxed,
    if ! mettail_runtime :: BoundTerm :: free_vars(& s_f1_deref_f0_body.clone()).contains(& s_f1_deref_f0_binder.0.clone()),
    let t = (Proc :: PNew(mettail_runtime :: Scope :: from_parts_unsafe(s_f1_deref_f0_binder.clone().clone(), Box :: new(Proc :: PIn(Box :: new((s_f0_deref.clone()).clone()), Box :: new((s_f1_deref_f0_body.clone()).clone())))))).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc :: PNew(ref s_f0) = s,
    let s_f0_binder = s_f0.unsafe_pattern().clone(),
    let s_f0_body_boxed = s_f0.unsafe_body(),
    let s_f0_body = & * * s_f0_body_boxed,
    if let Proc :: PIn(ref s_f0_body_f0, ref s_f0_body_f1) = s_f0_body,
    let s_f0_body_f0_deref = & * * s_f0_body_f0,
    let s_f0_body_f1_deref = & * * s_f0_body_f1,
    if ! mettail_runtime :: BoundTerm :: free_vars(& s_f0_body_f1_deref.clone()).contains(& s_f0_binder.0.clone()),
    let t = (Proc :: PIn(Box :: new((s_f0_body_f0_deref.clone()).clone()), Box :: new(Proc :: PNew(mettail_runtime :: Scope :: from_parts_unsafe(s_f0_binder.clone().clone(), Box :: new((s_f0_body_f1_deref.clone()).clone())))))).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc :: POut(ref s_f0, ref s_f1) = s,
    let s_f0_deref = & * * s_f0,
    let s_f1_deref = & * * s_f1,
    if let Proc :: PNew(ref s_f1_deref_f0) = s_f1_deref,
    let s_f1_deref_f0_binder = s_f1_deref_f0.unsafe_pattern().clone(),
    let s_f1_deref_f0_body_boxed = s_f1_deref_f0.unsafe_body(),
    let s_f1_deref_f0_body = & * * s_f1_deref_f0_body_boxed,
    if ! mettail_runtime :: BoundTerm :: free_vars(& s_f1_deref_f0_body.clone()).contains(& s_f1_deref_f0_binder.0.clone()),
    let t = (Proc :: PNew(mettail_runtime :: Scope :: from_parts_unsafe(s_f1_deref_f0_binder.clone().clone(), Box :: new(Proc :: POut(Box :: new((s_f0_deref.clone()).clone()), Box :: new((s_f1_deref_f0_body.clone()).clone())))))).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc :: PNew(ref s_f0) = s,
    let s_f0_binder = s_f0.unsafe_pattern().clone(),
    let s_f0_body_boxed = s_f0.unsafe_body(),
    let s_f0_body = & * * s_f0_body_boxed,
    if let Proc :: POut(ref s_f0_body_f0, ref s_f0_body_f1) = s_f0_body,
    let s_f0_body_f0_deref = & * * s_f0_body_f0,
    let s_f0_body_f1_deref = & * * s_f0_body_f1,
    if ! mettail_runtime :: BoundTerm :: free_vars(& s_f0_body_f1_deref.clone()).contains(& s_f0_binder.0.clone()),
    let t = (Proc :: POut(Box :: new((s_f0_body_f0_deref.clone()).clone()), Box :: new(Proc :: PNew(mettail_runtime :: Scope :: from_parts_unsafe(s_f0_binder.clone().clone(), Box :: new((s_f0_body_f1_deref.clone()).clone())))))).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc :: POpen(ref s_f0, ref s_f1) = s,
    let s_f0_deref = & * * s_f0,
    let s_f1_deref = & * * s_f1,
    if let Proc :: PNew(ref s_f1_deref_f0) = s_f1_deref,
    let s_f1_deref_f0_binder = s_f1_deref_f0.unsafe_pattern().clone(),
    let s_f1_deref_f0_body_boxed = s_f1_deref_f0.unsafe_body(),
    let s_f1_deref_f0_body = & * * s_f1_deref_f0_body_boxed,
    if ! mettail_runtime :: BoundTerm :: free_vars(& s_f1_deref_f0_body.clone()).contains(& s_f1_deref_f0_binder.0.clone()),
    let t = (Proc :: PNew(mettail_runtime :: Scope :: from_parts_unsafe(s_f1_deref_f0_binder.clone().clone(), Box :: new(Proc :: POpen(Box :: new((s_f0_deref.clone()).clone()), Box :: new((s_f1_deref_f0_body.clone()).clone())))))).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc :: PNew(ref s_f0) = s,
    let s_f0_binder = s_f0.unsafe_pattern().clone(),
    let s_f0_body_boxed = s_f0.unsafe_body(),
    let s_f0_body = & * * s_f0_body_boxed,
    if let Proc :: POpen(ref s_f0_body_f0, ref s_f0_body_f1) = s_f0_body,
    let s_f0_body_f0_deref = & * * s_f0_body_f0,
    let s_f0_body_f1_deref = & * * s_f0_body_f1,
    if ! mettail_runtime :: BoundTerm :: free_vars(& s_f0_body_f1_deref.clone()).contains(& s_f0_binder.0.clone()),
    let t = (Proc :: POpen(Box :: new((s_f0_body_f0_deref.clone()).clone()), Box :: new(Proc :: PNew(mettail_runtime :: Scope :: from_parts_unsafe(s_f0_binder.clone().clone(), Box :: new((s_f0_body_f1_deref.clone()).clone())))))).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc :: PAmb(ref s_f0, ref s_f1) = s,
    let s_f0_deref = & * * s_f0,
    let s_f1_deref = & * * s_f1,
    if let Proc :: PNew(ref s_f1_deref_f0) = s_f1_deref,
    let s_f1_deref_f0_binder = s_f1_deref_f0.unsafe_pattern().clone(),
    let s_f1_deref_f0_body_boxed = s_f1_deref_f0.unsafe_body(),
    let s_f1_deref_f0_body = & * * s_f1_deref_f0_body_boxed,
    if ! mettail_runtime :: BoundTerm :: free_vars(& s_f1_deref_f0_body.clone()).contains(& s_f1_deref_f0_binder.0.clone()),
    let t = (Proc :: PNew(mettail_runtime :: Scope :: from_parts_unsafe(s_f1_deref_f0_binder.clone().clone(), Box :: new(Proc :: PAmb(Box :: new((s_f0_deref.clone()).clone()), Box :: new((s_f1_deref_f0_body.clone()).clone())))))).normalize();

eq_proc(s.clone(), t.clone()),
proc(t.clone()) <--
    proc(s),
    if let Proc :: PNew(ref s_f0) = s,
    let s_f0_binder = s_f0.unsafe_pattern().clone(),
    let s_f0_body_boxed = s_f0.unsafe_body(),
    let s_f0_body = & * * s_f0_body_boxed,
    if let Proc :: PAmb(ref s_f0_body_f0, ref s_f0_body_f1) = s_f0_body,
    let s_f0_body_f0_deref = & * * s_f0_body_f0,
    let s_f0_body_f1_deref = & * * s_f0_body_f1,
    if ! mettail_runtime :: BoundTerm :: free_vars(& s_f0_body_f1_deref.clone()).contains(& s_f0_binder.0.clone()),
    let t = (Proc :: PAmb(Box :: new((s_f0_body_f0_deref.clone()).clone()), Box :: new(Proc :: PNew(mettail_runtime :: Scope :: from_parts_unsafe(s_f0_binder.clone().clone(), Box :: new((s_f0_body_f1_deref.clone()).clone())))))).normalize();


    // Rewrite rules
rw_proc(s_orig.clone(), t) <--
    eq_proc(s_orig, s),
    if let Proc :: PPar(ref s_f0) = s,
    for (s_f0_e0, _count_0) in s_f0.iter(),
    if let Proc :: PAmb(ref s_f0_e0_f0, ref s_f0_e0_f1) = s_f0_e0,
    let s_f0_e0_f0_deref = & * * s_f0_e0_f0,
    let s_f0_e0_f1_deref = & * * s_f0_e0_f1,
    if let Proc :: PPar(ref s_f0_e0_f1_deref_f0) = s_f0_e0_f1_deref,
    for (s_f0_e0_f1_deref_f0_e0, _count_1) in s_f0_e0_f1_deref_f0.iter(),
    if let Proc :: PIn(ref s_f0_e0_f1_deref_f0_e0_f0, ref s_f0_e0_f1_deref_f0_e0_f1) = s_f0_e0_f1_deref_f0_e0,
    let s_f0_e0_f1_deref_f0_e0_f0_deref = & * * s_f0_e0_f1_deref_f0_e0_f0,
    let s_f0_e0_f1_deref_f0_e0_f1_deref = & * * s_f0_e0_f1_deref_f0_e0_f1,
    let s_f0_e0_f1_deref_f0_rest = { let mut bag = s_f0_e0_f1_deref_f0.clone();

bag.remove(& s_f0_e0_f1_deref_f0_e0);

bag }, for (s_f0_e1, _count_2) in s_f0.iter(), if & s_f0_e1 != & s_f0_e0, if let Proc :: PAmb(ref s_f0_e1_f0, ref s_f0_e1_f1) = s_f0_e1, let s_f0_e1_f0_deref = & * * s_f0_e1_f0, let s_f0_e1_f1_deref = & * * s_f0_e1_f1, let s_f0_rest = { let mut bag = s_f0.clone();

bag.remove(& s_f0_e0);

bag.remove(& s_f0_e1);

bag }, eq_name(s_f0_e0_f1_deref_f0_e0_f0_deref.clone(), s_f0_e1_f0_deref.clone()), let t = (Proc :: PPar({ let mut bag = (s_f0_rest.clone()).clone();

Proc :: insert_into_ppar(& mut bag, Proc :: PAmb(Box :: new((s_f0_e0_f1_deref_f0_e0_f0_deref.clone()).clone()), Box :: new(Proc :: PPar({ let mut bag = mettail_runtime :: HashBag :: new();

Proc :: insert_into_ppar(& mut bag, Proc :: PAmb(Box :: new((s_f0_e0_f0_deref.clone()).clone()), Box :: new(Proc :: PPar({ let mut bag = (s_f0_e0_f1_deref_f0_rest.clone()).clone();

Proc :: insert_into_ppar(& mut bag, (s_f0_e0_f1_deref_f0_e0_f1_deref.clone()).clone());

bag }))));

Proc :: insert_into_ppar(& mut bag, (s_f0_e1_f1_deref.clone()).clone());

bag }))));

bag })).normalize();

rw_proc(s_orig.clone(), t) <--
    eq_proc(s_orig, s),
    if let Proc :: PAmb(ref s_f0, ref s_f1) = s,
    let s_f0_deref = & * * s_f0,
    let s_f1_deref = & * * s_f1,
    if let Proc :: PPar(ref s_f1_deref_f0) = s_f1_deref,
    for (s_f1_deref_f0_e0, _count_0) in s_f1_deref_f0.iter(),
    if let Proc :: PAmb(ref s_f1_deref_f0_e0_f0, ref s_f1_deref_f0_e0_f1) = s_f1_deref_f0_e0,
    let s_f1_deref_f0_e0_f0_deref = & * * s_f1_deref_f0_e0_f0,
    let s_f1_deref_f0_e0_f1_deref = & * * s_f1_deref_f0_e0_f1,
    if let Proc :: PPar(ref s_f1_deref_f0_e0_f1_deref_f0) = s_f1_deref_f0_e0_f1_deref,
    for (s_f1_deref_f0_e0_f1_deref_f0_e0, _count_1) in s_f1_deref_f0_e0_f1_deref_f0.iter(),
    if let Proc :: POut(ref s_f1_deref_f0_e0_f1_deref_f0_e0_f0, ref s_f1_deref_f0_e0_f1_deref_f0_e0_f1) = s_f1_deref_f0_e0_f1_deref_f0_e0,
    let s_f1_deref_f0_e0_f1_deref_f0_e0_f0_deref = & * * s_f1_deref_f0_e0_f1_deref_f0_e0_f0,
    let s_f1_deref_f0_e0_f1_deref_f0_e0_f1_deref = & * * s_f1_deref_f0_e0_f1_deref_f0_e0_f1,
    let s_f1_deref_f0_e0_f1_deref_f0_rest = { let mut bag = s_f1_deref_f0_e0_f1_deref_f0.clone();

bag.remove(& s_f1_deref_f0_e0_f1_deref_f0_e0);

bag }, for (s_f1_deref_f0_e1, _count_2) in s_f1_deref_f0.iter(), if & s_f1_deref_f0_e1 != & s_f1_deref_f0_e0, let s_f1_deref_f0_rest = { let mut bag = s_f1_deref_f0.clone();

bag.remove(& s_f1_deref_f0_e0);

bag.remove(& s_f1_deref_f0_e1);

bag }, eq_name(s_f0_deref.clone(), s_f1_deref_f0_e0_f1_deref_f0_e0_f0_deref.clone()), let t = (Proc :: PPar({ let mut bag = (s_f1_deref_f0_rest.clone()).clone();

Proc :: insert_into_ppar(& mut bag, Proc :: PAmb(Box :: new((s_f1_deref_f0_e0_f0_deref.clone()).clone()), Box :: new(Proc :: PPar({ let mut bag = (s_f1_deref_f0_e0_f1_deref_f0_rest.clone()).clone();

Proc :: insert_into_ppar(& mut bag, (s_f1_deref_f0_e0_f1_deref_f0_e0_f1_deref.clone()).clone());

bag }))));

Proc :: insert_into_ppar(& mut bag, Proc :: PAmb(Box :: new((s_f0_deref.clone()).clone()), Box :: new((s_f1_deref_f0_e1.clone()).clone())));

bag })).normalize();

rw_proc(s_orig.clone(), t) <--
    eq_proc(s_orig, s),
    if let Proc :: PPar(ref s_f0) = s,
    for (s_f0_e0, _count_0) in s_f0.iter(),
    if let Proc :: POpen(ref s_f0_e0_f0, ref s_f0_e0_f1) = s_f0_e0,
    let s_f0_e0_f0_deref = & * * s_f0_e0_f0,
    let s_f0_e0_f1_deref = & * * s_f0_e0_f1,
    for (s_f0_e1, _count_1) in s_f0.iter(),
    if & s_f0_e1 != & s_f0_e0,
    if let Proc :: PAmb(ref s_f0_e1_f0, ref s_f0_e1_f1) = s_f0_e1,
    let s_f0_e1_f0_deref = & * * s_f0_e1_f0,
    let s_f0_e1_f1_deref = & * * s_f0_e1_f1,
    let s_f0_rest = { let mut bag = s_f0.clone();

bag.remove(& s_f0_e0);

bag.remove(& s_f0_e1);

bag }, eq_name(s_f0_e0_f0_deref.clone(), s_f0_e1_f0_deref.clone()), let t = (Proc :: PPar({ let mut bag = (s_f0_rest.clone()).clone();

Proc :: insert_into_ppar(& mut bag, (s_f0_e0_f1_deref.clone()).clone());

Proc :: insert_into_ppar(& mut bag, (s_f0_e1_f1_deref.clone()).clone());

bag })).normalize();

rw_proc(parent.clone(), result) <--
    proc(parent),
    if let Proc :: PPar(ref bag) = parent,
    for (elem, _count) in bag.iter(),
    rw_proc(elem.clone(), elem_rewritten),
    let result = Proc :: PPar({ let mut new_bag = bag.clone();

new_bag.remove(elem);

Proc :: insert_into_ppar(& mut new_bag, elem_rewritten.clone());

new_bag });

rw_proc(lhs.clone(), rhs) <--
    proc(lhs),
    if let Proc :: PNew(ref scope) = lhs,
    let binder = scope.unsafe_pattern().clone(),
    let body = scope.unsafe_body(),
    rw_proc((* * body).clone(), body_rewritten),
    let rhs = Proc :: PNew(mettail_runtime :: Scope :: from_parts_unsafe(binder.clone(), Box :: new(body_rewritten.clone())));

rw_proc(lhs.clone(), rhs) <--
    proc(lhs),
    if let Proc :: PAmb(ref x0, ref x1) = lhs,
    rw_proc((* * x1).clone(), t),
    let rhs = Proc :: PAmb(x0.clone(), Box :: new(t.clone()));

}

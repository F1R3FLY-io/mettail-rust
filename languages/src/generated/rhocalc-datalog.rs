// Generated Ascent Datalog for rhocalc theory
// This file is generated by the theory! macro and is for inspection only.
// Do not edit manually - changes will be overwritten.

ascent_source! {
    rhocalc_source:

    // Relations
relation proc(Proc);

relation name(Name);

#[ds(crate :: eqrel)] relation eq_proc(Proc, Proc);

#[ds(crate :: eqrel)] relation eq_name(Name, Name);

relation rw_proc(Proc, Proc);

relation rw_name(Name, Name);

relation ppar_contains(Proc, Proc);


    // Category rules
proc(c1) <--
    proc(c0),
    rw_proc(c0, c1);

name(field_0.as_ref().clone()) <--
    proc(t),
    if let Proc :: PDrop(field_0) = t;

name(field_0.as_ref().clone()),
proc(field_1.as_ref().clone()) <--
    proc(t),
    if let Proc :: POutput(field_0, field_1) = t;

proc(lam.as_ref().clone()),
proc(arg.as_ref().clone()) <--
    proc(t),
    if let Proc :: ApplyProc(lam, arg) = t;

proc(lam.as_ref().clone()) <--
    proc(t),
    if let Proc :: MApplyProc(lam, _) = t;

proc(arg.clone()) <--
    proc(t),
    if let Proc :: MApplyProc(_, args) = t,
    for arg in args.iter();

proc((* scope.inner().unsafe_body).clone()) <--
    proc(t),
    if let Proc :: LamProc(scope) = t;

proc((* scope.inner().unsafe_body).clone()) <--
    proc(t),
    if let Proc :: MLamProc(scope) = t;

proc(lam.as_ref().clone()),
name(arg.as_ref().clone()) <--
    proc(t),
    if let Proc :: ApplyName(lam, arg) = t;

proc(lam.as_ref().clone()) <--
    proc(t),
    if let Proc :: MApplyName(lam, _) = t;

name(arg.clone()) <--
    proc(t),
    if let Proc :: MApplyName(_, args) = t,
    for arg in args.iter();

proc((* scope.inner().unsafe_body).clone()) <--
    proc(t),
    if let Proc :: LamName(scope) = t;

proc((* scope.inner().unsafe_body).clone()) <--
    proc(t),
    if let Proc :: MLamName(scope) = t;

ppar_contains(parent.clone(), elem.clone()) <--
    proc(parent),
    if let Proc :: PPar(ref bag_field) = parent,
    for (elem, _count) in bag_field.iter();

proc(elem) <--
    ppar_contains(_parent, elem);

rw_proc(Proc :: ApplyProc(lam.clone(), arg.clone()), Proc :: ApplyProc(Box :: new(lam_new.clone()), arg.clone())) <--
    proc(t),
    if let Proc :: ApplyProc(ref lam, ref arg) = t,
    rw_proc(lam.as_ref().clone(), lam_new);

rw_proc(Proc :: ApplyProc(lam.clone(), arg.clone()), Proc :: ApplyProc(lam.clone(), Box :: new(arg_new.clone()))) <--
    proc(t),
    if let Proc :: ApplyProc(ref lam, ref arg) = t,
    rw_proc(arg.as_ref().clone(), arg_new);

rw_proc(Proc :: MApplyProc(lam.clone(), args.clone()), Proc :: MApplyProc(Box :: new(lam_new.clone()), args.clone())) <--
    proc(t),
    if let Proc :: MApplyProc(ref lam, ref args) = t,
    rw_proc(lam.as_ref().clone(), lam_new);

rw_proc(Proc :: ApplyName(lam.clone(), arg.clone()), Proc :: ApplyName(Box :: new(lam_new.clone()), arg.clone())) <--
    proc(t),
    if let Proc :: ApplyName(ref lam, ref arg) = t,
    rw_proc(lam.as_ref().clone(), lam_new);

rw_proc(Proc :: ApplyName(lam.clone(), arg.clone()), Proc :: ApplyName(lam.clone(), Box :: new(arg_new.clone()))) <--
    proc(t),
    if let Proc :: ApplyName(ref lam, ref arg) = t,
    rw_name(arg.as_ref().clone(), arg_new);

rw_proc(Proc :: MApplyName(lam.clone(), args.clone()), Proc :: MApplyName(Box :: new(lam_new.clone()), args.clone())) <--
    proc(t),
    if let Proc :: MApplyName(ref lam, ref args) = t,
    rw_proc(lam.as_ref().clone(), lam_new);

name(c1) <--
    name(c0),
    rw_name(c0, c1);

proc(field_0.as_ref().clone()) <--
    name(t),
    if let Name :: NQuote(field_0) = t;

name(lam.as_ref().clone()),
proc(arg.as_ref().clone()) <--
    name(t),
    if let Name :: ApplyProc(lam, arg) = t;

name(lam.as_ref().clone()) <--
    name(t),
    if let Name :: MApplyProc(lam, _) = t;

proc(arg.clone()) <--
    name(t),
    if let Name :: MApplyProc(_, args) = t,
    for arg in args.iter();

name((* scope.inner().unsafe_body).clone()) <--
    name(t),
    if let Name :: LamProc(scope) = t;

name((* scope.inner().unsafe_body).clone()) <--
    name(t),
    if let Name :: MLamProc(scope) = t;

name(lam.as_ref().clone()),
name(arg.as_ref().clone()) <--
    name(t),
    if let Name :: ApplyName(lam, arg) = t;

name(lam.as_ref().clone()) <--
    name(t),
    if let Name :: MApplyName(lam, _) = t;

name(arg.clone()) <--
    name(t),
    if let Name :: MApplyName(_, args) = t,
    for arg in args.iter();

name((* scope.inner().unsafe_body).clone()) <--
    name(t),
    if let Name :: LamName(scope) = t;

name((* scope.inner().unsafe_body).clone()) <--
    name(t),
    if let Name :: MLamName(scope) = t;

rw_name(Name :: ApplyProc(lam.clone(), arg.clone()), Name :: ApplyProc(Box :: new(lam_new.clone()), arg.clone())) <--
    name(t),
    if let Name :: ApplyProc(ref lam, ref arg) = t,
    rw_name(lam.as_ref().clone(), lam_new);

rw_name(Name :: ApplyProc(lam.clone(), arg.clone()), Name :: ApplyProc(lam.clone(), Box :: new(arg_new.clone()))) <--
    name(t),
    if let Name :: ApplyProc(ref lam, ref arg) = t,
    rw_proc(arg.as_ref().clone(), arg_new);

rw_name(Name :: MApplyProc(lam.clone(), args.clone()), Name :: MApplyProc(Box :: new(lam_new.clone()), args.clone())) <--
    name(t),
    if let Name :: MApplyProc(ref lam, ref args) = t,
    rw_name(lam.as_ref().clone(), lam_new);

rw_name(Name :: ApplyName(lam.clone(), arg.clone()), Name :: ApplyName(Box :: new(lam_new.clone()), arg.clone())) <--
    name(t),
    if let Name :: ApplyName(ref lam, ref arg) = t,
    rw_name(lam.as_ref().clone(), lam_new);

rw_name(Name :: ApplyName(lam.clone(), arg.clone()), Name :: ApplyName(lam.clone(), Box :: new(arg_new.clone()))) <--
    name(t),
    if let Name :: ApplyName(ref lam, ref arg) = t,
    rw_name(arg.as_ref().clone(), arg_new);

rw_name(Name :: MApplyName(lam.clone(), args.clone()), Name :: MApplyName(Box :: new(lam_new.clone()), args.clone())) <--
    name(t),
    if let Name :: MApplyName(ref lam, ref args) = t,
    rw_name(lam.as_ref().clone(), lam_new);


    // Equation rules
eq_proc(t.clone(), t.clone()) <--
    proc(t);

eq_name(t.clone(), t.clone()) <--
    name(t);

eq_proc(s.clone(), t.clone()) <--
    proc(s),
    if let Proc :: PDrop(ref s_f0) = s,
    proc(t),
    if let Proc :: PDrop(ref t_f0) = t,
    eq_name(s_f0.as_ref().clone(), t_f0.as_ref().clone());

eq_proc(s.clone(), t.clone()) <--
    proc(s),
    if let Proc :: POutput(ref s_f0, ref s_f1) = s,
    proc(t),
    if let Proc :: POutput(ref t_f0, ref t_f1) = t,
    eq_name(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_proc(s_f1.as_ref().clone(), t_f1.as_ref().clone());

eq_name(s.clone(), t.clone()) <--
    name(s),
    if let Name :: NQuote(ref s_f0) = s,
    name(t),
    if let Name :: NQuote(ref t_f0) = t,
    eq_proc(s_f0.as_ref().clone(), t_f0.as_ref().clone());

eq_name(s.clone(), t.clone()),
name(t.clone()) <--
    name(s),
    if let Name :: NQuote(ref s_f0) = s,
    let s_f0_deref = & * * s_f0,
    if let Proc :: PDrop(ref s_f0_deref_f0) = s_f0_deref,
    let s_f0_deref_f0_deref = & * * s_f0_deref_f0,
    let t = ((s_f0_deref_f0_deref.clone()).clone()).normalize();


    // Rewrite rules
rw_proc(s_orig.clone(), t) <--
    eq_proc(s_orig, s),
    if let Proc :: PPar(ref s_f0) = s,
    for (s_f0_e0, _count_0) in s_f0.iter(),
    if let Proc :: PInputs(ref s_f0_e0_f0, ref s_f0_e0_f1) = s_f0_e0,
    let s_f0_e0_f1_binder = s_f0_e0_f1.unsafe_pattern().clone(),
    let s_f0_e0_f1_body_boxed = s_f0_e0_f1.unsafe_body(),
    let s_f0_e0_f1_body = & * * s_f0_e0_f1_body_boxed,
    let (__zip_collected_1, __map_matched_indices_1) = { let __ctx_vec : Vec < _ > = s_f0.iter().collect();

let mut __results = Vec :: new();

let mut __matched = std :: collections :: HashSet :: new();

for __zip_first_1 in s_f0_e0_f0.clone().iter() { let mut __found = None;

for (__idx, (__zip_search_1, _)) in __ctx_vec.iter().enumerate() { if __matched.contains(& __idx) { continue;

} if let Proc :: POutput(ref __match_f0_1, ref __match_f1_1) = __zip_search_1 { if & * * __match_f0_1 == __zip_first_1 { __found = Some((__idx, (* * __match_f1_1).clone()));

break;

} } } if let Some((__idx, __val)) = __found { __matched.insert(__idx);

__results.push(__val);

} } (__results, __matched) }, if __zip_collected_1.len() == s_f0_e0_f0.clone().len(), let s_f0_rest = { let mut bag = s_f0.clone();

bag.remove(& s_f0_e0);

let __ctx_vec : Vec < _ > = s_f0.iter().collect();

for __idx in __map_matched_indices_1.iter() { if let Some((elem, _)) = __ctx_vec.get(* __idx) { bag.remove(elem);

} } bag }, let t = (Proc :: PPar({ let mut bag = (s_f0_rest.clone()).clone();

Proc :: insert_into_ppar(& mut bag, { let (__binders, __body) = ((s_f0_e0_f1.clone()).clone()).unbind();

let __vars : Vec < & mettail_runtime :: FreeVar < String >> = __binders.iter().map(| b | & b.0).collect();

let __repls = { let __map_coll = (__zip_collected_1.clone()).clone();

__map_coll.iter().map(| __elem | Name :: NQuote(Box :: new((__elem).clone()))).collect :: < Vec < _ >> () };

(* __body).multi_substitute_name(& __vars, & __repls) });

bag })).normalize();

rw_proc(s_orig.clone(), t) <--
    eq_proc(s_orig, s),
    if let Proc :: PDrop(ref s_f0) = s,
    let s_f0_deref = & * * s_f0,
    if let Name :: NQuote(ref s_f0_deref_f0) = s_f0_deref,
    let s_f0_deref_f0_deref = & * * s_f0_deref_f0,
    let t = ((s_f0_deref_f0_deref.clone()).clone()).normalize();

rw_proc(parent, result) <--
    proc(parent),
    if let Proc :: PPar(ref bag) = parent,
    for (elem, _count) in bag.iter(),
    rw_proc(elem.clone(), elem_rewritten),
    let result = Proc :: PPar({ let mut new_bag = bag.clone();

new_bag.remove(elem);

Proc :: insert_into_ppar(& mut new_bag, elem_rewritten.clone());

new_bag });

}

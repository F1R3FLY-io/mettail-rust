// Generated Ascent Datalog for rhocalc theory
// This file is generated by the theory! macro and is for inspection only.
// Do not edit manually - changes will be overwritten.

ascent_source! {
    rhocalc_source:

    // Relations
relation proc(Proc);

#[ds(crate::eqrel)] relation eq_proc(Proc, Proc);

relation rw_proc(Proc, Proc);

relation fold_proc(Proc, Proc);

relation name(Name);

#[ds(crate::eqrel)] relation eq_name(Name, Name);

relation rw_name(Name, Name);

relation int(Int);

#[ds(crate::eqrel)] relation eq_int(Int, Int);

relation rw_int(Int, Int);

relation float(Float);

#[ds(crate::eqrel)] relation eq_float(Float, Float);

relation rw_float(Float, Float);

relation bool(Bool);

#[ds(crate::eqrel)] relation eq_bool(Bool, Bool);

relation rw_bool(Bool, Bool);

relation str(Str);

#[ds(crate::eqrel)] relation eq_str(Str, Str);

relation rw_str(Str, Str);

relation step_term(Proc);

relation ppar_contains(Proc, Proc);


    // Category rules
proc(sub.clone()) <--
    proc(t),
    for sub in { std::thread_local! { static POOL_PROC_PROC : std::cell::Cell < Vec < Proc >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_PROC.with(| p | p.take()); buf.clear(); match t {
        Proc::POutput(_, ref f1) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Proc::Add(ref f0, ref f1) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Proc::Sub(ref f0, ref f1) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Proc::Mul(ref f0, ref f1) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Proc::Div(ref f0, ref f1) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Proc::Eq(ref f0, ref f1) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Proc::Ne(ref f0, ref f1) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Proc::Gt(ref f0, ref f1) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Proc::Lt(ref f0, ref f1) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Proc::GtEq(ref f0, ref f1) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Proc::LtEq(ref f0, ref f1) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Proc::Not(ref f0) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Proc::And(ref f0, ref f1) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Proc::Or(ref f0, ref f1) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Proc::ConcatStr(ref f0, ref f1) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Proc::Len(ref f0) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Proc::ToInt(ref f0) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Proc::ToFloat(ref f0) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Proc::ToBool(ref f0) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Proc::ToStr(ref f0) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Proc::PNew(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::ApplyProc(ref lam, ref arg) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Proc::MApplyProc(ref lam, ref args) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.extend(args.iter().cloned());
        },
        Proc::LamProc(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::MLamProc(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::ApplyName(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyName(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::LamName(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::MLamName(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::ApplyInt(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyInt(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::LamInt(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::MLamInt(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::ApplyFloat(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyFloat(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::LamFloat(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::MLamFloat(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::ApplyBool(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyBool(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::LamBool(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::MLamBool(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::ApplyStr(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyStr(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::LamStr(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::MLamStr(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_PROC.with(| p | p.set(buf)); iter_buf }.into_iter();

name(sub.clone()) <--
    proc(t),
    for sub in { std::thread_local! { static POOL_PROC_NAME : std::cell::Cell < Vec < Name >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_NAME.with(| p | p.take()); buf.clear(); match t {
        Proc::PDrop(ref f0) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Proc::POutput(ref f0, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Proc::ApplyName(_, ref arg) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Proc::MApplyName(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_NAME.with(| p | p.set(buf)); iter_buf }.into_iter();

int(sub.clone()) <--
    proc(t),
    for sub in { std::thread_local! { static POOL_PROC_INT : std::cell::Cell < Vec < Int >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_INT.with(| p | p.take()); buf.clear(); match t {
        Proc::CastInt(ref f0) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Proc::ApplyInt(_, ref arg) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Proc::MApplyInt(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_INT.with(| p | p.set(buf)); iter_buf }.into_iter();

float(sub.clone()) <--
    proc(t),
    for sub in { std::thread_local! { static POOL_PROC_FLOAT : std::cell::Cell < Vec < Float >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_FLOAT.with(| p | p.take()); buf.clear(); match t {
        Proc::CastFloat(ref f0) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Proc::ApplyFloat(_, ref arg) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Proc::MApplyFloat(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter();

bool(sub.clone()) <--
    proc(t),
    for sub in { std::thread_local! { static POOL_PROC_BOOL : std::cell::Cell < Vec < Bool >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_BOOL.with(| p | p.take()); buf.clear(); match t {
        Proc::CastBool(ref f0) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Proc::ApplyBool(_, ref arg) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Proc::MApplyBool(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter();

str(sub.clone()) <--
    proc(t),
    for sub in { std::thread_local! { static POOL_PROC_STR : std::cell::Cell < Vec < Str >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_STR.with(| p | p.take()); buf.clear(); match t {
        Proc::CastStr(ref f0) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Proc::ApplyStr(_, ref arg) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Proc::MApplyStr(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_STR.with(| p | p.set(buf)); iter_buf }.into_iter();

proc(sub.clone()) <--
    name(t),
    for sub in { std::thread_local! { static POOL_NAME_PROC : std::cell::Cell < Vec < Proc >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_NAME_PROC.with(| p | p.take()); buf.clear(); match t {
        Name::NQuote(ref f0) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Name::ApplyProc(_, ref arg) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Name::MApplyProc(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_NAME_PROC.with(| p | p.set(buf)); iter_buf }.into_iter();

name(sub.clone()) <--
    name(t),
    for sub in { std::thread_local! { static POOL_NAME_NAME : std::cell::Cell < Vec < Name >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_NAME_NAME.with(| p | p.take()); buf.clear(); match t {
        Name::ApplyProc(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::MApplyProc(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::LamProc(ref scope) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Name::MLamProc(ref scope) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Name::ApplyName(ref lam, ref arg) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Name::MApplyName(ref lam, ref args) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.extend(args.iter().cloned());
        },
        Name::LamName(ref scope) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Name::MLamName(ref scope) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Name::ApplyInt(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::MApplyInt(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::LamInt(ref scope) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Name::MLamInt(ref scope) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Name::ApplyFloat(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::MApplyFloat(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::LamFloat(ref scope) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Name::MLamFloat(ref scope) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Name::ApplyBool(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::MApplyBool(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::LamBool(ref scope) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Name::MLamBool(ref scope) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Name::ApplyStr(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::MApplyStr(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::LamStr(ref scope) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Name::MLamStr(ref scope) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_NAME_NAME.with(| p | p.set(buf)); iter_buf }.into_iter();

int(sub.clone()) <--
    name(t),
    for sub in { std::thread_local! { static POOL_NAME_INT : std::cell::Cell < Vec < Int >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_NAME_INT.with(| p | p.take()); buf.clear(); match t {
        Name::ApplyInt(_, ref arg) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Name::MApplyInt(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_NAME_INT.with(| p | p.set(buf)); iter_buf }.into_iter();

float(sub.clone()) <--
    name(t),
    for sub in { std::thread_local! { static POOL_NAME_FLOAT : std::cell::Cell < Vec < Float >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_NAME_FLOAT.with(| p | p.take()); buf.clear(); match t {
        Name::ApplyFloat(_, ref arg) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Name::MApplyFloat(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_NAME_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter();

bool(sub.clone()) <--
    name(t),
    for sub in { std::thread_local! { static POOL_NAME_BOOL : std::cell::Cell < Vec < Bool >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_NAME_BOOL.with(| p | p.take()); buf.clear(); match t {
        Name::ApplyBool(_, ref arg) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Name::MApplyBool(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_NAME_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter();

str(sub.clone()) <--
    name(t),
    for sub in { std::thread_local! { static POOL_NAME_STR : std::cell::Cell < Vec < Str >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_NAME_STR.with(| p | p.take()); buf.clear(); match t {
        Name::ApplyStr(_, ref arg) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Name::MApplyStr(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_NAME_STR.with(| p | p.set(buf)); iter_buf }.into_iter();

int(sub.clone()) <--
    int(t),
    for sub in { std::thread_local! { static POOL_INT_INT : std::cell::Cell < Vec < Int >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_INT.with(| p | p.take()); buf.clear(); match t {
        Int::ApplyProc(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::MApplyProc(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::LamProc(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::MLamProc(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::ApplyName(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::MApplyName(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::LamName(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::MLamName(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::ApplyInt(ref lam, ref arg) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Int::MApplyInt(ref lam, ref args) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.extend(args.iter().cloned());
        },
        Int::LamInt(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::MLamInt(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::ApplyFloat(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::MApplyFloat(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::LamFloat(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::MLamFloat(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::ApplyBool(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::MApplyBool(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::LamBool(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::MLamBool(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::ApplyStr(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::MApplyStr(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::LamStr(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::MLamStr(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_INT.with(| p | p.set(buf)); iter_buf }.into_iter();

float(sub.clone()) <--
    float(t),
    for sub in { std::thread_local! { static POOL_FLOAT_FLOAT : std::cell::Cell < Vec < Float >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_FLOAT.with(| p | p.take()); buf.clear(); match t {
        Float::ApplyProc(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::MApplyProc(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::LamProc(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::MLamProc(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::ApplyName(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::MApplyName(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::LamName(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::MLamName(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::ApplyInt(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::MApplyInt(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::LamInt(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::MLamInt(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::ApplyFloat(ref lam, ref arg) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Float::MApplyFloat(ref lam, ref args) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.extend(args.iter().cloned());
        },
        Float::LamFloat(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::MLamFloat(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::ApplyBool(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::MApplyBool(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::LamBool(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::MLamBool(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::ApplyStr(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::MApplyStr(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::LamStr(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::MLamStr(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter();

bool(sub.clone()) <--
    bool(t),
    for sub in { std::thread_local! { static POOL_BOOL_BOOL : std::cell::Cell < Vec < Bool >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_BOOL.with(| p | p.take()); buf.clear(); match t {
        Bool::ApplyProc(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::MApplyProc(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::LamProc(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::MLamProc(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::ApplyName(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::MApplyName(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::LamName(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::MLamName(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::ApplyInt(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::MApplyInt(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::LamInt(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::MLamInt(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::ApplyFloat(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::MApplyFloat(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::LamFloat(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::MLamFloat(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::ApplyBool(ref lam, ref arg) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Bool::MApplyBool(ref lam, ref args) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.extend(args.iter().cloned());
        },
        Bool::LamBool(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::MLamBool(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::ApplyStr(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::MApplyStr(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::LamStr(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::MLamStr(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter();

str(sub.clone()) <--
    str(t),
    for sub in { std::thread_local! { static POOL_STR_STR : std::cell::Cell < Vec < Str >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_STR.with(| p | p.take()); buf.clear(); match t {
        Str::ApplyProc(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::MApplyProc(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::LamProc(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::MLamProc(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::ApplyName(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::MApplyName(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::LamName(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::MLamName(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::ApplyInt(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::MApplyInt(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::LamInt(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::MLamInt(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::ApplyFloat(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::MApplyFloat(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::LamFloat(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::MLamFloat(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::ApplyBool(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::MApplyBool(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::LamBool(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::MLamBool(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::ApplyStr(ref lam, ref arg) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Str::MApplyStr(ref lam, ref args) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.extend(args.iter().cloned());
        },
        Str::LamStr(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::MLamStr(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_STR.with(| p | p.set(buf)); iter_buf }.into_iter();

proc(c1.clone()) <--
    proc(c0),
    rw_proc(c0, c1);

ppar_contains(parent.clone(), elem.clone()) <--
    proc(parent),
    if let Proc::PPar(ref bag_field) = parent,
    for (elem, _count) in bag_field.iter();

proc(elem.clone()) <--
    ppar_contains(_parent, elem);

name(elem.clone()) <--
    proc(t),
    if let Proc::PInputs(ref vec_field, _) = t,
    for elem in vec_field.iter();

proc(Proc::MLamProc(scope.clone())) <--
    proc(t),
    if let Proc::PInputs(_, scope) = t;

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Proc::ApplyProc(_, arg) => Proc::ApplyProc(Box::new(new_lam.clone()), arg.clone()),
    Proc::MApplyProc(_, args) => Proc::MApplyProc(Box::new(new_lam.clone()), args.clone()),
    Proc::ApplyName(_, arg) => Proc::ApplyName(Box::new(new_lam.clone()), arg.clone()),
    Proc::MApplyName(_, args) => Proc::MApplyName(Box::new(new_lam.clone()), args.clone()),
    Proc::ApplyInt(_, arg) => Proc::ApplyInt(Box::new(new_lam.clone()), arg.clone()),
    Proc::MApplyInt(_, args) => Proc::MApplyInt(Box::new(new_lam.clone()), args.clone()),
    Proc::ApplyFloat(_, arg) => Proc::ApplyFloat(Box::new(new_lam.clone()), arg.clone()),
    Proc::MApplyFloat(_, args) => Proc::MApplyFloat(Box::new(new_lam.clone()), args.clone()),
    Proc::ApplyBool(_, arg) => Proc::ApplyBool(Box::new(new_lam.clone()), arg.clone()),
    Proc::MApplyBool(_, args) => Proc::MApplyBool(Box::new(new_lam.clone()), args.clone()),
    Proc::ApplyStr(_, arg) => Proc::ApplyStr(Box::new(new_lam.clone()), arg.clone()),
    Proc::MApplyStr(_, args) => Proc::MApplyStr(Box::new(new_lam.clone()), args.clone()),
    _ => unreachable!(),
},) <--
    proc(t),
    for lam in { std::thread_local! { static POOL_PROC_CONG_LAM : std::cell::Cell < Vec < Proc >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_CONG_LAM.with(| p | p.take()); buf.clear(); match t {
        Proc::ApplyProc(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyProc(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::ApplyName(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyName(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::ApplyInt(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyInt(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::ApplyFloat(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyFloat(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::ApplyBool(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyBool(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::ApplyStr(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyStr(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_CONG_LAM.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_proc(lam, new_lam);

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Proc::ApplyProc(lam, _) => Proc::ApplyProc(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    proc(t),
    for arg in { std::thread_local! { static POOL_PROC_CONG_ARG_PROC : std::cell::Cell < Vec < Proc >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_CONG_ARG_PROC.with(| p | p.take()); buf.clear(); match t {
        Proc::ApplyProc(_, ref arg) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_CONG_ARG_PROC.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_proc(arg, new_arg);

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Proc::ApplyName(lam, _) => Proc::ApplyName(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    proc(t),
    for arg in { std::thread_local! { static POOL_PROC_CONG_ARG_NAME : std::cell::Cell < Vec < Name >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_CONG_ARG_NAME.with(| p | p.take()); buf.clear(); match t {
        Proc::ApplyName(_, ref arg) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_CONG_ARG_NAME.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_name(arg, new_arg);

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Proc::ApplyInt(lam, _) => Proc::ApplyInt(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    proc(t),
    for arg in { std::thread_local! { static POOL_PROC_CONG_ARG_INT : std::cell::Cell < Vec < Int >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_CONG_ARG_INT.with(| p | p.take()); buf.clear(); match t {
        Proc::ApplyInt(_, ref arg) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_CONG_ARG_INT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_int(arg, new_arg);

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Proc::ApplyFloat(lam, _) => Proc::ApplyFloat(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    proc(t),
    for arg in { std::thread_local! { static POOL_PROC_CONG_ARG_FLOAT : std::cell::Cell < Vec < Float >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_CONG_ARG_FLOAT.with(| p | p.take()); buf.clear(); match t {
        Proc::ApplyFloat(_, ref arg) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_CONG_ARG_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_float(arg, new_arg);

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Proc::ApplyBool(lam, _) => Proc::ApplyBool(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    proc(t),
    for arg in { std::thread_local! { static POOL_PROC_CONG_ARG_BOOL : std::cell::Cell < Vec < Bool >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_CONG_ARG_BOOL.with(| p | p.take()); buf.clear(); match t {
        Proc::ApplyBool(_, ref arg) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_CONG_ARG_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_bool(arg, new_arg);

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Proc::ApplyStr(lam, _) => Proc::ApplyStr(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    proc(t),
    for arg in { std::thread_local! { static POOL_PROC_CONG_ARG_STR : std::cell::Cell < Vec < Str >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_CONG_ARG_STR.with(| p | p.take()); buf.clear(); match t {
        Proc::ApplyStr(_, ref arg) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_CONG_ARG_STR.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_str(arg, new_arg);

name(c1.clone()) <--
    name(c0),
    rw_name(c0, c1);

rw_name(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Name::ApplyProc(_, arg) => Name::ApplyProc(Box::new(new_lam.clone()), arg.clone()),
    Name::MApplyProc(_, args) => Name::MApplyProc(Box::new(new_lam.clone()), args.clone()),
    Name::ApplyName(_, arg) => Name::ApplyName(Box::new(new_lam.clone()), arg.clone()),
    Name::MApplyName(_, args) => Name::MApplyName(Box::new(new_lam.clone()), args.clone()),
    Name::ApplyInt(_, arg) => Name::ApplyInt(Box::new(new_lam.clone()), arg.clone()),
    Name::MApplyInt(_, args) => Name::MApplyInt(Box::new(new_lam.clone()), args.clone()),
    Name::ApplyFloat(_, arg) => Name::ApplyFloat(Box::new(new_lam.clone()), arg.clone()),
    Name::MApplyFloat(_, args) => Name::MApplyFloat(Box::new(new_lam.clone()), args.clone()),
    Name::ApplyBool(_, arg) => Name::ApplyBool(Box::new(new_lam.clone()), arg.clone()),
    Name::MApplyBool(_, args) => Name::MApplyBool(Box::new(new_lam.clone()), args.clone()),
    Name::ApplyStr(_, arg) => Name::ApplyStr(Box::new(new_lam.clone()), arg.clone()),
    Name::MApplyStr(_, args) => Name::MApplyStr(Box::new(new_lam.clone()), args.clone()),
    _ => unreachable!(),
},) <--
    name(t),
    for lam in { std::thread_local! { static POOL_NAME_CONG_LAM : std::cell::Cell < Vec < Name >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_NAME_CONG_LAM.with(| p | p.take()); buf.clear(); match t {
        Name::ApplyProc(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::MApplyProc(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::ApplyName(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::MApplyName(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::ApplyInt(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::MApplyInt(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::ApplyFloat(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::MApplyFloat(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::ApplyBool(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::MApplyBool(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::ApplyStr(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Name::MApplyStr(ref lam, _) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_NAME_CONG_LAM.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_name(lam, new_lam);

rw_name(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Name::ApplyProc(lam, _) => Name::ApplyProc(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    name(t),
    for arg in { std::thread_local! { static POOL_NAME_CONG_ARG_PROC : std::cell::Cell < Vec < Proc >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_NAME_CONG_ARG_PROC.with(| p | p.take()); buf.clear(); match t {
        Name::ApplyProc(_, ref arg) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_NAME_CONG_ARG_PROC.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_proc(arg, new_arg);

rw_name(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Name::ApplyName(lam, _) => Name::ApplyName(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    name(t),
    for arg in { std::thread_local! { static POOL_NAME_CONG_ARG_NAME : std::cell::Cell < Vec < Name >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_NAME_CONG_ARG_NAME.with(| p | p.take()); buf.clear(); match t {
        Name::ApplyName(_, ref arg) => {
            buf.push(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_NAME_CONG_ARG_NAME.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_name(arg, new_arg);

rw_name(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Name::ApplyInt(lam, _) => Name::ApplyInt(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    name(t),
    for arg in { std::thread_local! { static POOL_NAME_CONG_ARG_INT : std::cell::Cell < Vec < Int >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_NAME_CONG_ARG_INT.with(| p | p.take()); buf.clear(); match t {
        Name::ApplyInt(_, ref arg) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_NAME_CONG_ARG_INT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_int(arg, new_arg);

rw_name(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Name::ApplyFloat(lam, _) => Name::ApplyFloat(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    name(t),
    for arg in { std::thread_local! { static POOL_NAME_CONG_ARG_FLOAT : std::cell::Cell < Vec < Float >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_NAME_CONG_ARG_FLOAT.with(| p | p.take()); buf.clear(); match t {
        Name::ApplyFloat(_, ref arg) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_NAME_CONG_ARG_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_float(arg, new_arg);

rw_name(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Name::ApplyBool(lam, _) => Name::ApplyBool(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    name(t),
    for arg in { std::thread_local! { static POOL_NAME_CONG_ARG_BOOL : std::cell::Cell < Vec < Bool >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_NAME_CONG_ARG_BOOL.with(| p | p.take()); buf.clear(); match t {
        Name::ApplyBool(_, ref arg) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_NAME_CONG_ARG_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_bool(arg, new_arg);

rw_name(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Name::ApplyStr(lam, _) => Name::ApplyStr(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    name(t),
    for arg in { std::thread_local! { static POOL_NAME_CONG_ARG_STR : std::cell::Cell < Vec < Str >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_NAME_CONG_ARG_STR.with(| p | p.take()); buf.clear(); match t {
        Name::ApplyStr(_, ref arg) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_NAME_CONG_ARG_STR.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_str(arg, new_arg);

int(c1.clone()) <--
    int(c0),
    rw_int(c0, c1);

rw_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Int::ApplyInt(_, arg) => Int::ApplyInt(Box::new(new_lam.clone()), arg.clone()),
    Int::MApplyInt(_, args) => Int::MApplyInt(Box::new(new_lam.clone()), args.clone()),
    _ => unreachable!(),
},) <--
    int(t),
    for lam in { std::thread_local! { static POOL_INT_CONG_LAM : std::cell::Cell < Vec < Int >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_CONG_LAM.with(| p | p.take()); buf.clear(); match t {
        Int::ApplyInt(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::MApplyInt(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_CONG_LAM.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_int(lam, new_lam);

rw_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Int::ApplyInt(lam, _) => Int::ApplyInt(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    int(t),
    for arg in { std::thread_local! { static POOL_INT_CONG_ARG_INT : std::cell::Cell < Vec < Int >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_CONG_ARG_INT.with(| p | p.take()); buf.clear(); match t {
        Int::ApplyInt(_, ref arg) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_CONG_ARG_INT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_int(arg, new_arg);

float(c1.clone()) <--
    float(c0),
    rw_float(c0, c1);

rw_float(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Float::ApplyFloat(_, arg) => Float::ApplyFloat(Box::new(new_lam.clone()), arg.clone()),
    Float::MApplyFloat(_, args) => Float::MApplyFloat(Box::new(new_lam.clone()), args.clone()),
    _ => unreachable!(),
},) <--
    float(t),
    for lam in { std::thread_local! { static POOL_FLOAT_CONG_LAM : std::cell::Cell < Vec < Float >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_CONG_LAM.with(| p | p.take()); buf.clear(); match t {
        Float::ApplyFloat(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::MApplyFloat(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_CONG_LAM.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_float(lam, new_lam);

rw_float(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Float::ApplyFloat(lam, _) => Float::ApplyFloat(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    float(t),
    for arg in { std::thread_local! { static POOL_FLOAT_CONG_ARG_FLOAT : std::cell::Cell < Vec < Float >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_CONG_ARG_FLOAT.with(| p | p.take()); buf.clear(); match t {
        Float::ApplyFloat(_, ref arg) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_CONG_ARG_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_float(arg, new_arg);

bool(c1.clone()) <--
    bool(c0),
    rw_bool(c0, c1);

rw_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Bool::ApplyBool(_, arg) => Bool::ApplyBool(Box::new(new_lam.clone()), arg.clone()),
    Bool::MApplyBool(_, args) => Bool::MApplyBool(Box::new(new_lam.clone()), args.clone()),
    _ => unreachable!(),
},) <--
    bool(t),
    for lam in { std::thread_local! { static POOL_BOOL_CONG_LAM : std::cell::Cell < Vec < Bool >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_CONG_LAM.with(| p | p.take()); buf.clear(); match t {
        Bool::ApplyBool(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::MApplyBool(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_CONG_LAM.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_bool(lam, new_lam);

rw_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Bool::ApplyBool(lam, _) => Bool::ApplyBool(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    bool(t),
    for arg in { std::thread_local! { static POOL_BOOL_CONG_ARG_BOOL : std::cell::Cell < Vec < Bool >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_CONG_ARG_BOOL.with(| p | p.take()); buf.clear(); match t {
        Bool::ApplyBool(_, ref arg) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_CONG_ARG_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_bool(arg, new_arg);

str(c1.clone()) <--
    str(c0),
    rw_str(c0, c1);

rw_str(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Str::ApplyStr(_, arg) => Str::ApplyStr(Box::new(new_lam.clone()), arg.clone()),
    Str::MApplyStr(_, args) => Str::MApplyStr(Box::new(new_lam.clone()), args.clone()),
    _ => unreachable!(),
},) <--
    str(t),
    for lam in { std::thread_local! { static POOL_STR_CONG_LAM : std::cell::Cell < Vec < Str >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_CONG_LAM.with(| p | p.take()); buf.clear(); match t {
        Str::ApplyStr(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::MApplyStr(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_CONG_LAM.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_str(lam, new_lam);

rw_str(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Str::ApplyStr(lam, _) => Str::ApplyStr(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    str(t),
    for arg in { std::thread_local! { static POOL_STR_CONG_ARG_STR : std::cell::Cell < Vec < Str >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_CONG_ARG_STR.with(| p | p.take()); buf.clear(); match t {
        Str::ApplyStr(_, ref arg) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_CONG_ARG_STR.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_str(arg, new_arg);


    // Equation rules
eq_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    proc(t);

eq_name(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), < Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    name(t);

eq_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    int(t);

eq_float(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    float(t);

eq_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    bool(t);

eq_str(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    str(t);

eq_name(< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    name(s),
    name(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_NAME_EQ_CONG_0 : std::cell::Cell < Vec < (Proc, Proc) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_NAME_EQ_CONG_0.with(| p | p.take()); buf.clear(); match (s, t) {
        (Name::NQuote(ref sf0), Name::NQuote(ref tf0)) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_NAME_EQ_CONG_0.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_proc(s_f0, t_f0);

eq_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    proc(s),
    proc(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_PROC_EQ_CONG_1 : std::cell::Cell < Vec < (Bool, Bool) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_EQ_CONG_1.with(| p | p.take()); buf.clear(); match (s, t) {
        (Proc::CastBool(ref sf0), Proc::CastBool(ref tf0)) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_EQ_CONG_1.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_bool(s_f0, t_f0);

eq_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    proc(s),
    proc(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_PROC_EQ_CONG_2 : std::cell::Cell < Vec < (Float, Float) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_EQ_CONG_2.with(| p | p.take()); buf.clear(); match (s, t) {
        (Proc::CastFloat(ref sf0), Proc::CastFloat(ref tf0)) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_EQ_CONG_2.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_float(s_f0, t_f0);

eq_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    proc(s),
    proc(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_PROC_EQ_CONG_3 : std::cell::Cell < Vec < (Int, Int) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_EQ_CONG_3.with(| p | p.take()); buf.clear(); match (s, t) {
        (Proc::CastInt(ref sf0), Proc::CastInt(ref tf0)) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_EQ_CONG_3.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_int(s_f0, t_f0);

eq_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    proc(s),
    proc(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_PROC_EQ_CONG_4 : std::cell::Cell < Vec < (Name, Name) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_EQ_CONG_4.with(| p | p.take()); buf.clear(); match (s, t) {
        (Proc::PDrop(ref sf0), Proc::PDrop(ref tf0)) => {
            buf.push((< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_EQ_CONG_4.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_name(s_f0, t_f0);

eq_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    proc(s),
    proc(t),
    for (s_f0, s_f1, t_f0, t_f1) in { std::thread_local! { static POOL_PROC_EQ_CONG_5 : std::cell::Cell < Vec < (Name, Proc, Name, Proc) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_EQ_CONG_5.with(| p | p.take()); buf.clear(); match (s, t) {
        (Proc::POutput(ref sf0, ref sf1), Proc::POutput(ref tf0, ref tf1)) => {
            buf.push((< Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Name as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_EQ_CONG_5.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_name(s_f0, t_f0),
    eq_proc(s_f1, t_f1);

eq_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    proc(s),
    proc(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_PROC_EQ_CONG_6 : std::cell::Cell < Vec < (Proc, Proc) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_EQ_CONG_6.with(| p | p.take()); buf.clear(); match (s, t) {
        (Proc::Not(ref sf0), Proc::Not(ref tf0)) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        (Proc::Len(ref sf0), Proc::Len(ref tf0)) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        (Proc::ToInt(ref sf0), Proc::ToInt(ref tf0)) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        (Proc::ToFloat(ref sf0), Proc::ToFloat(ref tf0)) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        (Proc::ToBool(ref sf0), Proc::ToBool(ref tf0)) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        (Proc::ToStr(ref sf0), Proc::ToStr(ref tf0)) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_EQ_CONG_6.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_proc(s_f0, t_f0);

eq_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    proc(s),
    proc(t),
    for (s_f0, s_f1, t_f0, t_f1) in { std::thread_local! { static POOL_PROC_EQ_CONG_7 : std::cell::Cell < Vec < (Proc, Proc, Proc, Proc) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_EQ_CONG_7.with(| p | p.take()); buf.clear(); match (s, t) {
        (Proc::Add(ref sf0, ref sf1), Proc::Add(ref tf0, ref tf1)) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Proc::Sub(ref sf0, ref sf1), Proc::Sub(ref tf0, ref tf1)) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Proc::Mul(ref sf0, ref sf1), Proc::Mul(ref tf0, ref tf1)) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Proc::Div(ref sf0, ref sf1), Proc::Div(ref tf0, ref tf1)) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Proc::Eq(ref sf0, ref sf1), Proc::Eq(ref tf0, ref tf1)) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Proc::Ne(ref sf0, ref sf1), Proc::Ne(ref tf0, ref tf1)) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Proc::Gt(ref sf0, ref sf1), Proc::Gt(ref tf0, ref tf1)) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Proc::Lt(ref sf0, ref sf1), Proc::Lt(ref tf0, ref tf1)) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Proc::GtEq(ref sf0, ref sf1), Proc::GtEq(ref tf0, ref tf1)) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Proc::LtEq(ref sf0, ref sf1), Proc::LtEq(ref tf0, ref tf1)) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Proc::And(ref sf0, ref sf1), Proc::And(ref tf0, ref tf1)) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Proc::Or(ref sf0, ref sf1), Proc::Or(ref tf0, ref tf1)) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Proc::ConcatStr(ref sf0, ref sf1), Proc::ConcatStr(ref tf0, ref tf1)) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_EQ_CONG_7.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_proc(s_f0, t_f0),
    eq_proc(s_f1, t_f1);

eq_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    proc(s),
    proc(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_PROC_EQ_CONG_8 : std::cell::Cell < Vec < (Str, Str) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_EQ_CONG_8.with(| p | p.take()); buf.clear(); match (s, t) {
        (Proc::CastStr(ref sf0), Proc::CastStr(ref tf0)) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_EQ_CONG_8.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_str(s_f0, t_f0);

eq_name(s.clone(), t.clone()),
name(t.clone()) <--
    name(s),
    if let Name::NQuote(ref s_f0) = s,
    let s_f0_deref = &** s_f0,
    if let Proc::PDrop(ref s_f0_deref_f0) = s_f0_deref,
    let s_f0_deref_f0_deref = &** s_f0_deref_f0,
    let t = ((s_f0_deref_f0_deref.clone()).clone()).normalize();


    // Rewrite rules
rw_proc(s_orig.clone(), t) <--
    eq_proc(s_orig, s),
    if let Proc::PPar(ref s_f0) = s,
    for (s_f0_e0, _count_0) in s_f0.iter(),
    if let Proc::PInputs(ref s_f0_e0_f0, ref s_f0_e0_f1) = s_f0_e0,
    let s_f0_e0_f1_binder = s_f0_e0_f1.unsafe_pattern().clone(),
    let s_f0_e0_f1_body_boxed = s_f0_e0_f1.unsafe_body(),
    let s_f0_e0_f1_body = &** s_f0_e0_f1_body_boxed,
    let __all_matchings_1 = { let __ctx_vec : Vec < _ > = s_f0.iter().collect(); let mut __candidates = Vec::new(); for __zip_first_1 in s_f0_e0_f0.clone().iter() { let mut __row = Vec::new(); for (__idx, (__zip_search_1, _)) in __ctx_vec.iter().enumerate() { if let Proc::POutput(ref __match_f0_1, ref __match_f1_1) = __zip_search_1 { if &** __match_f0_1 == __zip_first_1 { __row.push((__idx, (** __match_f1_1).clone())); } } } __candidates.push(__row); } mettail_runtime::enumerate_matchings(& __candidates) },
    for (__zip_collected_1, __map_matched_indices_1) in __all_matchings_1.into_iter(),
    if __zip_collected_1.len() == s_f0_e0_f0.clone().len(),
    let s_f0_rest = { let mut bag = s_f0.clone(); bag.remove(& s_f0_e0); let __ctx_vec : Vec < _ > = s_f0.iter().collect(); for __idx in __map_matched_indices_1.iter() { if let Some((elem, _)) = __ctx_vec.get(* __idx) { bag.remove(elem); } } bag },
    let t = (Proc::PPar({ let mut bag = (s_f0_rest.clone()).clone(); Proc::insert_into_ppar(& mut bag, { let (__binders, __body) = ((s_f0_e0_f1.clone()).clone()).unbind(); let __vars : Vec < & mettail_runtime::FreeVar < String >> = __binders.iter().map(| b | & b.0).collect(); let __repls = { let __map_coll = (__zip_collected_1.clone()).clone(); __map_coll.iter().map(| __elem | Name::NQuote(Box::new((__elem).clone()))).collect::< Vec < _ >> () }; (* __body).multi_substitute_name(& __vars, & __repls) }); bag })).normalize();

rw_proc(s_orig.clone(), t) <--
    eq_proc(s_orig, s),
    if let Proc::PDrop(ref s_f0) = s,
    let s_f0_deref = &** s_f0,
    if let Name::NQuote(ref s_f0_deref_f0) = s_f0_deref,
    let s_f0_deref_f0_deref = &** s_f0_deref_f0,
    let t = ((s_f0_deref_f0_deref.clone()).clone()).normalize();

fold_proc(t.clone(), t.clone()) <--
    proc(t),
    if (match t {
        Proc::PZero => true,
        Proc::PDrop(_) => true,
        Proc::PPar(_) => true,
        Proc::POutput(_, _) => true,
        Proc::PInputs(_, _) => true,
        Proc::CastInt(_) => true,
        Proc::CastFloat(_) => true,
        Proc::CastBool(_) => true,
        Proc::CastStr(_) => true,
        Proc::PNew(_) => true,
        Proc::Err => true,
        _ => false,
    });

fold_proc(s.clone(), res) <--
    proc(s),
    if let Proc::Add(left, right) = s,
    fold_proc(left.as_ref().clone(), lv),
    fold_proc(right.as_ref().clone(), rv),
    let a = lv,
    let b = rv,
    let res = ({ match (& a, & b) {
        (Proc::CastInt(a), Proc::CastInt(b)) => Proc::CastInt(Box::new(* a.clone() + * b.clone())),
        (Proc::CastFloat(a), Proc::CastFloat(b)) => Proc::CastFloat(Box::new(* a.clone() + * b.clone())),
        _ => Proc::Err,
    } }),
    if (match & res { Proc::Err => false, _ => true });

fold_proc(s.clone(), res) <--
    proc(s),
    if let Proc::Sub(left, right) = s,
    fold_proc(left.as_ref().clone(), lv),
    fold_proc(right.as_ref().clone(), rv),
    let a = lv,
    let b = rv,
    let res = ({ match (& a, & b) {
        (Proc::CastInt(a), Proc::CastInt(b)) => Proc::CastInt(Box::new(* a.clone() - * b.clone())),
        (Proc::CastFloat(a), Proc::CastFloat(b)) => Proc::CastFloat(Box::new(* a.clone() - * b.clone())),
        _ => Proc::Err,
    } }),
    if (match & res { Proc::Err => false, _ => true });

fold_proc(s.clone(), res) <--
    proc(s),
    if let Proc::Mul(left, right) = s,
    fold_proc(left.as_ref().clone(), lv),
    fold_proc(right.as_ref().clone(), rv),
    let a = lv,
    let b = rv,
    let res = ({ match (& a, & b) {
        (Proc::CastInt(a), Proc::CastInt(b)) => Proc::CastInt(Box::new(* a.clone() * * b.clone())),
        (Proc::CastFloat(a), Proc::CastFloat(b)) => Proc::CastFloat(Box::new(* a.clone() * * b.clone())),
        _ => Proc::Err,
    } }),
    if (match & res { Proc::Err => false, _ => true });

fold_proc(s.clone(), res) <--
    proc(s),
    if let Proc::Div(left, right) = s,
    fold_proc(left.as_ref().clone(), lv),
    fold_proc(right.as_ref().clone(), rv),
    let a = lv,
    let b = rv,
    let res = ({ match (& a, & b) {
        (Proc::CastInt(a), Proc::CastInt(b)) => Proc::CastInt(Box::new(* a.clone() / * b.clone())),
        (Proc::CastFloat(a), Proc::CastFloat(b)) => Proc::CastFloat(Box::new(* a.clone() / * b.clone())),
        _ => Proc::Err,
    } }),
    if (match & res { Proc::Err => false, _ => true });

fold_proc(s.clone(), res) <--
    proc(s),
    if let Proc::Eq(left, right) = s,
    fold_proc(left.as_ref().clone(), lv),
    fold_proc(right.as_ref().clone(), rv),
    let a = lv,
    let b = rv,
    let res = ({ match (& a, & b) {
        (Proc::CastInt(a), Proc::CastInt(b)) => match (&** a, &** b) { (Int::NumLit(i), Int::NumLit(j)) => Proc::CastBool(Box::new(Bool::BoolLit(i == j))), _ => Proc::Err, },
        (Proc::CastFloat(a), Proc::CastFloat(b)) => match (&** a, &** b) { (Float::FloatLit(x), Float::FloatLit(y)) => Proc::CastBool(Box::new(Bool::BoolLit(x == y))), _ => Proc::Err, },
        _ => Proc::Err,
    } }),
    if (match & res { Proc::Err => false, _ => true });

fold_proc(s.clone(), res) <--
    proc(s),
    if let Proc::Ne(left, right) = s,
    fold_proc(left.as_ref().clone(), lv),
    fold_proc(right.as_ref().clone(), rv),
    let a = lv,
    let b = rv,
    let res = ({ match (& a, & b) {
        (Proc::CastInt(a), Proc::CastInt(b)) => match (&** a, &** b) { (Int::NumLit(i), Int::NumLit(j)) => Proc::CastBool(Box::new(Bool::BoolLit(i != j))), _ => Proc::Err, },
        (Proc::CastFloat(a), Proc::CastFloat(b)) => match (&** a, &** b) { (Float::FloatLit(x), Float::FloatLit(y)) => Proc::CastBool(Box::new(Bool::BoolLit(x != y))), _ => Proc::Err, },
        _ => Proc::Err,
    } }),
    if (match & res { Proc::Err => false, _ => true });

fold_proc(s.clone(), res) <--
    proc(s),
    if let Proc::Gt(left, right) = s,
    fold_proc(left.as_ref().clone(), lv),
    fold_proc(right.as_ref().clone(), rv),
    let a = lv,
    let b = rv,
    let res = ({ match (& a, & b) {
        (Proc::CastInt(a), Proc::CastInt(b)) => match (&** a, &** b) { (Int::NumLit(i), Int::NumLit(j)) => Proc::CastBool(Box::new(Bool::BoolLit(i > j))), _ => Proc::Err, },
        (Proc::CastFloat(a), Proc::CastFloat(b)) => match (&** a, &** b) { (Float::FloatLit(x), Float::FloatLit(y)) => Proc::CastBool(Box::new(Bool::BoolLit(x > y))), _ => Proc::Err, },
        _ => Proc::Err,
    } }),
    if (match & res { Proc::Err => false, _ => true });

fold_proc(s.clone(), res) <--
    proc(s),
    if let Proc::Lt(left, right) = s,
    fold_proc(left.as_ref().clone(), lv),
    fold_proc(right.as_ref().clone(), rv),
    let a = lv,
    let b = rv,
    let res = ({ match (& a, & b) {
        (Proc::CastInt(a), Proc::CastInt(b)) => match (&** a, &** b) { (Int::NumLit(i), Int::NumLit(j)) => Proc::CastBool(Box::new(Bool::BoolLit(i < j))), _ => Proc::Err, },
        (Proc::CastFloat(a), Proc::CastFloat(b)) => match (&** a, &** b) { (Float::FloatLit(x), Float::FloatLit(y)) => Proc::CastBool(Box::new(Bool::BoolLit(x < y))), _ => Proc::Err, },
        _ => Proc::Err,
    } }),
    if (match & res { Proc::Err => false, _ => true });

fold_proc(s.clone(), res) <--
    proc(s),
    if let Proc::GtEq(left, right) = s,
    fold_proc(left.as_ref().clone(), lv),
    fold_proc(right.as_ref().clone(), rv),
    let a = lv,
    let b = rv,
    let res = ({ match (& a, & b) {
        (Proc::CastInt(a), Proc::CastInt(b)) => match (&** a, &** b) { (Int::NumLit(i), Int::NumLit(j)) => Proc::CastBool(Box::new(Bool::BoolLit(i >= j))), _ => Proc::Err, },
        (Proc::CastFloat(a), Proc::CastFloat(b)) => match (&** a, &** b) { (Float::FloatLit(x), Float::FloatLit(y)) => Proc::CastBool(Box::new(Bool::BoolLit(x >= y))), _ => Proc::Err, },
        _ => Proc::Err,
    } }),
    if (match & res { Proc::Err => false, _ => true });

fold_proc(s.clone(), res) <--
    proc(s),
    if let Proc::LtEq(left, right) = s,
    fold_proc(left.as_ref().clone(), lv),
    fold_proc(right.as_ref().clone(), rv),
    let a = lv,
    let b = rv,
    let res = ({ match (& a, & b) {
        (Proc::CastInt(a), Proc::CastInt(b)) => match (&** a, &** b) { (Int::NumLit(i), Int::NumLit(j)) => Proc::CastBool(Box::new(Bool::BoolLit(i <= j))), _ => Proc::Err, },
        (Proc::CastFloat(a), Proc::CastFloat(b)) => match (&** a, &** b) { (Float::FloatLit(x), Float::FloatLit(y)) => Proc::CastBool(Box::new(Bool::BoolLit(x <= y))), _ => Proc::Err, },
        _ => Proc::Err,
    } }),
    if (match & res { Proc::Err => false, _ => true });

fold_proc(s.clone(), res) <--
    proc(s),
    if let Proc::Not(inner) = s,
    fold_proc(inner.as_ref().clone(), lv),
    let a = lv,
    let res = ({ match & a {
        Proc::CastBool(b) => match &** b { Bool::BoolLit(v) => Proc::CastBool(Box::new(Bool::BoolLit(! v))), _ => Proc::Err, },
        _ => Proc::Err,
    } }),
    if (match & res { Proc::Err => false, _ => true });

fold_proc(s.clone(), res) <--
    proc(s),
    if let Proc::And(left, right) = s,
    fold_proc(left.as_ref().clone(), lv),
    fold_proc(right.as_ref().clone(), rv),
    let a = lv,
    let b = rv,
    let res = ({ match (& a, & b) {
        (Proc::CastBool(a), Proc::CastBool(b)) => match (&** a, &** b) { (Bool::BoolLit(x), Bool::BoolLit(y)) => Proc::CastBool(Box::new(Bool::BoolLit(* x &&* y))), _ => Proc::Err, },
        _ => Proc::Err,
    } }),
    if (match & res { Proc::Err => false, _ => true });

fold_proc(s.clone(), res) <--
    proc(s),
    if let Proc::Or(left, right) = s,
    fold_proc(left.as_ref().clone(), lv),
    fold_proc(right.as_ref().clone(), rv),
    let a = lv,
    let b = rv,
    let res = ({ match (& a, & b) {
        (Proc::CastBool(a), Proc::CastBool(b)) => match (&** a, &** b) { (Bool::BoolLit(x), Bool::BoolLit(y)) => Proc::CastBool(Box::new(Bool::BoolLit(* x || * y))), _ => Proc::Err, },
        _ => Proc::Err,
    } }),
    if (match & res { Proc::Err => false, _ => true });

fold_proc(s.clone(), res) <--
    proc(s),
    if let Proc::ConcatStr(left, right) = s,
    fold_proc(left.as_ref().clone(), lv),
    fold_proc(right.as_ref().clone(), rv),
    let a = lv,
    let b = rv,
    let res = ({ match (& a, & b) {
        (Proc::CastStr(a), Proc::CastStr(b)) => match (&** a, &** b) { (Str::StringLit(x), Str::StringLit(y)) => Proc::CastStr(Box::new(Str::StringLit(format!("{}{}", x, y)))), _ => Proc::Err, },
        _ => Proc::Err,
    } }),
    if (match & res { Proc::Err => false, _ => true });

fold_proc(s.clone(), res) <--
    proc(s),
    if let Proc::Len(inner) = s,
    fold_proc(inner.as_ref().clone(), lv),
    let p = lv,
    let res = ({ match & p {
        Proc::CastStr(inner) => match &** inner { Str::StringLit(x) => Proc::CastInt(Box::new(Int::NumLit(x.len() as i64))), _ => Proc::Err, },
        _ => Proc::Err,
    } }),
    if (match & res { Proc::Err => false, _ => true });

fold_proc(s.clone(), res) <--
    proc(s),
    if let Proc::ToInt(inner) = s,
    fold_proc(inner.as_ref().clone(), lv),
    let p = lv,
    let res = ({ match & p {
        Proc::CastInt(x) => Proc::CastInt(x.clone()),
        Proc::CastFloat(x) => match &** x { Float::FloatLit(f) => Proc::CastInt(Box::new(Int::NumLit(f.get() as i64))), _ => Proc::Err, },
        Proc::CastBool(x) => match &** x { Bool::BoolLit(b) => Proc::CastInt(Box::new(Int::NumLit(if * b { 1 } else { 0 }))), _ => Proc::Err, },
        Proc::CastStr(x) => match &** x { Str::StringLit(s) => Proc::CastInt(Box::new(Int::NumLit(s.parse().unwrap_or(0)))), _ => Proc::Err, },
        _ => Proc::Err,
    } }),
    if (match & res { Proc::Err => false, _ => true });

fold_proc(s.clone(), res) <--
    proc(s),
    if let Proc::ToFloat(inner) = s,
    fold_proc(inner.as_ref().clone(), lv),
    let p = lv,
    let res = ({ match & p {
        Proc::CastFloat(x) => Proc::CastFloat(x.clone()),
        Proc::CastInt(x) => match &** x { Int::NumLit(i) => Proc::CastFloat(Box::new(Float::FloatLit(mettail_runtime::CanonicalFloat64::from(* i as f64)))), _ => Proc::Err, },
        Proc::CastBool(x) => match &** x { Bool::BoolLit(b) => Proc::CastFloat(Box::new(Float::FloatLit(mettail_runtime::CanonicalFloat64::from(if * b { 1.0 } else { 0.0 })))), _ => Proc::Err, },
        Proc::CastStr(x) => match &** x { Str::StringLit(s) => Proc::CastFloat(Box::new(Float::FloatLit(mettail_runtime::CanonicalFloat64::from(s.parse::< f64 > ().unwrap_or(0.0))))), _ => Proc::Err, },
        _ => Proc::Err,
    } }),
    if (match & res { Proc::Err => false, _ => true });

fold_proc(s.clone(), res) <--
    proc(s),
    if let Proc::ToBool(inner) = s,
    fold_proc(inner.as_ref().clone(), lv),
    let p = lv,
    let res = ({ match & p {
        Proc::CastBool(x) => Proc::CastBool(x.clone()),
        Proc::CastInt(x) => match &** x { Int::NumLit(i) => Proc::CastBool(Box::new(Bool::BoolLit(* i != 0))), _ => Proc::Err, },
        Proc::CastFloat(x) => match &** x { Float::FloatLit(f) => Proc::CastBool(Box::new(Bool::BoolLit(f.get() != 0.0))), _ => Proc::Err, },
        Proc::CastStr(x) => match &** x { Str::StringLit(s) => Proc::CastBool(Box::new(Bool::BoolLit(s.parse::< bool > ().unwrap_or(false)))), _ => Proc::Err, },
        _ => Proc::Err,
    } }),
    if (match & res { Proc::Err => false, _ => true });

fold_proc(s.clone(), res) <--
    proc(s),
    if let Proc::ToStr(inner) = s,
    fold_proc(inner.as_ref().clone(), lv),
    let p = lv,
    let res = ({ match & p {
        Proc::CastStr(x) => Proc::CastStr(x.clone()),
        Proc::CastInt(x) => match &** x { Int::NumLit(i) => Proc::CastStr(Box::new(Str::StringLit(i.to_string()))), _ => Proc::Err, },
        Proc::CastFloat(x) => match &** x { Float::FloatLit(f) => Proc::CastStr(Box::new(Str::StringLit(f.to_string()))), _ => Proc::Err, },
        Proc::CastBool(x) => match &** x { Bool::BoolLit(b) => Proc::CastStr(Box::new(Str::StringLit(b.to_string()))), _ => Proc::Err, },
        _ => Proc::Err,
    } }),
    if (match & res { Proc::Err => false, _ => true });

rw_proc(s.clone(), t.clone()) <--
    proc(s),
    if (match s {
        Proc::Add(_, _) => true,
        Proc::Sub(_, _) => true,
        Proc::Mul(_, _) => true,
        Proc::Div(_, _) => true,
        Proc::Eq(_, _) => true,
        Proc::Ne(_, _) => true,
        Proc::Gt(_, _) => true,
        Proc::Lt(_, _) => true,
        Proc::GtEq(_, _) => true,
        Proc::LtEq(_, _) => true,
        Proc::Not(_) => true,
        Proc::And(_, _) => true,
        Proc::Or(_, _) => true,
        Proc::ConcatStr(_, _) => true,
        Proc::Len(_) => true,
        Proc::ToInt(_) => true,
        Proc::ToFloat(_) => true,
        Proc::ToBool(_) => true,
        Proc::ToStr(_) => true,
        _ => false,
    }),
    fold_proc(s, t);

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* parent)), result) <--
    proc(parent),
    if let Proc::PPar(ref bag) = parent,
    for (elem, _count) in bag.iter(),
    rw_proc(elem.clone(), elem_rewritten),
    let result = Proc::PPar({ let mut new_bag = bag.clone(); new_bag.remove(elem); Proc::insert_into_ppar(& mut new_bag, elem_rewritten.clone()); new_bag });

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (Proc::Add(_, ref x1), 0usize) => Proc::Add(Box::new(t.clone()), x1.clone()),
    (Proc::Add(ref x0, _), 1usize) => Proc::Add(x0.clone(), Box::new(t.clone())),
    (Proc::Sub(_, ref x1), 2usize) => Proc::Sub(Box::new(t.clone()), x1.clone()),
    (Proc::Sub(ref x0, _), 3usize) => Proc::Sub(x0.clone(), Box::new(t.clone())),
    (Proc::Mul(_, ref x1), 4usize) => Proc::Mul(Box::new(t.clone()), x1.clone()),
    (Proc::Mul(ref x0, _), 5usize) => Proc::Mul(x0.clone(), Box::new(t.clone())),
    (Proc::Div(_, ref x1), 6usize) => Proc::Div(Box::new(t.clone()), x1.clone()),
    (Proc::Div(ref x0, _), 7usize) => Proc::Div(x0.clone(), Box::new(t.clone())),
    (Proc::Eq(_, ref x1), 8usize) => Proc::Eq(Box::new(t.clone()), x1.clone()),
    (Proc::Eq(ref x0, _), 9usize) => Proc::Eq(x0.clone(), Box::new(t.clone())),
    (Proc::Ne(_, ref x1), 10usize) => Proc::Ne(Box::new(t.clone()), x1.clone()),
    (Proc::Ne(ref x0, _), 11usize) => Proc::Ne(x0.clone(), Box::new(t.clone())),
    (Proc::Gt(_, ref x1), 12usize) => Proc::Gt(Box::new(t.clone()), x1.clone()),
    (Proc::Gt(ref x0, _), 13usize) => Proc::Gt(x0.clone(), Box::new(t.clone())),
    (Proc::Lt(_, ref x1), 14usize) => Proc::Lt(Box::new(t.clone()), x1.clone()),
    (Proc::Lt(ref x0, _), 15usize) => Proc::Lt(x0.clone(), Box::new(t.clone())),
    (Proc::GtEq(_, ref x1), 16usize) => Proc::GtEq(Box::new(t.clone()), x1.clone()),
    (Proc::GtEq(ref x0, _), 17usize) => Proc::GtEq(x0.clone(), Box::new(t.clone())),
    (Proc::LtEq(_, ref x1), 18usize) => Proc::LtEq(Box::new(t.clone()), x1.clone()),
    (Proc::LtEq(ref x0, _), 19usize) => Proc::LtEq(x0.clone(), Box::new(t.clone())),
    (Proc::Not(_), 20usize) => Proc::Not(Box::new(t.clone())),
    (Proc::And(_, ref x1), 21usize) => Proc::And(Box::new(t.clone()), x1.clone()),
    (Proc::And(ref x0, _), 22usize) => Proc::And(x0.clone(), Box::new(t.clone())),
    (Proc::Or(_, ref x1), 23usize) => Proc::Or(Box::new(t.clone()), x1.clone()),
    (Proc::Or(ref x0, _), 24usize) => Proc::Or(x0.clone(), Box::new(t.clone())),
    (Proc::ConcatStr(_, ref x1), 25usize) => Proc::ConcatStr(Box::new(t.clone()), x1.clone()),
    (Proc::ConcatStr(ref x0, _), 26usize) => Proc::ConcatStr(x0.clone(), Box::new(t.clone())),
    (Proc::Len(_), 27usize) => Proc::Len(Box::new(t.clone())),
    (Proc::ToInt(_), 28usize) => Proc::ToInt(Box::new(t.clone())),
    (Proc::ToFloat(_), 29usize) => Proc::ToFloat(Box::new(t.clone())),
    (Proc::ToBool(_), 30usize) => Proc::ToBool(Box::new(t.clone())),
    (Proc::ToStr(_), 31usize) => Proc::ToStr(Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    proc(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_PROC_SCONG_PROC : std::cell::Cell < Vec < (Proc, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_SCONG_PROC.with(| p | p.take()); buf.clear(); match lhs {
        Proc::Add(ref x0, ref x1) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 0usize));
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 1usize));
        },
        Proc::And(ref x0, ref x1) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 21usize));
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 22usize));
        },
        Proc::ConcatStr(ref x0, ref x1) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 25usize));
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 26usize));
        },
        Proc::Div(ref x0, ref x1) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 6usize));
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 7usize));
        },
        Proc::Eq(ref x0, ref x1) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 8usize));
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 9usize));
        },
        Proc::Gt(ref x0, ref x1) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 12usize));
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 13usize));
        },
        Proc::GtEq(ref x0, ref x1) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 16usize));
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 17usize));
        },
        Proc::Len(ref x0) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 27usize));
        },
        Proc::Lt(ref x0, ref x1) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 14usize));
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 15usize));
        },
        Proc::LtEq(ref x0, ref x1) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 18usize));
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 19usize));
        },
        Proc::Mul(ref x0, ref x1) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 4usize));
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 5usize));
        },
        Proc::Ne(ref x0, ref x1) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 10usize));
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 11usize));
        },
        Proc::Not(ref x0) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 20usize));
        },
        Proc::Or(ref x0, ref x1) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 23usize));
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 24usize));
        },
        Proc::Sub(ref x0, ref x1) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 2usize));
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 3usize));
        },
        Proc::ToBool(ref x0) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 30usize));
        },
        Proc::ToFloat(ref x0) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 29usize));
        },
        Proc::ToInt(ref x0) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 28usize));
        },
        Proc::ToStr(ref x0) => {
            buf.push((< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 31usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_SCONG_PROC.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_proc(field_val, t);


    // Custom logic
proc(p) <-- if let Ok(p) = Proc::parse("^x.{{ x | serv!(req) }}");

proc(p) <-- if let Ok(p) = Proc::parse("^x.{x}");

proc(res) <-- step_term(p), proc(c), if let Proc::LamProc(_) = c, let app = Proc::ApplyProc(Box::new(c.clone()), Box::new(p.clone())), let res = app.normalize();

proc(res) <-- step_term(p), proc(c), if let Proc::MLamProc(_) = c, let app = Proc::MApplyProc(Box::new(c.clone()), vec![p.clone()]), let res = app.normalize();

relation path(Proc, Proc);

path(p0, p1) <-- rw_proc(p0, p1);

path(p0, p2) <-- path(p0, p1), path(p1, p2);

relation trans(Proc, Proc, Proc);

trans(p,c,q) <-- step_term(p), proc(c), if let Proc::LamProc(_) = c, let app = Proc::ApplyProc(Box::new(c.clone()), Box::new(p.clone())), let res = app.normalize(), path(res.clone(), q);

trans(p,c,q) <-- step_term(p), proc(c), if let Proc::MLamProc(_) = c, let app = Proc::MApplyProc(Box::new(c.clone()), vec![p.clone()]), let res = app.normalize(), path(res.clone(), q);

}

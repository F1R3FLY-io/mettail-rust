// Generated Ascent Datalog for calculator theory
// This file is generated by the theory! macro and is for inspection only.
// Do not edit manually - changes will be overwritten.

ascent_source! {
    calculator_source:

    // Relations
relation proc(Proc);

#[ds(crate::eqrel)] relation eq_proc(Proc, Proc);

relation rw_proc(Proc, Proc);

relation int(Int);

#[ds(crate::eqrel)] relation eq_int(Int, Int);

relation rw_int(Int, Int);

relation fold_int(Int, Int);

relation float(Float);

#[ds(crate::eqrel)] relation eq_float(Float, Float);

relation rw_float(Float, Float);

relation fold_float(Float, Float);

relation bool(Bool);

#[ds(crate::eqrel)] relation eq_bool(Bool, Bool);

relation rw_bool(Bool, Bool);

relation str(Str);

#[ds(crate::eqrel)] relation eq_str(Str, Str);

relation rw_str(Str, Str);

relation list(List);

#[ds(crate::eqrel)] relation eq_list(List, List);

relation rw_list(List, List);

relation step_term(Proc);


    // Category rules
proc(sub.clone()) <--
    proc(t),
    for sub in { std::thread_local! { static POOL_PROC_PROC : std::cell::Cell < Vec < Proc >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_PROC.with(| p | p.take()); buf.clear(); match t {
        Proc::ApplyProc(ref lam, ref arg) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Proc::MApplyProc(ref lam, ref args) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.extend(args.iter().cloned());
        },
        Proc::LamProc(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::MLamProc(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::ApplyInt(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyInt(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::LamInt(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::MLamInt(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::ApplyFloat(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyFloat(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::LamFloat(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::MLamFloat(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::ApplyBool(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyBool(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::LamBool(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::MLamBool(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::ApplyStr(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyStr(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::LamStr(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::MLamStr(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::ApplyList(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyList(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::LamList(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Proc::MLamList(ref scope) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_PROC.with(| p | p.set(buf)); iter_buf }.into_iter();

int(sub.clone()) <--
    proc(t),
    for sub in { std::thread_local! { static POOL_PROC_INT : std::cell::Cell < Vec < Int >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_INT.with(| p | p.take()); buf.clear(); match t {
        Proc::ElemList(_, ref f1) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Proc::ApplyInt(_, ref arg) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Proc::MApplyInt(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_INT.with(| p | p.set(buf)); iter_buf }.into_iter();

float(sub.clone()) <--
    proc(t),
    for sub in { std::thread_local! { static POOL_PROC_FLOAT : std::cell::Cell < Vec < Float >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_FLOAT.with(| p | p.take()); buf.clear(); match t {
        Proc::ApplyFloat(_, ref arg) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Proc::MApplyFloat(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter();

bool(sub.clone()) <--
    proc(t),
    for sub in { std::thread_local! { static POOL_PROC_BOOL : std::cell::Cell < Vec < Bool >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_BOOL.with(| p | p.take()); buf.clear(); match t {
        Proc::ApplyBool(_, ref arg) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Proc::MApplyBool(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter();

str(sub.clone()) <--
    proc(t),
    for sub in { std::thread_local! { static POOL_PROC_STR : std::cell::Cell < Vec < Str >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_STR.with(| p | p.take()); buf.clear(); match t {
        Proc::ApplyStr(_, ref arg) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Proc::MApplyStr(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_STR.with(| p | p.set(buf)); iter_buf }.into_iter();

list(sub.clone()) <--
    proc(t),
    for sub in { std::thread_local! { static POOL_PROC_LIST : std::cell::Cell < Vec < List >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_LIST.with(| p | p.take()); buf.clear(); match t {
        Proc::ElemList(ref f0, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Proc::ApplyList(_, ref arg) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Proc::MApplyList(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_LIST.with(| p | p.set(buf)); iter_buf }.into_iter();

int(sub.clone()) <--
    int(t),
    for sub in { std::thread_local! { static POOL_INT_INT : std::cell::Cell < Vec < Int >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_INT.with(| p | p.take()); buf.clear(); match t {
        Int::IntId(ref f0) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Int::Tern(ref f0, ref f1, ref f2) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f2)));
        },
        Int::AddInt(ref f0, ref f1) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Int::SubInt(ref f0, ref f1) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Int::MulInt(ref f0, ref f1) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Int::DivInt(ref f0, ref f1) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Int::ModInt(ref f0, ref f1) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Int::PowInt(ref f0, ref f1) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Int::Neg(ref f0) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Int::Fact(ref f0) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Int::CustomOp(ref f0, ref f1) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Int::ApplyProc(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::MApplyProc(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::LamProc(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::MLamProc(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::ApplyInt(ref lam, ref arg) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Int::MApplyInt(ref lam, ref args) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.extend(args.iter().cloned());
        },
        Int::LamInt(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::MLamInt(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::ApplyFloat(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::MApplyFloat(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::LamFloat(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::MLamFloat(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::ApplyBool(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::MApplyBool(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::LamBool(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::MLamBool(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::ApplyStr(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::MApplyStr(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::LamStr(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::MLamStr(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::ApplyList(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::MApplyList(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::LamList(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Int::MLamList(ref scope) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_INT.with(| p | p.set(buf)); iter_buf }.into_iter();

float(sub.clone()) <--
    int(t),
    for sub in { std::thread_local! { static POOL_INT_FLOAT : std::cell::Cell < Vec < Float >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_FLOAT.with(| p | p.take()); buf.clear(); match t {
        Int::FloatToInt(ref f0) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Int::ApplyFloat(_, ref arg) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Int::MApplyFloat(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter();

bool(sub.clone()) <--
    int(t),
    for sub in { std::thread_local! { static POOL_INT_BOOL : std::cell::Cell < Vec < Bool >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_BOOL.with(| p | p.take()); buf.clear(); match t {
        Int::BoolToInt(ref f0) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Int::ApplyBool(_, ref arg) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Int::MApplyBool(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter();

str(sub.clone()) <--
    int(t),
    for sub in { std::thread_local! { static POOL_INT_STR : std::cell::Cell < Vec < Str >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_STR.with(| p | p.take()); buf.clear(); match t {
        Int::Len(ref f0) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Int::StrToInt(ref f0) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Int::ApplyStr(_, ref arg) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Int::MApplyStr(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_STR.with(| p | p.set(buf)); iter_buf }.into_iter();

list(sub.clone()) <--
    int(t),
    for sub in { std::thread_local! { static POOL_INT_LIST : std::cell::Cell < Vec < List >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_LIST.with(| p | p.take()); buf.clear(); match t {
        Int::LenList(ref f0) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Int::ApplyList(_, ref arg) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Int::MApplyList(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_LIST.with(| p | p.set(buf)); iter_buf }.into_iter();

int(sub.clone()) <--
    float(t),
    for sub in { std::thread_local! { static POOL_FLOAT_INT : std::cell::Cell < Vec < Int >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_INT.with(| p | p.take()); buf.clear(); match t {
        Float::IntToFloat(ref f0) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Float::ApplyInt(_, ref arg) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Float::MApplyInt(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_INT.with(| p | p.set(buf)); iter_buf }.into_iter();

float(sub.clone()) <--
    float(t),
    for sub in { std::thread_local! { static POOL_FLOAT_FLOAT : std::cell::Cell < Vec < Float >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_FLOAT.with(| p | p.take()); buf.clear(); match t {
        Float::FloatId(ref f0) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Float::AddFloat(ref f0, ref f1) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Float::SubFloat(ref f0, ref f1) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Float::MulFloat(ref f0, ref f1) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Float::DivFloat(ref f0, ref f1) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Float::PowFloat(ref f0, ref f1) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Float::SinFloat(ref f0) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Float::CosFloat(ref f0) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Float::ExpFloat(ref f0) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Float::LnFloat(ref f0) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Float::ApplyProc(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::MApplyProc(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::LamProc(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::MLamProc(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::ApplyInt(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::MApplyInt(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::LamInt(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::MLamInt(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::ApplyFloat(ref lam, ref arg) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Float::MApplyFloat(ref lam, ref args) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.extend(args.iter().cloned());
        },
        Float::LamFloat(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::MLamFloat(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::ApplyBool(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::MApplyBool(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::LamBool(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::MLamBool(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::ApplyStr(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::MApplyStr(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::LamStr(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::MLamStr(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::ApplyList(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::MApplyList(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::LamList(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Float::MLamList(ref scope) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter();

bool(sub.clone()) <--
    float(t),
    for sub in { std::thread_local! { static POOL_FLOAT_BOOL : std::cell::Cell < Vec < Bool >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_BOOL.with(| p | p.take()); buf.clear(); match t {
        Float::BoolToFloat(ref f0) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Float::ApplyBool(_, ref arg) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Float::MApplyBool(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter();

str(sub.clone()) <--
    float(t),
    for sub in { std::thread_local! { static POOL_FLOAT_STR : std::cell::Cell < Vec < Str >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_STR.with(| p | p.take()); buf.clear(); match t {
        Float::StrToFloat(ref f0) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Float::ApplyStr(_, ref arg) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Float::MApplyStr(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_STR.with(| p | p.set(buf)); iter_buf }.into_iter();

list(sub.clone()) <--
    float(t),
    for sub in { std::thread_local! { static POOL_FLOAT_LIST : std::cell::Cell < Vec < List >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_LIST.with(| p | p.take()); buf.clear(); match t {
        Float::ApplyList(_, ref arg) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Float::MApplyList(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_LIST.with(| p | p.set(buf)); iter_buf }.into_iter();

int(sub.clone()) <--
    bool(t),
    for sub in { std::thread_local! { static POOL_BOOL_INT : std::cell::Cell < Vec < Int >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_INT.with(| p | p.take()); buf.clear(); match t {
        Bool::EqInt(ref f0, ref f1) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::GtInt(ref f0, ref f1) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::LtInt(ref f0, ref f1) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::LtEqInt(ref f0, ref f1) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::GtEqInt(ref f0, ref f1) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::NeInt(ref f0, ref f1) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::IntToBool(ref f0) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Bool::ApplyInt(_, ref arg) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Bool::MApplyInt(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_INT.with(| p | p.set(buf)); iter_buf }.into_iter();

float(sub.clone()) <--
    bool(t),
    for sub in { std::thread_local! { static POOL_BOOL_FLOAT : std::cell::Cell < Vec < Float >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_FLOAT.with(| p | p.take()); buf.clear(); match t {
        Bool::EqFloat(ref f0, ref f1) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::GtFloat(ref f0, ref f1) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::LtFloat(ref f0, ref f1) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::LtEqFloat(ref f0, ref f1) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::GtEqFloat(ref f0, ref f1) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::NeFloat(ref f0, ref f1) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::FloatToBool(ref f0) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Bool::ApplyFloat(_, ref arg) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Bool::MApplyFloat(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter();

bool(sub.clone()) <--
    bool(t),
    for sub in { std::thread_local! { static POOL_BOOL_BOOL : std::cell::Cell < Vec < Bool >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_BOOL.with(| p | p.take()); buf.clear(); match t {
        Bool::BoolId(ref f0) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Bool::EqBool(ref f0, ref f1) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::GtBool(ref f0, ref f1) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::LtBool(ref f0, ref f1) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::LtEqBool(ref f0, ref f1) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::GtEqBool(ref f0, ref f1) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::NeBool(ref f0, ref f1) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::Not(ref f0) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Bool::And(ref f0, ref f1) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::Or(ref f0, ref f1) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::Xor(ref f0, ref f1) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::ApplyProc(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::MApplyProc(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::LamProc(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::MLamProc(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::ApplyInt(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::MApplyInt(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::LamInt(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::MLamInt(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::ApplyFloat(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::MApplyFloat(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::LamFloat(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::MLamFloat(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::ApplyBool(ref lam, ref arg) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Bool::MApplyBool(ref lam, ref args) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.extend(args.iter().cloned());
        },
        Bool::LamBool(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::MLamBool(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::ApplyStr(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::MApplyStr(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::LamStr(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::MLamStr(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::ApplyList(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::MApplyList(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::LamList(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Bool::MLamList(ref scope) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter();

str(sub.clone()) <--
    bool(t),
    for sub in { std::thread_local! { static POOL_BOOL_STR : std::cell::Cell < Vec < Str >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_STR.with(| p | p.take()); buf.clear(); match t {
        Bool::EqStr(ref f0, ref f1) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::GtStr(ref f0, ref f1) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::LtStr(ref f0, ref f1) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::LtEqStr(ref f0, ref f1) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::GtEqStr(ref f0, ref f1) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::NeStr(ref f0, ref f1) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Bool::StrToBool(ref f0) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Bool::ApplyStr(_, ref arg) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Bool::MApplyStr(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_STR.with(| p | p.set(buf)); iter_buf }.into_iter();

list(sub.clone()) <--
    bool(t),
    for sub in { std::thread_local! { static POOL_BOOL_LIST : std::cell::Cell < Vec < List >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_LIST.with(| p | p.take()); buf.clear(); match t {
        Bool::ApplyList(_, ref arg) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Bool::MApplyList(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_LIST.with(| p | p.set(buf)); iter_buf }.into_iter();

int(sub.clone()) <--
    str(t),
    for sub in { std::thread_local! { static POOL_STR_INT : std::cell::Cell < Vec < Int >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_INT.with(| p | p.take()); buf.clear(); match t {
        Str::IntToStr(ref f0) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Str::ApplyInt(_, ref arg) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Str::MApplyInt(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_INT.with(| p | p.set(buf)); iter_buf }.into_iter();

float(sub.clone()) <--
    str(t),
    for sub in { std::thread_local! { static POOL_STR_FLOAT : std::cell::Cell < Vec < Float >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_FLOAT.with(| p | p.take()); buf.clear(); match t {
        Str::FloatToStr(ref f0) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Str::ApplyFloat(_, ref arg) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Str::MApplyFloat(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter();

bool(sub.clone()) <--
    str(t),
    for sub in { std::thread_local! { static POOL_STR_BOOL : std::cell::Cell < Vec < Bool >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_BOOL.with(| p | p.take()); buf.clear(); match t {
        Str::BoolToStr(ref f0) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Str::ApplyBool(_, ref arg) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Str::MApplyBool(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter();

str(sub.clone()) <--
    str(t),
    for sub in { std::thread_local! { static POOL_STR_STR : std::cell::Cell < Vec < Str >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_STR.with(| p | p.take()); buf.clear(); match t {
        Str::StrId(ref f0) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        Str::Concat(ref f0, ref f1) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Str::AddStr(ref f0, ref f1) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        Str::ApplyProc(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::MApplyProc(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::LamProc(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::MLamProc(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::ApplyInt(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::MApplyInt(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::LamInt(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::MLamInt(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::ApplyFloat(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::MApplyFloat(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::LamFloat(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::MLamFloat(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::ApplyBool(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::MApplyBool(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::LamBool(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::MLamBool(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::ApplyStr(ref lam, ref arg) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Str::MApplyStr(ref lam, ref args) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.extend(args.iter().cloned());
        },
        Str::LamStr(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::MLamStr(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::ApplyList(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::MApplyList(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::LamList(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        Str::MLamList(ref scope) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_STR.with(| p | p.set(buf)); iter_buf }.into_iter();

list(sub.clone()) <--
    str(t),
    for sub in { std::thread_local! { static POOL_STR_LIST : std::cell::Cell < Vec < List >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_LIST.with(| p | p.take()); buf.clear(); match t {
        Str::ApplyList(_, ref arg) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        Str::MApplyList(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_LIST.with(| p | p.set(buf)); iter_buf }.into_iter();

int(sub.clone()) <--
    list(t),
    for sub in { std::thread_local! { static POOL_LIST_INT : std::cell::Cell < Vec < Int >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_LIST_INT.with(| p | p.take()); buf.clear(); match t {
        List::DeleteList(_, ref f1) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        List::ApplyInt(_, ref arg) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        List::MApplyInt(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_LIST_INT.with(| p | p.set(buf)); iter_buf }.into_iter();

float(sub.clone()) <--
    list(t),
    for sub in { std::thread_local! { static POOL_LIST_FLOAT : std::cell::Cell < Vec < Float >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_LIST_FLOAT.with(| p | p.take()); buf.clear(); match t {
        List::ApplyFloat(_, ref arg) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        List::MApplyFloat(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_LIST_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter();

bool(sub.clone()) <--
    list(t),
    for sub in { std::thread_local! { static POOL_LIST_BOOL : std::cell::Cell < Vec < Bool >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_LIST_BOOL.with(| p | p.take()); buf.clear(); match t {
        List::ApplyBool(_, ref arg) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        List::MApplyBool(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_LIST_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter();

str(sub.clone()) <--
    list(t),
    for sub in { std::thread_local! { static POOL_LIST_STR : std::cell::Cell < Vec < Str >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_LIST_STR.with(| p | p.take()); buf.clear(); match t {
        List::ApplyStr(_, ref arg) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        List::MApplyStr(_, ref args) => {
            buf.extend(args.iter().cloned());
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_LIST_STR.with(| p | p.set(buf)); iter_buf }.into_iter();

list(sub.clone()) <--
    list(t),
    for sub in { std::thread_local! { static POOL_LIST_LIST : std::cell::Cell < Vec < List >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_LIST_LIST.with(| p | p.take()); buf.clear(); match t {
        List::ListLit(ref f0) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        List::AppendList(ref f0, ref f1) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f1)));
        },
        List::DeleteList(ref f0, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* f0)));
        },
        List::ApplyProc(ref lam, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        List::MApplyProc(ref lam, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        List::LamProc(ref scope) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        List::MLamProc(ref scope) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        List::ApplyInt(ref lam, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        List::MApplyInt(ref lam, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        List::LamInt(ref scope) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        List::MLamInt(ref scope) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        List::ApplyFloat(ref lam, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        List::MApplyFloat(ref lam, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        List::LamFloat(ref scope) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        List::MLamFloat(ref scope) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        List::ApplyBool(ref lam, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        List::MApplyBool(ref lam, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        List::LamBool(ref scope) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        List::MLamBool(ref scope) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        List::ApplyStr(ref lam, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        List::MApplyStr(ref lam, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        List::LamStr(ref scope) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        List::MLamStr(ref scope) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        List::ApplyList(ref lam, ref arg) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        List::MApplyList(ref lam, ref args) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
            buf.extend(args.iter().cloned());
        },
        List::LamList(ref scope) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        List::MLamList(ref scope) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* scope.inner().unsafe_body)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_LIST_LIST.with(| p | p.set(buf)); iter_buf }.into_iter();

proc(c1.clone()) <--
    proc(c0),
    rw_proc(c0, c1);

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Proc::ApplyProc(_, arg) => Proc::ApplyProc(Box::new(new_lam.clone()), arg.clone()),
    Proc::MApplyProc(_, args) => Proc::MApplyProc(Box::new(new_lam.clone()), args.clone()),
    Proc::ApplyInt(_, arg) => Proc::ApplyInt(Box::new(new_lam.clone()), arg.clone()),
    Proc::MApplyInt(_, args) => Proc::MApplyInt(Box::new(new_lam.clone()), args.clone()),
    Proc::ApplyFloat(_, arg) => Proc::ApplyFloat(Box::new(new_lam.clone()), arg.clone()),
    Proc::MApplyFloat(_, args) => Proc::MApplyFloat(Box::new(new_lam.clone()), args.clone()),
    Proc::ApplyBool(_, arg) => Proc::ApplyBool(Box::new(new_lam.clone()), arg.clone()),
    Proc::MApplyBool(_, args) => Proc::MApplyBool(Box::new(new_lam.clone()), args.clone()),
    Proc::ApplyStr(_, arg) => Proc::ApplyStr(Box::new(new_lam.clone()), arg.clone()),
    Proc::MApplyStr(_, args) => Proc::MApplyStr(Box::new(new_lam.clone()), args.clone()),
    Proc::ApplyList(_, arg) => Proc::ApplyList(Box::new(new_lam.clone()), arg.clone()),
    Proc::MApplyList(_, args) => Proc::MApplyList(Box::new(new_lam.clone()), args.clone()),
    _ => unreachable!(),
},) <--
    proc(t),
    for lam in { std::thread_local! { static POOL_PROC_CONG_LAM : std::cell::Cell < Vec < Proc >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_CONG_LAM.with(| p | p.take()); buf.clear(); match t {
        Proc::ApplyProc(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyProc(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::ApplyInt(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyInt(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::ApplyFloat(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyFloat(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::ApplyBool(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyBool(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::ApplyStr(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyStr(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::ApplyList(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Proc::MApplyList(ref lam, _) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_CONG_LAM.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_proc(lam, new_lam);

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Proc::ApplyProc(lam, _) => Proc::ApplyProc(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    proc(t),
    for arg in { std::thread_local! { static POOL_PROC_CONG_ARG_PROC : std::cell::Cell < Vec < Proc >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_CONG_ARG_PROC.with(| p | p.take()); buf.clear(); match t {
        Proc::ApplyProc(_, ref arg) => {
            buf.push(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_CONG_ARG_PROC.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_proc(arg, new_arg);

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Proc::ApplyInt(lam, _) => Proc::ApplyInt(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    proc(t),
    for arg in { std::thread_local! { static POOL_PROC_CONG_ARG_INT : std::cell::Cell < Vec < Int >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_CONG_ARG_INT.with(| p | p.take()); buf.clear(); match t {
        Proc::ApplyInt(_, ref arg) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_CONG_ARG_INT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_int(arg, new_arg);

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Proc::ApplyFloat(lam, _) => Proc::ApplyFloat(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    proc(t),
    for arg in { std::thread_local! { static POOL_PROC_CONG_ARG_FLOAT : std::cell::Cell < Vec < Float >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_CONG_ARG_FLOAT.with(| p | p.take()); buf.clear(); match t {
        Proc::ApplyFloat(_, ref arg) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_CONG_ARG_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_float(arg, new_arg);

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Proc::ApplyBool(lam, _) => Proc::ApplyBool(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    proc(t),
    for arg in { std::thread_local! { static POOL_PROC_CONG_ARG_BOOL : std::cell::Cell < Vec < Bool >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_CONG_ARG_BOOL.with(| p | p.take()); buf.clear(); match t {
        Proc::ApplyBool(_, ref arg) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_CONG_ARG_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_bool(arg, new_arg);

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Proc::ApplyStr(lam, _) => Proc::ApplyStr(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    proc(t),
    for arg in { std::thread_local! { static POOL_PROC_CONG_ARG_STR : std::cell::Cell < Vec < Str >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_CONG_ARG_STR.with(| p | p.take()); buf.clear(); match t {
        Proc::ApplyStr(_, ref arg) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_CONG_ARG_STR.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_str(arg, new_arg);

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Proc::ApplyList(lam, _) => Proc::ApplyList(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    proc(t),
    for arg in { std::thread_local! { static POOL_PROC_CONG_ARG_LIST : std::cell::Cell < Vec < List >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_CONG_ARG_LIST.with(| p | p.take()); buf.clear(); match t {
        Proc::ApplyList(_, ref arg) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_CONG_ARG_LIST.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_list(arg, new_arg);

int(c1.clone()) <--
    int(c0),
    rw_int(c0, c1);

rw_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Int::ApplyInt(_, arg) => Int::ApplyInt(Box::new(new_lam.clone()), arg.clone()),
    Int::MApplyInt(_, args) => Int::MApplyInt(Box::new(new_lam.clone()), args.clone()),
    Int::ApplyFloat(_, arg) => Int::ApplyFloat(Box::new(new_lam.clone()), arg.clone()),
    Int::MApplyFloat(_, args) => Int::MApplyFloat(Box::new(new_lam.clone()), args.clone()),
    Int::ApplyBool(_, arg) => Int::ApplyBool(Box::new(new_lam.clone()), arg.clone()),
    Int::MApplyBool(_, args) => Int::MApplyBool(Box::new(new_lam.clone()), args.clone()),
    Int::ApplyStr(_, arg) => Int::ApplyStr(Box::new(new_lam.clone()), arg.clone()),
    Int::MApplyStr(_, args) => Int::MApplyStr(Box::new(new_lam.clone()), args.clone()),
    Int::ApplyList(_, arg) => Int::ApplyList(Box::new(new_lam.clone()), arg.clone()),
    Int::MApplyList(_, args) => Int::MApplyList(Box::new(new_lam.clone()), args.clone()),
    _ => unreachable!(),
},) <--
    int(t),
    for lam in { std::thread_local! { static POOL_INT_CONG_LAM : std::cell::Cell < Vec < Int >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_CONG_LAM.with(| p | p.take()); buf.clear(); match t {
        Int::ApplyInt(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::MApplyInt(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::ApplyFloat(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::MApplyFloat(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::ApplyBool(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::MApplyBool(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::ApplyStr(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::MApplyStr(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::ApplyList(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Int::MApplyList(ref lam, _) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_CONG_LAM.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_int(lam, new_lam);

rw_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Int::ApplyInt(lam, _) => Int::ApplyInt(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    int(t),
    for arg in { std::thread_local! { static POOL_INT_CONG_ARG_INT : std::cell::Cell < Vec < Int >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_CONG_ARG_INT.with(| p | p.take()); buf.clear(); match t {
        Int::ApplyInt(_, ref arg) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_CONG_ARG_INT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_int(arg, new_arg);

rw_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Int::ApplyFloat(lam, _) => Int::ApplyFloat(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    int(t),
    for arg in { std::thread_local! { static POOL_INT_CONG_ARG_FLOAT : std::cell::Cell < Vec < Float >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_CONG_ARG_FLOAT.with(| p | p.take()); buf.clear(); match t {
        Int::ApplyFloat(_, ref arg) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_CONG_ARG_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_float(arg, new_arg);

rw_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Int::ApplyBool(lam, _) => Int::ApplyBool(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    int(t),
    for arg in { std::thread_local! { static POOL_INT_CONG_ARG_BOOL : std::cell::Cell < Vec < Bool >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_CONG_ARG_BOOL.with(| p | p.take()); buf.clear(); match t {
        Int::ApplyBool(_, ref arg) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_CONG_ARG_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_bool(arg, new_arg);

rw_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Int::ApplyStr(lam, _) => Int::ApplyStr(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    int(t),
    for arg in { std::thread_local! { static POOL_INT_CONG_ARG_STR : std::cell::Cell < Vec < Str >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_CONG_ARG_STR.with(| p | p.take()); buf.clear(); match t {
        Int::ApplyStr(_, ref arg) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_CONG_ARG_STR.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_str(arg, new_arg);

rw_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Int::ApplyList(lam, _) => Int::ApplyList(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    int(t),
    for arg in { std::thread_local! { static POOL_INT_CONG_ARG_LIST : std::cell::Cell < Vec < List >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_CONG_ARG_LIST.with(| p | p.take()); buf.clear(); match t {
        Int::ApplyList(_, ref arg) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_CONG_ARG_LIST.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_list(arg, new_arg);

float(c1.clone()) <--
    float(c0),
    rw_float(c0, c1);

rw_float(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Float::ApplyInt(_, arg) => Float::ApplyInt(Box::new(new_lam.clone()), arg.clone()),
    Float::MApplyInt(_, args) => Float::MApplyInt(Box::new(new_lam.clone()), args.clone()),
    Float::ApplyFloat(_, arg) => Float::ApplyFloat(Box::new(new_lam.clone()), arg.clone()),
    Float::MApplyFloat(_, args) => Float::MApplyFloat(Box::new(new_lam.clone()), args.clone()),
    Float::ApplyBool(_, arg) => Float::ApplyBool(Box::new(new_lam.clone()), arg.clone()),
    Float::MApplyBool(_, args) => Float::MApplyBool(Box::new(new_lam.clone()), args.clone()),
    Float::ApplyStr(_, arg) => Float::ApplyStr(Box::new(new_lam.clone()), arg.clone()),
    Float::MApplyStr(_, args) => Float::MApplyStr(Box::new(new_lam.clone()), args.clone()),
    Float::ApplyList(_, arg) => Float::ApplyList(Box::new(new_lam.clone()), arg.clone()),
    Float::MApplyList(_, args) => Float::MApplyList(Box::new(new_lam.clone()), args.clone()),
    _ => unreachable!(),
},) <--
    float(t),
    for lam in { std::thread_local! { static POOL_FLOAT_CONG_LAM : std::cell::Cell < Vec < Float >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_CONG_LAM.with(| p | p.take()); buf.clear(); match t {
        Float::ApplyInt(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::MApplyInt(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::ApplyFloat(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::MApplyFloat(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::ApplyBool(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::MApplyBool(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::ApplyStr(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::MApplyStr(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::ApplyList(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Float::MApplyList(ref lam, _) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_CONG_LAM.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_float(lam, new_lam);

rw_float(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Float::ApplyInt(lam, _) => Float::ApplyInt(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    float(t),
    for arg in { std::thread_local! { static POOL_FLOAT_CONG_ARG_INT : std::cell::Cell < Vec < Int >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_CONG_ARG_INT.with(| p | p.take()); buf.clear(); match t {
        Float::ApplyInt(_, ref arg) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_CONG_ARG_INT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_int(arg, new_arg);

rw_float(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Float::ApplyFloat(lam, _) => Float::ApplyFloat(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    float(t),
    for arg in { std::thread_local! { static POOL_FLOAT_CONG_ARG_FLOAT : std::cell::Cell < Vec < Float >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_CONG_ARG_FLOAT.with(| p | p.take()); buf.clear(); match t {
        Float::ApplyFloat(_, ref arg) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_CONG_ARG_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_float(arg, new_arg);

rw_float(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Float::ApplyBool(lam, _) => Float::ApplyBool(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    float(t),
    for arg in { std::thread_local! { static POOL_FLOAT_CONG_ARG_BOOL : std::cell::Cell < Vec < Bool >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_CONG_ARG_BOOL.with(| p | p.take()); buf.clear(); match t {
        Float::ApplyBool(_, ref arg) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_CONG_ARG_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_bool(arg, new_arg);

rw_float(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Float::ApplyStr(lam, _) => Float::ApplyStr(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    float(t),
    for arg in { std::thread_local! { static POOL_FLOAT_CONG_ARG_STR : std::cell::Cell < Vec < Str >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_CONG_ARG_STR.with(| p | p.take()); buf.clear(); match t {
        Float::ApplyStr(_, ref arg) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_CONG_ARG_STR.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_str(arg, new_arg);

rw_float(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Float::ApplyList(lam, _) => Float::ApplyList(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    float(t),
    for arg in { std::thread_local! { static POOL_FLOAT_CONG_ARG_LIST : std::cell::Cell < Vec < List >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_CONG_ARG_LIST.with(| p | p.take()); buf.clear(); match t {
        Float::ApplyList(_, ref arg) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_CONG_ARG_LIST.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_list(arg, new_arg);

bool(c1.clone()) <--
    bool(c0),
    rw_bool(c0, c1);

rw_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Bool::ApplyInt(_, arg) => Bool::ApplyInt(Box::new(new_lam.clone()), arg.clone()),
    Bool::MApplyInt(_, args) => Bool::MApplyInt(Box::new(new_lam.clone()), args.clone()),
    Bool::ApplyFloat(_, arg) => Bool::ApplyFloat(Box::new(new_lam.clone()), arg.clone()),
    Bool::MApplyFloat(_, args) => Bool::MApplyFloat(Box::new(new_lam.clone()), args.clone()),
    Bool::ApplyBool(_, arg) => Bool::ApplyBool(Box::new(new_lam.clone()), arg.clone()),
    Bool::MApplyBool(_, args) => Bool::MApplyBool(Box::new(new_lam.clone()), args.clone()),
    Bool::ApplyStr(_, arg) => Bool::ApplyStr(Box::new(new_lam.clone()), arg.clone()),
    Bool::MApplyStr(_, args) => Bool::MApplyStr(Box::new(new_lam.clone()), args.clone()),
    Bool::ApplyList(_, arg) => Bool::ApplyList(Box::new(new_lam.clone()), arg.clone()),
    Bool::MApplyList(_, args) => Bool::MApplyList(Box::new(new_lam.clone()), args.clone()),
    _ => unreachable!(),
},) <--
    bool(t),
    for lam in { std::thread_local! { static POOL_BOOL_CONG_LAM : std::cell::Cell < Vec < Bool >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_CONG_LAM.with(| p | p.take()); buf.clear(); match t {
        Bool::ApplyInt(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::MApplyInt(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::ApplyFloat(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::MApplyFloat(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::ApplyBool(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::MApplyBool(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::ApplyStr(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::MApplyStr(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::ApplyList(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Bool::MApplyList(ref lam, _) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_CONG_LAM.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_bool(lam, new_lam);

rw_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Bool::ApplyInt(lam, _) => Bool::ApplyInt(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    bool(t),
    for arg in { std::thread_local! { static POOL_BOOL_CONG_ARG_INT : std::cell::Cell < Vec < Int >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_CONG_ARG_INT.with(| p | p.take()); buf.clear(); match t {
        Bool::ApplyInt(_, ref arg) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_CONG_ARG_INT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_int(arg, new_arg);

rw_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Bool::ApplyFloat(lam, _) => Bool::ApplyFloat(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    bool(t),
    for arg in { std::thread_local! { static POOL_BOOL_CONG_ARG_FLOAT : std::cell::Cell < Vec < Float >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_CONG_ARG_FLOAT.with(| p | p.take()); buf.clear(); match t {
        Bool::ApplyFloat(_, ref arg) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_CONG_ARG_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_float(arg, new_arg);

rw_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Bool::ApplyBool(lam, _) => Bool::ApplyBool(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    bool(t),
    for arg in { std::thread_local! { static POOL_BOOL_CONG_ARG_BOOL : std::cell::Cell < Vec < Bool >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_CONG_ARG_BOOL.with(| p | p.take()); buf.clear(); match t {
        Bool::ApplyBool(_, ref arg) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_CONG_ARG_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_bool(arg, new_arg);

rw_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Bool::ApplyStr(lam, _) => Bool::ApplyStr(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    bool(t),
    for arg in { std::thread_local! { static POOL_BOOL_CONG_ARG_STR : std::cell::Cell < Vec < Str >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_CONG_ARG_STR.with(| p | p.take()); buf.clear(); match t {
        Bool::ApplyStr(_, ref arg) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_CONG_ARG_STR.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_str(arg, new_arg);

rw_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Bool::ApplyList(lam, _) => Bool::ApplyList(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    bool(t),
    for arg in { std::thread_local! { static POOL_BOOL_CONG_ARG_LIST : std::cell::Cell < Vec < List >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_CONG_ARG_LIST.with(| p | p.take()); buf.clear(); match t {
        Bool::ApplyList(_, ref arg) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_CONG_ARG_LIST.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_list(arg, new_arg);

str(c1.clone()) <--
    str(c0),
    rw_str(c0, c1);

rw_str(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Str::ApplyInt(_, arg) => Str::ApplyInt(Box::new(new_lam.clone()), arg.clone()),
    Str::MApplyInt(_, args) => Str::MApplyInt(Box::new(new_lam.clone()), args.clone()),
    Str::ApplyFloat(_, arg) => Str::ApplyFloat(Box::new(new_lam.clone()), arg.clone()),
    Str::MApplyFloat(_, args) => Str::MApplyFloat(Box::new(new_lam.clone()), args.clone()),
    Str::ApplyBool(_, arg) => Str::ApplyBool(Box::new(new_lam.clone()), arg.clone()),
    Str::MApplyBool(_, args) => Str::MApplyBool(Box::new(new_lam.clone()), args.clone()),
    Str::ApplyStr(_, arg) => Str::ApplyStr(Box::new(new_lam.clone()), arg.clone()),
    Str::MApplyStr(_, args) => Str::MApplyStr(Box::new(new_lam.clone()), args.clone()),
    Str::ApplyList(_, arg) => Str::ApplyList(Box::new(new_lam.clone()), arg.clone()),
    Str::MApplyList(_, args) => Str::MApplyList(Box::new(new_lam.clone()), args.clone()),
    _ => unreachable!(),
},) <--
    str(t),
    for lam in { std::thread_local! { static POOL_STR_CONG_LAM : std::cell::Cell < Vec < Str >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_CONG_LAM.with(| p | p.take()); buf.clear(); match t {
        Str::ApplyInt(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::MApplyInt(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::ApplyFloat(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::MApplyFloat(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::ApplyBool(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::MApplyBool(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::ApplyStr(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::MApplyStr(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::ApplyList(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        Str::MApplyList(ref lam, _) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_CONG_LAM.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_str(lam, new_lam);

rw_str(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Str::ApplyInt(lam, _) => Str::ApplyInt(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    str(t),
    for arg in { std::thread_local! { static POOL_STR_CONG_ARG_INT : std::cell::Cell < Vec < Int >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_CONG_ARG_INT.with(| p | p.take()); buf.clear(); match t {
        Str::ApplyInt(_, ref arg) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_CONG_ARG_INT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_int(arg, new_arg);

rw_str(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Str::ApplyFloat(lam, _) => Str::ApplyFloat(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    str(t),
    for arg in { std::thread_local! { static POOL_STR_CONG_ARG_FLOAT : std::cell::Cell < Vec < Float >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_CONG_ARG_FLOAT.with(| p | p.take()); buf.clear(); match t {
        Str::ApplyFloat(_, ref arg) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_CONG_ARG_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_float(arg, new_arg);

rw_str(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Str::ApplyBool(lam, _) => Str::ApplyBool(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    str(t),
    for arg in { std::thread_local! { static POOL_STR_CONG_ARG_BOOL : std::cell::Cell < Vec < Bool >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_CONG_ARG_BOOL.with(| p | p.take()); buf.clear(); match t {
        Str::ApplyBool(_, ref arg) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_CONG_ARG_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_bool(arg, new_arg);

rw_str(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Str::ApplyStr(lam, _) => Str::ApplyStr(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    str(t),
    for arg in { std::thread_local! { static POOL_STR_CONG_ARG_STR : std::cell::Cell < Vec < Str >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_CONG_ARG_STR.with(| p | p.take()); buf.clear(); match t {
        Str::ApplyStr(_, ref arg) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_CONG_ARG_STR.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_str(arg, new_arg);

rw_str(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    Str::ApplyList(lam, _) => Str::ApplyList(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    str(t),
    for arg in { std::thread_local! { static POOL_STR_CONG_ARG_LIST : std::cell::Cell < Vec < List >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_CONG_ARG_LIST.with(| p | p.take()); buf.clear(); match t {
        Str::ApplyList(_, ref arg) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_CONG_ARG_LIST.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_list(arg, new_arg);

list(c1.clone()) <--
    list(c0),
    rw_list(c0, c1);

rw_list(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    List::ApplyInt(_, arg) => List::ApplyInt(Box::new(new_lam.clone()), arg.clone()),
    List::MApplyInt(_, args) => List::MApplyInt(Box::new(new_lam.clone()), args.clone()),
    List::ApplyFloat(_, arg) => List::ApplyFloat(Box::new(new_lam.clone()), arg.clone()),
    List::MApplyFloat(_, args) => List::MApplyFloat(Box::new(new_lam.clone()), args.clone()),
    List::ApplyBool(_, arg) => List::ApplyBool(Box::new(new_lam.clone()), arg.clone()),
    List::MApplyBool(_, args) => List::MApplyBool(Box::new(new_lam.clone()), args.clone()),
    List::ApplyStr(_, arg) => List::ApplyStr(Box::new(new_lam.clone()), arg.clone()),
    List::MApplyStr(_, args) => List::MApplyStr(Box::new(new_lam.clone()), args.clone()),
    List::ApplyList(_, arg) => List::ApplyList(Box::new(new_lam.clone()), arg.clone()),
    List::MApplyList(_, args) => List::MApplyList(Box::new(new_lam.clone()), args.clone()),
    _ => unreachable!(),
},) <--
    list(t),
    for lam in { std::thread_local! { static POOL_LIST_CONG_LAM : std::cell::Cell < Vec < List >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_LIST_CONG_LAM.with(| p | p.take()); buf.clear(); match t {
        List::ApplyInt(ref lam, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        List::MApplyInt(ref lam, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        List::ApplyFloat(ref lam, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        List::MApplyFloat(ref lam, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        List::ApplyBool(ref lam, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        List::MApplyBool(ref lam, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        List::ApplyStr(ref lam, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        List::MApplyStr(ref lam, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        List::ApplyList(ref lam, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        List::MApplyList(ref lam, _) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lam)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_LIST_CONG_LAM.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_list(lam, new_lam);

rw_list(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    List::ApplyInt(lam, _) => List::ApplyInt(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    list(t),
    for arg in { std::thread_local! { static POOL_LIST_CONG_ARG_INT : std::cell::Cell < Vec < Int >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_LIST_CONG_ARG_INT.with(| p | p.take()); buf.clear(); match t {
        List::ApplyInt(_, ref arg) => {
            buf.push(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_LIST_CONG_ARG_INT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_int(arg, new_arg);

rw_list(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    List::ApplyFloat(lam, _) => List::ApplyFloat(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    list(t),
    for arg in { std::thread_local! { static POOL_LIST_CONG_ARG_FLOAT : std::cell::Cell < Vec < Float >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_LIST_CONG_ARG_FLOAT.with(| p | p.take()); buf.clear(); match t {
        List::ApplyFloat(_, ref arg) => {
            buf.push(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_LIST_CONG_ARG_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_float(arg, new_arg);

rw_list(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    List::ApplyBool(lam, _) => List::ApplyBool(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    list(t),
    for arg in { std::thread_local! { static POOL_LIST_CONG_ARG_BOOL : std::cell::Cell < Vec < Bool >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_LIST_CONG_ARG_BOOL.with(| p | p.take()); buf.clear(); match t {
        List::ApplyBool(_, ref arg) => {
            buf.push(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_LIST_CONG_ARG_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_bool(arg, new_arg);

rw_list(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    List::ApplyStr(lam, _) => List::ApplyStr(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    list(t),
    for arg in { std::thread_local! { static POOL_LIST_CONG_ARG_STR : std::cell::Cell < Vec < Str >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_LIST_CONG_ARG_STR.with(| p | p.take()); buf.clear(); match t {
        List::ApplyStr(_, ref arg) => {
            buf.push(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_LIST_CONG_ARG_STR.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_str(arg, new_arg);

rw_list(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), match t {
    List::ApplyList(lam, _) => List::ApplyList(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
},) <--
    list(t),
    for arg in { std::thread_local! { static POOL_LIST_CONG_ARG_LIST : std::cell::Cell < Vec < List >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_LIST_CONG_ARG_LIST.with(| p | p.take()); buf.clear(); match t {
        List::ApplyList(_, ref arg) => {
            buf.push(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* arg)));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_LIST_CONG_ARG_LIST.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_list(arg, new_arg);


    // Equation rules
eq_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    proc(t);

eq_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    int(t);

eq_float(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    float(t);

eq_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    bool(t);

eq_str(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    str(t);

eq_list(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)), < List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    list(t);

eq_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    bool(s),
    bool(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_BOOL_EQ_CONG_0 : std::cell::Cell < Vec < (Bool, Bool) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_EQ_CONG_0.with(| p | p.take()); buf.clear(); match (s, t) {
        (Bool::BoolId(ref sf0), Bool::BoolId(ref tf0)) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        (Bool::Not(ref sf0), Bool::Not(ref tf0)) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_EQ_CONG_0.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_bool(s_f0, t_f0);

eq_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    bool(s),
    bool(t),
    for (s_f0, s_f1, t_f0, t_f1) in { std::thread_local! { static POOL_BOOL_EQ_CONG_1 : std::cell::Cell < Vec < (Bool, Bool, Bool, Bool) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_EQ_CONG_1.with(| p | p.take()); buf.clear(); match (s, t) {
        (Bool::EqBool(ref sf0, ref sf1), Bool::EqBool(ref tf0, ref tf1)) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::GtBool(ref sf0, ref sf1), Bool::GtBool(ref tf0, ref tf1)) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::LtBool(ref sf0, ref sf1), Bool::LtBool(ref tf0, ref tf1)) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::LtEqBool(ref sf0, ref sf1), Bool::LtEqBool(ref tf0, ref tf1)) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::GtEqBool(ref sf0, ref sf1), Bool::GtEqBool(ref tf0, ref tf1)) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::NeBool(ref sf0, ref sf1), Bool::NeBool(ref tf0, ref tf1)) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::And(ref sf0, ref sf1), Bool::And(ref tf0, ref tf1)) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::Or(ref sf0, ref sf1), Bool::Or(ref tf0, ref tf1)) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::Xor(ref sf0, ref sf1), Bool::Xor(ref tf0, ref tf1)) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_EQ_CONG_1.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_bool(s_f0, t_f0),
    eq_bool(s_f1, t_f1);

eq_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    bool(s),
    bool(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_BOOL_EQ_CONG_2 : std::cell::Cell < Vec < (Float, Float) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_EQ_CONG_2.with(| p | p.take()); buf.clear(); match (s, t) {
        (Bool::FloatToBool(ref sf0), Bool::FloatToBool(ref tf0)) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_EQ_CONG_2.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_float(s_f0, t_f0);

eq_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    bool(s),
    bool(t),
    for (s_f0, s_f1, t_f0, t_f1) in { std::thread_local! { static POOL_BOOL_EQ_CONG_3 : std::cell::Cell < Vec < (Float, Float, Float, Float) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_EQ_CONG_3.with(| p | p.take()); buf.clear(); match (s, t) {
        (Bool::EqFloat(ref sf0, ref sf1), Bool::EqFloat(ref tf0, ref tf1)) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::GtFloat(ref sf0, ref sf1), Bool::GtFloat(ref tf0, ref tf1)) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::LtFloat(ref sf0, ref sf1), Bool::LtFloat(ref tf0, ref tf1)) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::LtEqFloat(ref sf0, ref sf1), Bool::LtEqFloat(ref tf0, ref tf1)) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::GtEqFloat(ref sf0, ref sf1), Bool::GtEqFloat(ref tf0, ref tf1)) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::NeFloat(ref sf0, ref sf1), Bool::NeFloat(ref tf0, ref tf1)) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_EQ_CONG_3.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_float(s_f0, t_f0),
    eq_float(s_f1, t_f1);

eq_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    bool(s),
    bool(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_BOOL_EQ_CONG_4 : std::cell::Cell < Vec < (Int, Int) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_EQ_CONG_4.with(| p | p.take()); buf.clear(); match (s, t) {
        (Bool::IntToBool(ref sf0), Bool::IntToBool(ref tf0)) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_EQ_CONG_4.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_int(s_f0, t_f0);

eq_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    bool(s),
    bool(t),
    for (s_f0, s_f1, t_f0, t_f1) in { std::thread_local! { static POOL_BOOL_EQ_CONG_5 : std::cell::Cell < Vec < (Int, Int, Int, Int) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_EQ_CONG_5.with(| p | p.take()); buf.clear(); match (s, t) {
        (Bool::EqInt(ref sf0, ref sf1), Bool::EqInt(ref tf0, ref tf1)) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::GtInt(ref sf0, ref sf1), Bool::GtInt(ref tf0, ref tf1)) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::LtInt(ref sf0, ref sf1), Bool::LtInt(ref tf0, ref tf1)) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::LtEqInt(ref sf0, ref sf1), Bool::LtEqInt(ref tf0, ref tf1)) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::GtEqInt(ref sf0, ref sf1), Bool::GtEqInt(ref tf0, ref tf1)) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::NeInt(ref sf0, ref sf1), Bool::NeInt(ref tf0, ref tf1)) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_EQ_CONG_5.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_int(s_f0, t_f0),
    eq_int(s_f1, t_f1);

eq_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    bool(s),
    bool(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_BOOL_EQ_CONG_6 : std::cell::Cell < Vec < (Str, Str) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_EQ_CONG_6.with(| p | p.take()); buf.clear(); match (s, t) {
        (Bool::StrToBool(ref sf0), Bool::StrToBool(ref tf0)) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_EQ_CONG_6.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_str(s_f0, t_f0);

eq_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    bool(s),
    bool(t),
    for (s_f0, s_f1, t_f0, t_f1) in { std::thread_local! { static POOL_BOOL_EQ_CONG_7 : std::cell::Cell < Vec < (Str, Str, Str, Str) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_EQ_CONG_7.with(| p | p.take()); buf.clear(); match (s, t) {
        (Bool::EqStr(ref sf0, ref sf1), Bool::EqStr(ref tf0, ref tf1)) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::GtStr(ref sf0, ref sf1), Bool::GtStr(ref tf0, ref tf1)) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::LtStr(ref sf0, ref sf1), Bool::LtStr(ref tf0, ref tf1)) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::LtEqStr(ref sf0, ref sf1), Bool::LtEqStr(ref tf0, ref tf1)) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::GtEqStr(ref sf0, ref sf1), Bool::GtEqStr(ref tf0, ref tf1)) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Bool::NeStr(ref sf0, ref sf1), Bool::NeStr(ref tf0, ref tf1)) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_EQ_CONG_7.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_str(s_f0, t_f0),
    eq_str(s_f1, t_f1);

eq_float(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    float(s),
    float(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_FLOAT_EQ_CONG_8 : std::cell::Cell < Vec < (Bool, Bool) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_EQ_CONG_8.with(| p | p.take()); buf.clear(); match (s, t) {
        (Float::BoolToFloat(ref sf0), Float::BoolToFloat(ref tf0)) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_EQ_CONG_8.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_bool(s_f0, t_f0);

eq_float(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    float(s),
    float(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_FLOAT_EQ_CONG_9 : std::cell::Cell < Vec < (Float, Float) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_EQ_CONG_9.with(| p | p.take()); buf.clear(); match (s, t) {
        (Float::FloatId(ref sf0), Float::FloatId(ref tf0)) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        (Float::SinFloat(ref sf0), Float::SinFloat(ref tf0)) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        (Float::CosFloat(ref sf0), Float::CosFloat(ref tf0)) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        (Float::ExpFloat(ref sf0), Float::ExpFloat(ref tf0)) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        (Float::LnFloat(ref sf0), Float::LnFloat(ref tf0)) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_EQ_CONG_9.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_float(s_f0, t_f0);

eq_float(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    float(s),
    float(t),
    for (s_f0, s_f1, t_f0, t_f1) in { std::thread_local! { static POOL_FLOAT_EQ_CONG_10 : std::cell::Cell < Vec < (Float, Float, Float, Float) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_EQ_CONG_10.with(| p | p.take()); buf.clear(); match (s, t) {
        (Float::AddFloat(ref sf0, ref sf1), Float::AddFloat(ref tf0, ref tf1)) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Float::SubFloat(ref sf0, ref sf1), Float::SubFloat(ref tf0, ref tf1)) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Float::MulFloat(ref sf0, ref sf1), Float::MulFloat(ref tf0, ref tf1)) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Float::DivFloat(ref sf0, ref sf1), Float::DivFloat(ref tf0, ref tf1)) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Float::PowFloat(ref sf0, ref sf1), Float::PowFloat(ref tf0, ref tf1)) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_EQ_CONG_10.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_float(s_f0, t_f0),
    eq_float(s_f1, t_f1);

eq_float(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    float(s),
    float(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_FLOAT_EQ_CONG_11 : std::cell::Cell < Vec < (Int, Int) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_EQ_CONG_11.with(| p | p.take()); buf.clear(); match (s, t) {
        (Float::IntToFloat(ref sf0), Float::IntToFloat(ref tf0)) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_EQ_CONG_11.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_int(s_f0, t_f0);

eq_float(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    float(s),
    float(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_FLOAT_EQ_CONG_12 : std::cell::Cell < Vec < (Str, Str) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_EQ_CONG_12.with(| p | p.take()); buf.clear(); match (s, t) {
        (Float::StrToFloat(ref sf0), Float::StrToFloat(ref tf0)) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_EQ_CONG_12.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_str(s_f0, t_f0);

eq_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    int(s),
    int(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_INT_EQ_CONG_13 : std::cell::Cell < Vec < (Bool, Bool) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_EQ_CONG_13.with(| p | p.take()); buf.clear(); match (s, t) {
        (Int::BoolToInt(ref sf0), Int::BoolToInt(ref tf0)) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_EQ_CONG_13.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_bool(s_f0, t_f0);

eq_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    int(s),
    int(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_INT_EQ_CONG_14 : std::cell::Cell < Vec < (Float, Float) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_EQ_CONG_14.with(| p | p.take()); buf.clear(); match (s, t) {
        (Int::FloatToInt(ref sf0), Int::FloatToInt(ref tf0)) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_EQ_CONG_14.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_float(s_f0, t_f0);

eq_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    int(s),
    int(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_INT_EQ_CONG_15 : std::cell::Cell < Vec < (Int, Int) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_EQ_CONG_15.with(| p | p.take()); buf.clear(); match (s, t) {
        (Int::IntId(ref sf0), Int::IntId(ref tf0)) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        (Int::Neg(ref sf0), Int::Neg(ref tf0)) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        (Int::Fact(ref sf0), Int::Fact(ref tf0)) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_EQ_CONG_15.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_int(s_f0, t_f0);

eq_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    int(s),
    int(t),
    for (s_f0, s_f1, t_f0, t_f1) in { std::thread_local! { static POOL_INT_EQ_CONG_16 : std::cell::Cell < Vec < (Int, Int, Int, Int) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_EQ_CONG_16.with(| p | p.take()); buf.clear(); match (s, t) {
        (Int::AddInt(ref sf0, ref sf1), Int::AddInt(ref tf0, ref tf1)) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Int::SubInt(ref sf0, ref sf1), Int::SubInt(ref tf0, ref tf1)) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Int::MulInt(ref sf0, ref sf1), Int::MulInt(ref tf0, ref tf1)) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Int::DivInt(ref sf0, ref sf1), Int::DivInt(ref tf0, ref tf1)) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Int::ModInt(ref sf0, ref sf1), Int::ModInt(ref tf0, ref tf1)) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Int::PowInt(ref sf0, ref sf1), Int::PowInt(ref tf0, ref tf1)) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Int::CustomOp(ref sf0, ref sf1), Int::CustomOp(ref tf0, ref tf1)) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_EQ_CONG_16.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_int(s_f0, t_f0),
    eq_int(s_f1, t_f1);

eq_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    int(s),
    int(t),
    for (s_f0, s_f1, s_f2, t_f0, t_f1, t_f2) in { std::thread_local! { static POOL_INT_EQ_CONG_17 : std::cell::Cell < Vec < (Int, Int, Int, Int, Int, Int) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_EQ_CONG_17.with(| p | p.take()); buf.clear(); match (s, t) {
        (Int::Tern(ref sf0, ref sf1, ref sf2), Int::Tern(ref tf0, ref tf1, ref tf2)) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf2.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf2.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_EQ_CONG_17.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_int(s_f0, t_f0),
    eq_int(s_f1, t_f1),
    eq_int(s_f2, t_f2);

eq_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    int(s),
    int(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_INT_EQ_CONG_18 : std::cell::Cell < Vec < (List, List) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_EQ_CONG_18.with(| p | p.take()); buf.clear(); match (s, t) {
        (Int::LenList(ref sf0), Int::LenList(ref tf0)) => {
            buf.push((< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_EQ_CONG_18.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_list(s_f0, t_f0);

eq_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    int(s),
    int(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_INT_EQ_CONG_19 : std::cell::Cell < Vec < (Str, Str) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_EQ_CONG_19.with(| p | p.take()); buf.clear(); match (s, t) {
        (Int::Len(ref sf0), Int::Len(ref tf0)) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        (Int::StrToInt(ref sf0), Int::StrToInt(ref tf0)) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_EQ_CONG_19.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_str(s_f0, t_f0);

eq_list(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    list(s),
    list(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_LIST_EQ_CONG_20 : std::cell::Cell < Vec < (List, List) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_LIST_EQ_CONG_20.with(| p | p.take()); buf.clear(); match (s, t) {
        (List::ListLit(ref sf0), List::ListLit(ref tf0)) => {
            buf.push((< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_LIST_EQ_CONG_20.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_list(s_f0, t_f0);

eq_list(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    list(s),
    list(t),
    for (s_f0, s_f1, t_f0, t_f1) in { std::thread_local! { static POOL_LIST_EQ_CONG_21 : std::cell::Cell < Vec < (List, Int, List, Int) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_LIST_EQ_CONG_21.with(| p | p.take()); buf.clear(); match (s, t) {
        (List::DeleteList(ref sf0, ref sf1), List::DeleteList(ref tf0, ref tf1)) => {
            buf.push((< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_LIST_EQ_CONG_21.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_list(s_f0, t_f0),
    eq_int(s_f1, t_f1);

eq_list(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    list(s),
    list(t),
    for (s_f0, s_f1, t_f0, t_f1) in { std::thread_local! { static POOL_LIST_EQ_CONG_22 : std::cell::Cell < Vec < (List, List, List, List) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_LIST_EQ_CONG_22.with(| p | p.take()); buf.clear(); match (s, t) {
        (List::AppendList(ref sf0, ref sf1), List::AppendList(ref tf0, ref tf1)) => {
            buf.push((< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_LIST_EQ_CONG_22.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_list(s_f0, t_f0),
    eq_list(s_f1, t_f1);

eq_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    proc(s),
    proc(t),
    for (s_f0, s_f1, t_f0, t_f1) in { std::thread_local! { static POOL_PROC_EQ_CONG_23 : std::cell::Cell < Vec < (List, Int, List, Int) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_EQ_CONG_23.with(| p | p.take()); buf.clear(); match (s, t) {
        (Proc::ElemList(ref sf0, ref sf1), Proc::ElemList(ref tf0, ref tf1)) => {
            buf.push((< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_EQ_CONG_23.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_list(s_f0, t_f0),
    eq_int(s_f1, t_f1);

eq_str(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    str(s),
    str(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_STR_EQ_CONG_24 : std::cell::Cell < Vec < (Bool, Bool) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_EQ_CONG_24.with(| p | p.take()); buf.clear(); match (s, t) {
        (Str::BoolToStr(ref sf0), Str::BoolToStr(ref tf0)) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_EQ_CONG_24.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_bool(s_f0, t_f0);

eq_str(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    str(s),
    str(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_STR_EQ_CONG_25 : std::cell::Cell < Vec < (Float, Float) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_EQ_CONG_25.with(| p | p.take()); buf.clear(); match (s, t) {
        (Str::FloatToStr(ref sf0), Str::FloatToStr(ref tf0)) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_EQ_CONG_25.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_float(s_f0, t_f0);

eq_str(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    str(s),
    str(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_STR_EQ_CONG_26 : std::cell::Cell < Vec < (Int, Int) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_EQ_CONG_26.with(| p | p.take()); buf.clear(); match (s, t) {
        (Str::IntToStr(ref sf0), Str::IntToStr(ref tf0)) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_EQ_CONG_26.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_int(s_f0, t_f0);

eq_str(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    str(s),
    str(t),
    for (s_f0, t_f0) in { std::thread_local! { static POOL_STR_EQ_CONG_27 : std::cell::Cell < Vec < (Str, Str) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_EQ_CONG_27.with(| p | p.take()); buf.clear(); match (s, t) {
        (Str::StrId(ref sf0), Str::StrId(ref tf0)) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_EQ_CONG_27.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_str(s_f0, t_f0);

eq_str(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* s)), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* t)),) <--
    str(s),
    str(t),
    for (s_f0, s_f1, t_f0, t_f1) in { std::thread_local! { static POOL_STR_EQ_CONG_28 : std::cell::Cell < Vec < (Str, Str, Str, Str) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_EQ_CONG_28.with(| p | p.take()); buf.clear(); match (s, t) {
        (Str::Concat(ref sf0, ref sf1), Str::Concat(ref tf0, ref tf1)) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        (Str::AddStr(ref sf0, ref sf1), Str::AddStr(ref tf0, ref tf1)) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* sf1.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf0.as_ref())), < Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* tf1.as_ref()))));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_EQ_CONG_28.with(| p | p.set(buf)); iter_buf }.into_iter(),
    eq_str(s_f0, t_f0),
    eq_str(s_f1, t_f1);


    // Rewrite rules
rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::EqInt(left, right) = s,
    if let Int::NumLit(a_ref) = left.as_ref(),
    if let Int::NumLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a == b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::EqFloat(left, right) = s,
    if let Float::FloatLit(a_ref) = left.as_ref(),
    if let Float::FloatLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a == b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::EqBool(left, right) = s,
    if let Bool::BoolLit(a_ref) = left.as_ref(),
    if let Bool::BoolLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a == b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::EqStr(left, right) = s,
    if let Str::StringLit(a_ref) = left.as_ref(),
    if let Str::StringLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a == b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::GtInt(left, right) = s,
    if let Int::NumLit(a_ref) = left.as_ref(),
    if let Int::NumLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a > b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::GtFloat(left, right) = s,
    if let Float::FloatLit(a_ref) = left.as_ref(),
    if let Float::FloatLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a > b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::GtBool(left, right) = s,
    if let Bool::BoolLit(a_ref) = left.as_ref(),
    if let Bool::BoolLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a & ! b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::GtStr(left, right) = s,
    if let Str::StringLit(a_ref) = left.as_ref(),
    if let Str::StringLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a > b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::LtInt(left, right) = s,
    if let Int::NumLit(a_ref) = left.as_ref(),
    if let Int::NumLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a < b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::LtFloat(left, right) = s,
    if let Float::FloatLit(a_ref) = left.as_ref(),
    if let Float::FloatLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a < b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::LtBool(left, right) = s,
    if let Bool::BoolLit(a_ref) = left.as_ref(),
    if let Bool::BoolLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((! a & b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::LtStr(left, right) = s,
    if let Str::StringLit(a_ref) = left.as_ref(),
    if let Str::StringLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a < b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::LtEqInt(left, right) = s,
    if let Int::NumLit(a_ref) = left.as_ref(),
    if let Int::NumLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a <= b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::LtEqFloat(left, right) = s,
    if let Float::FloatLit(a_ref) = left.as_ref(),
    if let Float::FloatLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a <= b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::LtEqBool(left, right) = s,
    if let Bool::BoolLit(a_ref) = left.as_ref(),
    if let Bool::BoolLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a <= b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::LtEqStr(left, right) = s,
    if let Str::StringLit(a_ref) = left.as_ref(),
    if let Str::StringLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a <= b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::GtEqInt(left, right) = s,
    if let Int::NumLit(a_ref) = left.as_ref(),
    if let Int::NumLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a >= b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::GtEqFloat(left, right) = s,
    if let Float::FloatLit(a_ref) = left.as_ref(),
    if let Float::FloatLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a >= b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::GtEqBool(left, right) = s,
    if let Bool::BoolLit(a_ref) = left.as_ref(),
    if let Bool::BoolLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a >= b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::GtEqStr(left, right) = s,
    if let Str::StringLit(a_ref) = left.as_ref(),
    if let Str::StringLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a >= b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::NeInt(left, right) = s,
    if let Int::NumLit(a_ref) = left.as_ref(),
    if let Int::NumLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a != b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::NeFloat(left, right) = s,
    if let Float::FloatLit(a_ref) = left.as_ref(),
    if let Float::FloatLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a != b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::NeBool(left, right) = s,
    if let Bool::BoolLit(a_ref) = left.as_ref(),
    if let Bool::BoolLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a != b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::NeStr(left, right) = s,
    if let Str::StringLit(a_ref) = left.as_ref(),
    if let Str::StringLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a != b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::And(left, right) = s,
    if let Bool::BoolLit(a_ref) = left.as_ref(),
    if let Bool::BoolLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a && b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::Or(left, right) = s,
    if let Bool::BoolLit(a_ref) = left.as_ref(),
    if let Bool::BoolLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a || b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::Xor(left, right) = s,
    if let Bool::BoolLit(a_ref) = left.as_ref(),
    if let Bool::BoolLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a ^ b));

rw_str(s.clone(), t) <--
    str(s),
    if let Str::Concat(left, right) = s,
    if let Str::StringLit(a_ref) = left.as_ref(),
    if let Str::StringLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Str::StringLit(([a, b].concat()));

rw_str(s.clone(), t) <--
    str(s),
    if let Str::AddStr(left, right) = s,
    if let Str::StringLit(a_ref) = left.as_ref(),
    if let Str::StringLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Str::StringLit(({ let mut x = a.clone(); x.push_str(& b); x }));

rw_int(s.clone(), t) <--
    int(s),
    if let Int::PowInt(left, right) = s,
    if let Int::NumLit(a_ref) = left.as_ref(),
    if let Int::NumLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Int::NumLit((a.pow(b as u32)));

rw_float(s.clone(), t) <--
    float(s),
    if let Float::PowFloat(left, right) = s,
    if let Float::FloatLit(a_ref) = left.as_ref(),
    if let Float::FloatLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Float::FloatLit((a.powf(b)));

rw_list(s.clone(), t) <--
    list(s),
    if let List::AppendList(left, right) = s,
    if let List::Lit(a_ref) = left.as_ref(),
    if let List::Lit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = List::Lit(({ let mut o = a.clone(); o.extend(b.iter().cloned()); o }));

rw_list(s.clone(), t) <--
    list(s),
    if let List::DeleteList(left, right) = s,
    if let List::Lit(a_ref) = left.as_ref(),
    if let Int::NumLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = List::Lit(({ let mut v = a.clone(); v.remove(b as usize); v }));

rw_int(orig.clone(), t) <--
    int(orig),
    if let Int::IntId(inner) = orig,
    if let Int::NumLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Int::NumLit((a));

rw_float(orig.clone(), t) <--
    float(orig),
    if let Float::FloatId(inner) = orig,
    if let Float::FloatLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Float::FloatLit((a));

rw_bool(orig.clone(), t) <--
    bool(orig),
    if let Bool::BoolId(inner) = orig,
    if let Bool::BoolLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Bool::BoolLit((a));

rw_str(orig.clone(), t) <--
    str(orig),
    if let Str::StrId(inner) = orig,
    if let Str::StringLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Str::StringLit((a));

rw_bool(orig.clone(), t) <--
    bool(orig),
    if let Bool::Not(inner) = orig,
    if let Bool::BoolLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Bool::BoolLit(({ match a { true => false, false => true, } }));

rw_int(orig.clone(), t) <--
    int(orig),
    if let Int::Len(inner) = orig,
    if let Str::StringLit(s_ref) = inner.as_ref(),
    let s = s_ref.clone(),
    let t = Int::NumLit((s.len() as i32));

rw_int(orig.clone(), t) <--
    int(orig),
    if let Int::Fact(inner) = orig,
    if let Int::NumLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Int::NumLit(({ (1 ..= a.max(0)).product::< i32 > () }));

rw_float(orig.clone(), t) <--
    float(orig),
    if let Float::SinFloat(inner) = orig,
    if let Float::FloatLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Float::FloatLit((a.sin()));

rw_float(orig.clone(), t) <--
    float(orig),
    if let Float::CosFloat(inner) = orig,
    if let Float::FloatLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Float::FloatLit((a.cos()));

rw_float(orig.clone(), t) <--
    float(orig),
    if let Float::ExpFloat(inner) = orig,
    if let Float::FloatLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Float::FloatLit((a.exp()));

rw_float(orig.clone(), t) <--
    float(orig),
    if let Float::LnFloat(inner) = orig,
    if let Float::FloatLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Float::FloatLit((a.ln()));

rw_float(orig.clone(), t) <--
    float(orig),
    if let Float::IntToFloat(inner) = orig,
    if let Int::NumLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Float::FloatLit((mettail_runtime::CanonicalFloat64::from(a as f64)));

rw_float(orig.clone(), t) <--
    float(orig),
    if let Float::BoolToFloat(inner) = orig,
    if let Bool::BoolLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Float::FloatLit((mettail_runtime::CanonicalFloat64::from(if a { 1.0 } else { 0.0 })));

rw_float(orig.clone(), t) <--
    float(orig),
    if let Float::StrToFloat(inner) = orig,
    if let Str::StringLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Float::FloatLit((mettail_runtime::CanonicalFloat64::from(a.parse().unwrap_or(0.0))));

rw_int(orig.clone(), t) <--
    int(orig),
    if let Int::FloatToInt(inner) = orig,
    if let Float::FloatLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Int::NumLit((a.get() as i32));

rw_int(orig.clone(), t) <--
    int(orig),
    if let Int::BoolToInt(inner) = orig,
    if let Bool::BoolLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Int::NumLit((if a { 1 } else { 0 }));

rw_int(orig.clone(), t) <--
    int(orig),
    if let Int::StrToInt(inner) = orig,
    if let Str::StringLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Int::NumLit((a.parse().unwrap_or(0)));

rw_str(orig.clone(), t) <--
    str(orig),
    if let Str::BoolToStr(inner) = orig,
    if let Bool::BoolLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Str::StringLit((a.to_string()));

rw_str(orig.clone(), t) <--
    str(orig),
    if let Str::IntToStr(inner) = orig,
    if let Int::NumLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Str::StringLit((a.to_string()));

rw_str(orig.clone(), t) <--
    str(orig),
    if let Str::FloatToStr(inner) = orig,
    if let Float::FloatLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Str::StringLit((a.to_string()));

rw_bool(orig.clone(), t) <--
    bool(orig),
    if let Bool::IntToBool(inner) = orig,
    if let Int::NumLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Bool::BoolLit((a != 0));

rw_bool(orig.clone(), t) <--
    bool(orig),
    if let Bool::FloatToBool(inner) = orig,
    if let Float::FloatLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Bool::BoolLit((a.get() != 0.0));

rw_bool(orig.clone(), t) <--
    bool(orig),
    if let Bool::StrToBool(inner) = orig,
    if let Str::StringLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Bool::BoolLit((a.parse().unwrap_or(false)));

rw_list(orig.clone(), t) <--
    list(orig),
    if let List::ListLit(inner) = orig,
    if let List::Lit(s_ref) = inner.as_ref(),
    let elements = s_ref.clone(),
    let t = List::Lit((elements));

rw_int(orig.clone(), t) <--
    int(orig),
    if let Int::LenList(inner) = orig,
    if let List::Lit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Int::NumLit((a.len() as i32));

rw_int(__src.clone(), __dst) <--
    int(__src),
    if let Int::Tern(f0, f1, f2) = __src,
    if let Int::NumLit(r0) = f0.as_ref(),
    if let Int::NumLit(r1) = f1.as_ref(),
    if let Int::NumLit(r2) = f2.as_ref(),
    let c = r0.clone(),
    let t = r1.clone(),
    let e = r2.clone(),
    let __dst = Int::NumLit(({ if c != 0 { t } else { e } }));

fold_int(t.clone(), t.clone()) <--
    int(t),
    if let Int::NumLit(_) = t;

fold_int(s.clone(), res) <--
    int(s),
    if let Int::IntId(inner) = s,
    fold_int(inner.as_ref().clone(), iv),
    if let Int::NumLit(a_ref) = & iv,
    let a = a_ref.clone(),
    let res = Int::NumLit((a));

fold_int(s.clone(), res) <--
    int(s),
    if let Int::AddInt(left, right) = s,
    fold_int(left.as_ref().clone(), lv),
    fold_int(right.as_ref().clone(), rv),
    if let Int::NumLit(a_ref) = & lv,
    if let Int::NumLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Int::NumLit((a + b));

fold_int(s.clone(), res) <--
    int(s),
    if let Int::SubInt(left, right) = s,
    fold_int(left.as_ref().clone(), lv),
    fold_int(right.as_ref().clone(), rv),
    if let Int::NumLit(a_ref) = & lv,
    if let Int::NumLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Int::NumLit((a - b));

fold_int(s.clone(), res) <--
    int(s),
    if let Int::MulInt(left, right) = s,
    fold_int(left.as_ref().clone(), lv),
    fold_int(right.as_ref().clone(), rv),
    if let Int::NumLit(a_ref) = & lv,
    if let Int::NumLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Int::NumLit((a * b));

fold_int(s.clone(), res) <--
    int(s),
    if let Int::DivInt(left, right) = s,
    fold_int(left.as_ref().clone(), lv),
    fold_int(right.as_ref().clone(), rv),
    if let Int::NumLit(a_ref) = & lv,
    if let Int::NumLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Int::NumLit((a / b));

fold_int(s.clone(), res) <--
    int(s),
    if let Int::ModInt(left, right) = s,
    fold_int(left.as_ref().clone(), lv),
    fold_int(right.as_ref().clone(), rv),
    if let Int::NumLit(a_ref) = & lv,
    if let Int::NumLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Int::NumLit((a % b));

fold_int(s.clone(), res) <--
    int(s),
    if let Int::PowInt(left, right) = s,
    fold_int(left.as_ref().clone(), lv),
    fold_int(right.as_ref().clone(), rv),
    if let Int::NumLit(a_ref) = & lv,
    if let Int::NumLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Int::NumLit((a.pow(b as u32)));

fold_int(s.clone(), res) <--
    int(s),
    if let Int::Neg(inner) = s,
    fold_int(inner.as_ref().clone(), iv),
    if let Int::NumLit(a_ref) = & iv,
    let a = a_ref.clone(),
    let res = Int::NumLit(((- a)));

fold_int(s.clone(), res) <--
    int(s),
    if let Int::Fact(inner) = s,
    fold_int(inner.as_ref().clone(), iv),
    if let Int::NumLit(a_ref) = & iv,
    let a = a_ref.clone(),
    let res = Int::NumLit(({ (1 ..= a.max(0)).product::< i32 > () }));

fold_int(s.clone(), res) <--
    int(s),
    if let Int::CustomOp(left, right) = s,
    fold_int(left.as_ref().clone(), lv),
    fold_int(right.as_ref().clone(), rv),
    if let Int::NumLit(a_ref) = & lv,
    if let Int::NumLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Int::NumLit((2 * a + 3 * b));

rw_int(s.clone(), t.clone()) <--
    int(s),
    if (match s {
        Int::AddInt(_, _) => true,
        Int::SubInt(_, _) => true,
        Int::MulInt(_, _) => true,
        Int::DivInt(_, _) => true,
        Int::ModInt(_, _) => true,
        Int::Neg(_) => true,
        Int::CustomOp(_, _) => true,
        _ => false,
    }),
    fold_int(s, t);

fold_float(t.clone(), t.clone()) <--
    float(t),
    if let Float::FloatLit(_) = t;

fold_float(s.clone(), res) <--
    float(s),
    if let Float::FloatId(inner) = s,
    fold_float(inner.as_ref().clone(), iv),
    if let Float::FloatLit(a_ref) = & iv,
    let a = a_ref.clone(),
    let res = Float::FloatLit((a));

fold_float(s.clone(), res) <--
    float(s),
    if let Float::AddFloat(left, right) = s,
    fold_float(left.as_ref().clone(), lv),
    fold_float(right.as_ref().clone(), rv),
    if let Float::FloatLit(a_ref) = & lv,
    if let Float::FloatLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Float::FloatLit((a + b));

fold_float(s.clone(), res) <--
    float(s),
    if let Float::SubFloat(left, right) = s,
    fold_float(left.as_ref().clone(), lv),
    fold_float(right.as_ref().clone(), rv),
    if let Float::FloatLit(a_ref) = & lv,
    if let Float::FloatLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Float::FloatLit((a - b));

fold_float(s.clone(), res) <--
    float(s),
    if let Float::MulFloat(left, right) = s,
    fold_float(left.as_ref().clone(), lv),
    fold_float(right.as_ref().clone(), rv),
    if let Float::FloatLit(a_ref) = & lv,
    if let Float::FloatLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Float::FloatLit((a * b));

fold_float(s.clone(), res) <--
    float(s),
    if let Float::DivFloat(left, right) = s,
    fold_float(left.as_ref().clone(), lv),
    fold_float(right.as_ref().clone(), rv),
    if let Float::FloatLit(a_ref) = & lv,
    if let Float::FloatLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Float::FloatLit((a / b));

fold_float(s.clone(), res) <--
    float(s),
    if let Float::PowFloat(left, right) = s,
    fold_float(left.as_ref().clone(), lv),
    fold_float(right.as_ref().clone(), rv),
    if let Float::FloatLit(a_ref) = & lv,
    if let Float::FloatLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Float::FloatLit((a.powf(b)));

fold_float(s.clone(), res) <--
    float(s),
    if let Float::SinFloat(inner) = s,
    fold_float(inner.as_ref().clone(), iv),
    if let Float::FloatLit(a_ref) = & iv,
    let a = a_ref.clone(),
    let res = Float::FloatLit((a.sin()));

fold_float(s.clone(), res) <--
    float(s),
    if let Float::CosFloat(inner) = s,
    fold_float(inner.as_ref().clone(), iv),
    if let Float::FloatLit(a_ref) = & iv,
    let a = a_ref.clone(),
    let res = Float::FloatLit((a.cos()));

fold_float(s.clone(), res) <--
    float(s),
    if let Float::ExpFloat(inner) = s,
    fold_float(inner.as_ref().clone(), iv),
    if let Float::FloatLit(a_ref) = & iv,
    let a = a_ref.clone(),
    let res = Float::FloatLit((a.exp()));

fold_float(s.clone(), res) <--
    float(s),
    if let Float::LnFloat(inner) = s,
    fold_float(inner.as_ref().clone(), iv),
    if let Float::FloatLit(a_ref) = & iv,
    let a = a_ref.clone(),
    let res = Float::FloatLit((a.ln()));

rw_float(s.clone(), t.clone()) <--
    float(s),
    if (match s {
        Float::AddFloat(_, _) => true,
        Float::SubFloat(_, _) => true,
        Float::MulFloat(_, _) => true,
        Float::DivFloat(_, _) => true,
        _ => false,
    }),
    fold_float(s, t);

rw_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (Bool::EqBool(_, ref x1), 0usize) => Bool::EqBool(Box::new(t.clone()), x1.clone()),
    (Bool::EqBool(ref x0, _), 1usize) => Bool::EqBool(x0.clone(), Box::new(t.clone())),
    (Bool::GtBool(_, ref x1), 2usize) => Bool::GtBool(Box::new(t.clone()), x1.clone()),
    (Bool::GtBool(ref x0, _), 3usize) => Bool::GtBool(x0.clone(), Box::new(t.clone())),
    (Bool::LtBool(_, ref x1), 4usize) => Bool::LtBool(Box::new(t.clone()), x1.clone()),
    (Bool::LtBool(ref x0, _), 5usize) => Bool::LtBool(x0.clone(), Box::new(t.clone())),
    (Bool::LtEqBool(_, ref x1), 6usize) => Bool::LtEqBool(Box::new(t.clone()), x1.clone()),
    (Bool::LtEqBool(ref x0, _), 7usize) => Bool::LtEqBool(x0.clone(), Box::new(t.clone())),
    (Bool::GtEqBool(_, ref x1), 8usize) => Bool::GtEqBool(Box::new(t.clone()), x1.clone()),
    (Bool::GtEqBool(ref x0, _), 9usize) => Bool::GtEqBool(x0.clone(), Box::new(t.clone())),
    (Bool::NeBool(_, ref x1), 10usize) => Bool::NeBool(Box::new(t.clone()), x1.clone()),
    (Bool::NeBool(ref x0, _), 11usize) => Bool::NeBool(x0.clone(), Box::new(t.clone())),
    (Bool::And(_, ref x1), 12usize) => Bool::And(Box::new(t.clone()), x1.clone()),
    (Bool::And(ref x0, _), 13usize) => Bool::And(x0.clone(), Box::new(t.clone())),
    (Bool::Or(_, ref x1), 14usize) => Bool::Or(Box::new(t.clone()), x1.clone()),
    (Bool::Or(ref x0, _), 15usize) => Bool::Or(x0.clone(), Box::new(t.clone())),
    (Bool::Xor(_, ref x1), 16usize) => Bool::Xor(Box::new(t.clone()), x1.clone()),
    (Bool::Xor(ref x0, _), 17usize) => Bool::Xor(x0.clone(), Box::new(t.clone())),
    (Bool::Not(_), 18usize) => Bool::Not(Box::new(t.clone())),
    (Bool::BoolId(_), 19usize) => Bool::BoolId(Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    bool(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_BOOL_SCONG_BOOL : std::cell::Cell < Vec < (Bool, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_SCONG_BOOL.with(| p | p.take()); buf.clear(); match lhs {
        Bool::And(ref x0, ref x1) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 12usize));
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 13usize));
        },
        Bool::BoolId(ref x0) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 19usize));
        },
        Bool::EqBool(ref x0, ref x1) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 0usize));
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 1usize));
        },
        Bool::GtBool(ref x0, ref x1) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 2usize));
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 3usize));
        },
        Bool::GtEqBool(ref x0, ref x1) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 8usize));
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 9usize));
        },
        Bool::LtBool(ref x0, ref x1) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 4usize));
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 5usize));
        },
        Bool::LtEqBool(ref x0, ref x1) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 6usize));
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 7usize));
        },
        Bool::NeBool(ref x0, ref x1) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 10usize));
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 11usize));
        },
        Bool::Not(ref x0) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 18usize));
        },
        Bool::Or(ref x0, ref x1) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 14usize));
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 15usize));
        },
        Bool::Xor(ref x0, ref x1) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 16usize));
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 17usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_SCONG_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_bool(field_val, t);

rw_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (Bool::EqFloat(_, ref x1), 0usize) => Bool::EqFloat(Box::new(t.clone()), x1.clone()),
    (Bool::EqFloat(ref x0, _), 1usize) => Bool::EqFloat(x0.clone(), Box::new(t.clone())),
    (Bool::GtFloat(_, ref x1), 2usize) => Bool::GtFloat(Box::new(t.clone()), x1.clone()),
    (Bool::GtFloat(ref x0, _), 3usize) => Bool::GtFloat(x0.clone(), Box::new(t.clone())),
    (Bool::LtFloat(_, ref x1), 4usize) => Bool::LtFloat(Box::new(t.clone()), x1.clone()),
    (Bool::LtFloat(ref x0, _), 5usize) => Bool::LtFloat(x0.clone(), Box::new(t.clone())),
    (Bool::LtEqFloat(_, ref x1), 6usize) => Bool::LtEqFloat(Box::new(t.clone()), x1.clone()),
    (Bool::LtEqFloat(ref x0, _), 7usize) => Bool::LtEqFloat(x0.clone(), Box::new(t.clone())),
    (Bool::GtEqFloat(_, ref x1), 8usize) => Bool::GtEqFloat(Box::new(t.clone()), x1.clone()),
    (Bool::GtEqFloat(ref x0, _), 9usize) => Bool::GtEqFloat(x0.clone(), Box::new(t.clone())),
    (Bool::NeFloat(_, ref x1), 10usize) => Bool::NeFloat(Box::new(t.clone()), x1.clone()),
    (Bool::NeFloat(ref x0, _), 11usize) => Bool::NeFloat(x0.clone(), Box::new(t.clone())),
    (Bool::FloatToBool(_), 12usize) => Bool::FloatToBool(Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    bool(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_BOOL_SCONG_FLOAT : std::cell::Cell < Vec < (Float, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_SCONG_FLOAT.with(| p | p.take()); buf.clear(); match lhs {
        Bool::EqFloat(ref x0, ref x1) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 0usize));
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 1usize));
        },
        Bool::FloatToBool(ref x0) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 12usize));
        },
        Bool::GtEqFloat(ref x0, ref x1) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 8usize));
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 9usize));
        },
        Bool::GtFloat(ref x0, ref x1) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 2usize));
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 3usize));
        },
        Bool::LtEqFloat(ref x0, ref x1) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 6usize));
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 7usize));
        },
        Bool::LtFloat(ref x0, ref x1) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 4usize));
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 5usize));
        },
        Bool::NeFloat(ref x0, ref x1) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 10usize));
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 11usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_SCONG_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_float(field_val, t);

rw_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (Bool::EqInt(_, ref x1), 0usize) => Bool::EqInt(Box::new(t.clone()), x1.clone()),
    (Bool::EqInt(ref x0, _), 1usize) => Bool::EqInt(x0.clone(), Box::new(t.clone())),
    (Bool::GtInt(_, ref x1), 2usize) => Bool::GtInt(Box::new(t.clone()), x1.clone()),
    (Bool::GtInt(ref x0, _), 3usize) => Bool::GtInt(x0.clone(), Box::new(t.clone())),
    (Bool::LtInt(_, ref x1), 4usize) => Bool::LtInt(Box::new(t.clone()), x1.clone()),
    (Bool::LtInt(ref x0, _), 5usize) => Bool::LtInt(x0.clone(), Box::new(t.clone())),
    (Bool::LtEqInt(_, ref x1), 6usize) => Bool::LtEqInt(Box::new(t.clone()), x1.clone()),
    (Bool::LtEqInt(ref x0, _), 7usize) => Bool::LtEqInt(x0.clone(), Box::new(t.clone())),
    (Bool::GtEqInt(_, ref x1), 8usize) => Bool::GtEqInt(Box::new(t.clone()), x1.clone()),
    (Bool::GtEqInt(ref x0, _), 9usize) => Bool::GtEqInt(x0.clone(), Box::new(t.clone())),
    (Bool::NeInt(_, ref x1), 10usize) => Bool::NeInt(Box::new(t.clone()), x1.clone()),
    (Bool::NeInt(ref x0, _), 11usize) => Bool::NeInt(x0.clone(), Box::new(t.clone())),
    (Bool::IntToBool(_), 12usize) => Bool::IntToBool(Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    bool(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_BOOL_SCONG_INT : std::cell::Cell < Vec < (Int, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_SCONG_INT.with(| p | p.take()); buf.clear(); match lhs {
        Bool::EqInt(ref x0, ref x1) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 0usize));
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 1usize));
        },
        Bool::GtEqInt(ref x0, ref x1) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 8usize));
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 9usize));
        },
        Bool::GtInt(ref x0, ref x1) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 2usize));
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 3usize));
        },
        Bool::IntToBool(ref x0) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 12usize));
        },
        Bool::LtEqInt(ref x0, ref x1) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 6usize));
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 7usize));
        },
        Bool::LtInt(ref x0, ref x1) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 4usize));
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 5usize));
        },
        Bool::NeInt(ref x0, ref x1) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 10usize));
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 11usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_SCONG_INT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_int(field_val, t);

rw_bool(< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (Bool::EqStr(_, ref x1), 0usize) => Bool::EqStr(Box::new(t.clone()), x1.clone()),
    (Bool::EqStr(ref x0, _), 1usize) => Bool::EqStr(x0.clone(), Box::new(t.clone())),
    (Bool::GtStr(_, ref x1), 2usize) => Bool::GtStr(Box::new(t.clone()), x1.clone()),
    (Bool::GtStr(ref x0, _), 3usize) => Bool::GtStr(x0.clone(), Box::new(t.clone())),
    (Bool::LtStr(_, ref x1), 4usize) => Bool::LtStr(Box::new(t.clone()), x1.clone()),
    (Bool::LtStr(ref x0, _), 5usize) => Bool::LtStr(x0.clone(), Box::new(t.clone())),
    (Bool::LtEqStr(_, ref x1), 6usize) => Bool::LtEqStr(Box::new(t.clone()), x1.clone()),
    (Bool::LtEqStr(ref x0, _), 7usize) => Bool::LtEqStr(x0.clone(), Box::new(t.clone())),
    (Bool::GtEqStr(_, ref x1), 8usize) => Bool::GtEqStr(Box::new(t.clone()), x1.clone()),
    (Bool::GtEqStr(ref x0, _), 9usize) => Bool::GtEqStr(x0.clone(), Box::new(t.clone())),
    (Bool::NeStr(_, ref x1), 10usize) => Bool::NeStr(Box::new(t.clone()), x1.clone()),
    (Bool::NeStr(ref x0, _), 11usize) => Bool::NeStr(x0.clone(), Box::new(t.clone())),
    (Bool::StrToBool(_), 12usize) => Bool::StrToBool(Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    bool(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_BOOL_SCONG_STR : std::cell::Cell < Vec < (Str, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_BOOL_SCONG_STR.with(| p | p.take()); buf.clear(); match lhs {
        Bool::EqStr(ref x0, ref x1) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 0usize));
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 1usize));
        },
        Bool::GtEqStr(ref x0, ref x1) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 8usize));
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 9usize));
        },
        Bool::GtStr(ref x0, ref x1) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 2usize));
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 3usize));
        },
        Bool::LtEqStr(ref x0, ref x1) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 6usize));
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 7usize));
        },
        Bool::LtStr(ref x0, ref x1) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 4usize));
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 5usize));
        },
        Bool::NeStr(ref x0, ref x1) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 10usize));
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 11usize));
        },
        Bool::StrToBool(ref x0) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 12usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_BOOL_SCONG_STR.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_str(field_val, t);

rw_float(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (Float::BoolToFloat(_), 0usize) => Float::BoolToFloat(Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    float(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_FLOAT_SCONG_BOOL : std::cell::Cell < Vec < (Bool, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_SCONG_BOOL.with(| p | p.take()); buf.clear(); match lhs {
        Float::BoolToFloat(ref x0) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 0usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_SCONG_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_bool(field_val, t);

rw_float(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (Float::AddFloat(_, ref x1), 0usize) => Float::AddFloat(Box::new(t.clone()), x1.clone()),
    (Float::AddFloat(ref x0, _), 1usize) => Float::AddFloat(x0.clone(), Box::new(t.clone())),
    (Float::SubFloat(_, ref x1), 2usize) => Float::SubFloat(Box::new(t.clone()), x1.clone()),
    (Float::SubFloat(ref x0, _), 3usize) => Float::SubFloat(x0.clone(), Box::new(t.clone())),
    (Float::MulFloat(_, ref x1), 4usize) => Float::MulFloat(Box::new(t.clone()), x1.clone()),
    (Float::MulFloat(ref x0, _), 5usize) => Float::MulFloat(x0.clone(), Box::new(t.clone())),
    (Float::DivFloat(_, ref x1), 6usize) => Float::DivFloat(Box::new(t.clone()), x1.clone()),
    (Float::DivFloat(ref x0, _), 7usize) => Float::DivFloat(x0.clone(), Box::new(t.clone())),
    (Float::PowFloat(_, ref x1), 8usize) => Float::PowFloat(Box::new(t.clone()), x1.clone()),
    (Float::PowFloat(ref x0, _), 9usize) => Float::PowFloat(x0.clone(), Box::new(t.clone())),
    (Float::SinFloat(_), 10usize) => Float::SinFloat(Box::new(t.clone())),
    (Float::CosFloat(_), 11usize) => Float::CosFloat(Box::new(t.clone())),
    (Float::ExpFloat(_), 12usize) => Float::ExpFloat(Box::new(t.clone())),
    (Float::LnFloat(_), 13usize) => Float::LnFloat(Box::new(t.clone())),
    (Float::FloatId(_), 14usize) => Float::FloatId(Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    float(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_FLOAT_SCONG_FLOAT : std::cell::Cell < Vec < (Float, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_SCONG_FLOAT.with(| p | p.take()); buf.clear(); match lhs {
        Float::AddFloat(ref x0, ref x1) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 0usize));
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 1usize));
        },
        Float::CosFloat(ref x0) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 11usize));
        },
        Float::DivFloat(ref x0, ref x1) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 6usize));
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 7usize));
        },
        Float::ExpFloat(ref x0) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 12usize));
        },
        Float::FloatId(ref x0) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 14usize));
        },
        Float::LnFloat(ref x0) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 13usize));
        },
        Float::MulFloat(ref x0, ref x1) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 4usize));
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 5usize));
        },
        Float::PowFloat(ref x0, ref x1) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 8usize));
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 9usize));
        },
        Float::SinFloat(ref x0) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 10usize));
        },
        Float::SubFloat(ref x0, ref x1) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 2usize));
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 3usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_SCONG_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_float(field_val, t);

rw_float(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (Float::IntToFloat(_), 0usize) => Float::IntToFloat(Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    float(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_FLOAT_SCONG_INT : std::cell::Cell < Vec < (Int, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_SCONG_INT.with(| p | p.take()); buf.clear(); match lhs {
        Float::IntToFloat(ref x0) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 0usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_SCONG_INT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_int(field_val, t);

rw_float(< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (Float::StrToFloat(_), 0usize) => Float::StrToFloat(Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    float(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_FLOAT_SCONG_STR : std::cell::Cell < Vec < (Str, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_FLOAT_SCONG_STR.with(| p | p.take()); buf.clear(); match lhs {
        Float::StrToFloat(ref x0) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 0usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_FLOAT_SCONG_STR.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_str(field_val, t);

rw_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (Int::BoolToInt(_), 0usize) => Int::BoolToInt(Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    int(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_INT_SCONG_BOOL : std::cell::Cell < Vec < (Bool, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_SCONG_BOOL.with(| p | p.take()); buf.clear(); match lhs {
        Int::BoolToInt(ref x0) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 0usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_SCONG_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_bool(field_val, t);

rw_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (Int::FloatToInt(_), 0usize) => Int::FloatToInt(Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    int(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_INT_SCONG_FLOAT : std::cell::Cell < Vec < (Float, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_SCONG_FLOAT.with(| p | p.take()); buf.clear(); match lhs {
        Int::FloatToInt(ref x0) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 0usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_SCONG_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_float(field_val, t);

rw_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (Int::AddInt(_, ref x1), 0usize) => Int::AddInt(Box::new(t.clone()), x1.clone()),
    (Int::AddInt(ref x0, _), 1usize) => Int::AddInt(x0.clone(), Box::new(t.clone())),
    (Int::Neg(_), 2usize) => Int::Neg(Box::new(t.clone())),
    (Int::SubInt(_, ref x1), 3usize) => Int::SubInt(Box::new(t.clone()), x1.clone()),
    (Int::SubInt(ref x0, _), 4usize) => Int::SubInt(x0.clone(), Box::new(t.clone())),
    (Int::MulInt(_, ref x1), 5usize) => Int::MulInt(Box::new(t.clone()), x1.clone()),
    (Int::MulInt(ref x0, _), 6usize) => Int::MulInt(x0.clone(), Box::new(t.clone())),
    (Int::DivInt(_, ref x1), 7usize) => Int::DivInt(Box::new(t.clone()), x1.clone()),
    (Int::DivInt(ref x0, _), 8usize) => Int::DivInt(x0.clone(), Box::new(t.clone())),
    (Int::ModInt(_, ref x1), 9usize) => Int::ModInt(Box::new(t.clone()), x1.clone()),
    (Int::ModInt(ref x0, _), 10usize) => Int::ModInt(x0.clone(), Box::new(t.clone())),
    (Int::PowInt(_, ref x1), 11usize) => Int::PowInt(Box::new(t.clone()), x1.clone()),
    (Int::PowInt(ref x0, _), 12usize) => Int::PowInt(x0.clone(), Box::new(t.clone())),
    (Int::Fact(_), 13usize) => Int::Fact(Box::new(t.clone())),
    (Int::IntId(_), 14usize) => Int::IntId(Box::new(t.clone())),
    (Int::CustomOp(_, ref x1), 15usize) => Int::CustomOp(Box::new(t.clone()), x1.clone()),
    (Int::CustomOp(ref x0, _), 16usize) => Int::CustomOp(x0.clone(), Box::new(t.clone())),
    (Int::Tern(_, ref x1, ref x2), 17usize) => Int::Tern(Box::new(t.clone()), x1.clone(), x2.clone()),
    (Int::Tern(ref x0, _, ref x2), 18usize) => Int::Tern(x0.clone(), Box::new(t.clone()), x2.clone()),
    (Int::Tern(ref x0, ref x1, _), 19usize) => Int::Tern(x0.clone(), x1.clone(), Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    int(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_INT_SCONG_INT : std::cell::Cell < Vec < (Int, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_SCONG_INT.with(| p | p.take()); buf.clear(); match lhs {
        Int::AddInt(ref x0, ref x1) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 0usize));
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 1usize));
        },
        Int::CustomOp(ref x0, ref x1) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 15usize));
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 16usize));
        },
        Int::DivInt(ref x0, ref x1) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 7usize));
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 8usize));
        },
        Int::Fact(ref x0) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 13usize));
        },
        Int::IntId(ref x0) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 14usize));
        },
        Int::ModInt(ref x0, ref x1) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 9usize));
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 10usize));
        },
        Int::MulInt(ref x0, ref x1) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 5usize));
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 6usize));
        },
        Int::Neg(ref x0) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 2usize));
        },
        Int::PowInt(ref x0, ref x1) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 11usize));
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 12usize));
        },
        Int::SubInt(ref x0, ref x1) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 3usize));
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 4usize));
        },
        Int::Tern(ref x0, ref x1, ref x2) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 17usize));
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 18usize));
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x2)), 19usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_SCONG_INT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_int(field_val, t);

rw_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (Int::LenList(_), 0usize) => Int::LenList(Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    int(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_INT_SCONG_LIST : std::cell::Cell < Vec < (List, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_SCONG_LIST.with(| p | p.take()); buf.clear(); match lhs {
        Int::LenList(ref x0) => {
            buf.push((< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 0usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_SCONG_LIST.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_list(field_val, t);

rw_int(< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (Int::Len(_), 0usize) => Int::Len(Box::new(t.clone())),
    (Int::StrToInt(_), 1usize) => Int::StrToInt(Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    int(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_INT_SCONG_STR : std::cell::Cell < Vec < (Str, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_INT_SCONG_STR.with(| p | p.take()); buf.clear(); match lhs {
        Int::Len(ref x0) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 0usize));
        },
        Int::StrToInt(ref x0) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 1usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_INT_SCONG_STR.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_str(field_val, t);

rw_list(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (List::DeleteList(ref x0, _), 0usize) => List::DeleteList(x0.clone(), Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    list(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_LIST_SCONG_INT : std::cell::Cell < Vec < (Int, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_LIST_SCONG_INT.with(| p | p.take()); buf.clear(); match lhs {
        List::DeleteList(_, ref x1) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 0usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_LIST_SCONG_INT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_int(field_val, t);

rw_list(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (List::ListLit(_), 0usize) => List::ListLit(Box::new(t.clone())),
    (List::AppendList(_, ref x1), 1usize) => List::AppendList(Box::new(t.clone()), x1.clone()),
    (List::AppendList(ref x0, _), 2usize) => List::AppendList(x0.clone(), Box::new(t.clone())),
    (List::DeleteList(_, ref x1), 3usize) => List::DeleteList(Box::new(t.clone()), x1.clone()),
    _ => unreachable!(),
}) <--
    list(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_LIST_SCONG_LIST : std::cell::Cell < Vec < (List, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_LIST_SCONG_LIST.with(| p | p.take()); buf.clear(); match lhs {
        List::AppendList(ref x0, ref x1) => {
            buf.push((< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 1usize));
            buf.push((< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 2usize));
        },
        List::DeleteList(ref x0, _) => {
            buf.push((< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 3usize));
        },
        List::ListLit(ref x0) => {
            buf.push((< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 0usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_LIST_SCONG_LIST.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_list(field_val, t);

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (Proc::ElemList(ref x0, _), 0usize) => Proc::ElemList(x0.clone(), Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    proc(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_PROC_SCONG_INT : std::cell::Cell < Vec < (Int, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_SCONG_INT.with(| p | p.take()); buf.clear(); match lhs {
        Proc::ElemList(_, ref x1) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 0usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_SCONG_INT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_int(field_val, t);

rw_proc(< Proc as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (Proc::ElemList(_, ref x1), 0usize) => Proc::ElemList(Box::new(t.clone()), x1.clone()),
    _ => unreachable!(),
}) <--
    proc(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_PROC_SCONG_LIST : std::cell::Cell < Vec < (List, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_PROC_SCONG_LIST.with(| p | p.take()); buf.clear(); match lhs {
        Proc::ElemList(ref x0, _) => {
            buf.push((< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 0usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_PROC_SCONG_LIST.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_list(field_val, t);

rw_str(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (Str::BoolToStr(_), 0usize) => Str::BoolToStr(Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    str(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_STR_SCONG_BOOL : std::cell::Cell < Vec < (Bool, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_SCONG_BOOL.with(| p | p.take()); buf.clear(); match lhs {
        Str::BoolToStr(ref x0) => {
            buf.push((< Bool as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 0usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_SCONG_BOOL.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_bool(field_val, t);

rw_str(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (Str::FloatToStr(_), 0usize) => Str::FloatToStr(Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    str(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_STR_SCONG_FLOAT : std::cell::Cell < Vec < (Float, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_SCONG_FLOAT.with(| p | p.take()); buf.clear(); match lhs {
        Str::FloatToStr(ref x0) => {
            buf.push((< Float as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 0usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_SCONG_FLOAT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_float(field_val, t);

rw_str(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (Str::IntToStr(_), 0usize) => Str::IntToStr(Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    str(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_STR_SCONG_INT : std::cell::Cell < Vec < (Int, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_SCONG_INT.with(| p | p.take()); buf.clear(); match lhs {
        Str::IntToStr(ref x0) => {
            buf.push((< Int as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 0usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_SCONG_INT.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_int(field_val, t);

rw_str(< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), match (lhs, vi) {
    (Str::Concat(_, ref x1), 0usize) => Str::Concat(Box::new(t.clone()), x1.clone()),
    (Str::Concat(ref x0, _), 1usize) => Str::Concat(x0.clone(), Box::new(t.clone())),
    (Str::AddStr(_, ref x1), 2usize) => Str::AddStr(Box::new(t.clone()), x1.clone()),
    (Str::AddStr(ref x0, _), 3usize) => Str::AddStr(x0.clone(), Box::new(t.clone())),
    (Str::StrId(_), 4usize) => Str::StrId(Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    str(lhs),
    for (field_val, vi) in { std::thread_local! { static POOL_STR_SCONG_STR : std::cell::Cell < Vec < (Str, usize) >> = const { std::cell::Cell::new(Vec::new()) }; } let mut buf = POOL_STR_SCONG_STR.with(| p | p.take()); buf.clear(); match lhs {
        Str::AddStr(ref x0, ref x1) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 2usize));
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 3usize));
        },
        Str::Concat(ref x0, ref x1) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 0usize));
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x1)), 1usize));
        },
        Str::StrId(ref x0) => {
            buf.push((< Str as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* x0)), 4usize));
        },
        _ => {},
    } let iter_buf = std::mem::take(& mut buf); POOL_STR_SCONG_STR.with(| p | p.set(buf)); iter_buf }.into_iter(),
    rw_str(field_val, t);

rw_list(< List as std::clone::Clone >::clone(std::borrow::Borrow::borrow(&* lhs)), result) <--
    list(lhs),
    if let List::Lit(ref vec) = lhs,
    for (idx, elem) in vec.iter().enumerate(),
    rw_proc(elem.clone(), elem_rewritten),
    let result = List::Lit({ let mut v = vec.clone(); v [idx] = elem_rewritten.clone(); v });

}

// Generated Ascent Datalog for calculator theory
// This file is generated by the theory! macro and is for inspection only.
// Do not edit manually - changes will be overwritten.

ascent_source! {
    calculator_source:

    // Relations
relation int(Int);

relation float(Float);

relation bool(Bool);

relation str(Str);

#[ds(crate :: eqrel)] relation eq_int(Int, Int);

#[ds(crate :: eqrel)] relation eq_float(Float, Float);

#[ds(crate :: eqrel)] relation eq_bool(Bool, Bool);

#[ds(crate :: eqrel)] relation eq_str(Str, Str);

relation rw_int(Int, Int);

relation rw_float(Float, Float);

relation rw_bool(Bool, Bool);

relation rw_str(Str, Str);

relation fold_int(Int, Int);

relation fold_float(Float, Float);


    // Category rules
int(c1.clone()) <--
    int(c0),
    rw_int(c0, c1);

str(field_0.as_ref().clone()) <--
    int(t),
    if let Int :: Len(field_0) = t;

int(field_0.as_ref().clone()),
int(field_1.as_ref().clone()) <--
    int(t),
    if let Int :: AddInt(field_0, field_1) = t;

int(field_0.as_ref().clone()),
int(field_1.as_ref().clone()) <--
    int(t),
    if let Int :: SubInt(field_0, field_1) = t;

int(field_0.as_ref().clone()),
int(field_1.as_ref().clone()) <--
    int(t),
    if let Int :: MulInt(field_0, field_1) = t;

int(field_0.as_ref().clone()),
int(field_1.as_ref().clone()) <--
    int(t),
    if let Int :: DivInt(field_0, field_1) = t;

int(field_0.as_ref().clone()),
int(field_1.as_ref().clone()) <--
    int(t),
    if let Int :: ModInt(field_0, field_1) = t;

int(field_0.as_ref().clone()),
int(field_1.as_ref().clone()) <--
    int(t),
    if let Int :: PowInt(field_0, field_1) = t;

float(field_0.as_ref().clone()) <--
    int(t),
    if let Int :: ToInt(field_0) = t;

int(field_0.as_ref().clone()) <--
    int(t),
    if let Int :: IntId(field_0) = t;

int(field_0.as_ref().clone()),
int(field_1.as_ref().clone()) <--
    int(t),
    if let Int :: CustomOp(field_0, field_1) = t;

int(lam.as_ref().clone()),
int(arg.as_ref().clone()) <--
    int(t),
    if let Int :: ApplyInt(lam, arg) = t;

int(lam.as_ref().clone()) <--
    int(t),
    if let Int :: MApplyInt(lam, _) = t;

int(arg.clone()) <--
    int(t),
    if let Int :: MApplyInt(_, args) = t,
    for arg in args.iter();

int((* scope.inner().unsafe_body).clone()) <--
    int(t),
    if let Int :: LamInt(scope) = t;

int((* scope.inner().unsafe_body).clone()) <--
    int(t),
    if let Int :: MLamInt(scope) = t;

int(lam.as_ref().clone()),
float(arg.as_ref().clone()) <--
    int(t),
    if let Int :: ApplyFloat(lam, arg) = t;

int(lam.as_ref().clone()) <--
    int(t),
    if let Int :: MApplyFloat(lam, _) = t;

float(arg.clone()) <--
    int(t),
    if let Int :: MApplyFloat(_, args) = t,
    for arg in args.iter();

int((* scope.inner().unsafe_body).clone()) <--
    int(t),
    if let Int :: LamFloat(scope) = t;

int((* scope.inner().unsafe_body).clone()) <--
    int(t),
    if let Int :: MLamFloat(scope) = t;

int(lam.as_ref().clone()),
bool(arg.as_ref().clone()) <--
    int(t),
    if let Int :: ApplyBool(lam, arg) = t;

int(lam.as_ref().clone()) <--
    int(t),
    if let Int :: MApplyBool(lam, _) = t;

bool(arg.clone()) <--
    int(t),
    if let Int :: MApplyBool(_, args) = t,
    for arg in args.iter();

int((* scope.inner().unsafe_body).clone()) <--
    int(t),
    if let Int :: LamBool(scope) = t;

int((* scope.inner().unsafe_body).clone()) <--
    int(t),
    if let Int :: MLamBool(scope) = t;

int(lam.as_ref().clone()),
str(arg.as_ref().clone()) <--
    int(t),
    if let Int :: ApplyStr(lam, arg) = t;

int(lam.as_ref().clone()) <--
    int(t),
    if let Int :: MApplyStr(lam, _) = t;

str(arg.clone()) <--
    int(t),
    if let Int :: MApplyStr(_, args) = t,
    for arg in args.iter();

int((* scope.inner().unsafe_body).clone()) <--
    int(t),
    if let Int :: LamStr(scope) = t;

int((* scope.inner().unsafe_body).clone()) <--
    int(t),
    if let Int :: MLamStr(scope) = t;

rw_int(Int :: ApplyInt(lam.clone(), arg.clone()), Int :: ApplyInt(Box :: new(lam_new.clone()), arg.clone())) <--
    int(t),
    if let Int :: ApplyInt(ref lam, ref arg) = t,
    rw_int(lam.as_ref().clone(), lam_new);

rw_int(Int :: ApplyInt(lam.clone(), arg.clone()), Int :: ApplyInt(lam.clone(), Box :: new(arg_new.clone()))) <--
    int(t),
    if let Int :: ApplyInt(ref lam, ref arg) = t,
    rw_int(arg.as_ref().clone(), arg_new);

rw_int(Int :: MApplyInt(lam.clone(), args.clone()), Int :: MApplyInt(Box :: new(lam_new.clone()), args.clone())) <--
    int(t),
    if let Int :: MApplyInt(ref lam, ref args) = t,
    rw_int(lam.as_ref().clone(), lam_new);

rw_int(Int :: ApplyFloat(lam.clone(), arg.clone()), Int :: ApplyFloat(Box :: new(lam_new.clone()), arg.clone())) <--
    int(t),
    if let Int :: ApplyFloat(ref lam, ref arg) = t,
    rw_int(lam.as_ref().clone(), lam_new);

rw_int(Int :: ApplyFloat(lam.clone(), arg.clone()), Int :: ApplyFloat(lam.clone(), Box :: new(arg_new.clone()))) <--
    int(t),
    if let Int :: ApplyFloat(ref lam, ref arg) = t,
    rw_float(arg.as_ref().clone(), arg_new);

rw_int(Int :: MApplyFloat(lam.clone(), args.clone()), Int :: MApplyFloat(Box :: new(lam_new.clone()), args.clone())) <--
    int(t),
    if let Int :: MApplyFloat(ref lam, ref args) = t,
    rw_int(lam.as_ref().clone(), lam_new);

rw_int(Int :: ApplyBool(lam.clone(), arg.clone()), Int :: ApplyBool(Box :: new(lam_new.clone()), arg.clone())) <--
    int(t),
    if let Int :: ApplyBool(ref lam, ref arg) = t,
    rw_int(lam.as_ref().clone(), lam_new);

rw_int(Int :: ApplyBool(lam.clone(), arg.clone()), Int :: ApplyBool(lam.clone(), Box :: new(arg_new.clone()))) <--
    int(t),
    if let Int :: ApplyBool(ref lam, ref arg) = t,
    rw_bool(arg.as_ref().clone(), arg_new);

rw_int(Int :: MApplyBool(lam.clone(), args.clone()), Int :: MApplyBool(Box :: new(lam_new.clone()), args.clone())) <--
    int(t),
    if let Int :: MApplyBool(ref lam, ref args) = t,
    rw_int(lam.as_ref().clone(), lam_new);

rw_int(Int :: ApplyStr(lam.clone(), arg.clone()), Int :: ApplyStr(Box :: new(lam_new.clone()), arg.clone())) <--
    int(t),
    if let Int :: ApplyStr(ref lam, ref arg) = t,
    rw_int(lam.as_ref().clone(), lam_new);

rw_int(Int :: ApplyStr(lam.clone(), arg.clone()), Int :: ApplyStr(lam.clone(), Box :: new(arg_new.clone()))) <--
    int(t),
    if let Int :: ApplyStr(ref lam, ref arg) = t,
    rw_str(arg.as_ref().clone(), arg_new);

rw_int(Int :: MApplyStr(lam.clone(), args.clone()), Int :: MApplyStr(Box :: new(lam_new.clone()), args.clone())) <--
    int(t),
    if let Int :: MApplyStr(ref lam, ref args) = t,
    rw_int(lam.as_ref().clone(), lam_new);

float(c1.clone()) <--
    float(c0),
    rw_float(c0, c1);

float(field_0.as_ref().clone()),
float(field_1.as_ref().clone()) <--
    float(t),
    if let Float :: AddFloat(field_0, field_1) = t;

float(field_0.as_ref().clone()),
float(field_1.as_ref().clone()) <--
    float(t),
    if let Float :: SubFloat(field_0, field_1) = t;

int(field_0.as_ref().clone()) <--
    float(t),
    if let Float :: ToFloat(field_0) = t;

float(field_0.as_ref().clone()) <--
    float(t),
    if let Float :: FloatId(field_0) = t;

float(lam.as_ref().clone()),
int(arg.as_ref().clone()) <--
    float(t),
    if let Float :: ApplyInt(lam, arg) = t;

float(lam.as_ref().clone()) <--
    float(t),
    if let Float :: MApplyInt(lam, _) = t;

int(arg.clone()) <--
    float(t),
    if let Float :: MApplyInt(_, args) = t,
    for arg in args.iter();

float((* scope.inner().unsafe_body).clone()) <--
    float(t),
    if let Float :: LamInt(scope) = t;

float((* scope.inner().unsafe_body).clone()) <--
    float(t),
    if let Float :: MLamInt(scope) = t;

float(lam.as_ref().clone()),
float(arg.as_ref().clone()) <--
    float(t),
    if let Float :: ApplyFloat(lam, arg) = t;

float(lam.as_ref().clone()) <--
    float(t),
    if let Float :: MApplyFloat(lam, _) = t;

float(arg.clone()) <--
    float(t),
    if let Float :: MApplyFloat(_, args) = t,
    for arg in args.iter();

float((* scope.inner().unsafe_body).clone()) <--
    float(t),
    if let Float :: LamFloat(scope) = t;

float((* scope.inner().unsafe_body).clone()) <--
    float(t),
    if let Float :: MLamFloat(scope) = t;

float(lam.as_ref().clone()),
bool(arg.as_ref().clone()) <--
    float(t),
    if let Float :: ApplyBool(lam, arg) = t;

float(lam.as_ref().clone()) <--
    float(t),
    if let Float :: MApplyBool(lam, _) = t;

bool(arg.clone()) <--
    float(t),
    if let Float :: MApplyBool(_, args) = t,
    for arg in args.iter();

float((* scope.inner().unsafe_body).clone()) <--
    float(t),
    if let Float :: LamBool(scope) = t;

float((* scope.inner().unsafe_body).clone()) <--
    float(t),
    if let Float :: MLamBool(scope) = t;

float(lam.as_ref().clone()),
str(arg.as_ref().clone()) <--
    float(t),
    if let Float :: ApplyStr(lam, arg) = t;

float(lam.as_ref().clone()) <--
    float(t),
    if let Float :: MApplyStr(lam, _) = t;

str(arg.clone()) <--
    float(t),
    if let Float :: MApplyStr(_, args) = t,
    for arg in args.iter();

float((* scope.inner().unsafe_body).clone()) <--
    float(t),
    if let Float :: LamStr(scope) = t;

float((* scope.inner().unsafe_body).clone()) <--
    float(t),
    if let Float :: MLamStr(scope) = t;

rw_float(Float :: ApplyInt(lam.clone(), arg.clone()), Float :: ApplyInt(Box :: new(lam_new.clone()), arg.clone())) <--
    float(t),
    if let Float :: ApplyInt(ref lam, ref arg) = t,
    rw_float(lam.as_ref().clone(), lam_new);

rw_float(Float :: ApplyInt(lam.clone(), arg.clone()), Float :: ApplyInt(lam.clone(), Box :: new(arg_new.clone()))) <--
    float(t),
    if let Float :: ApplyInt(ref lam, ref arg) = t,
    rw_int(arg.as_ref().clone(), arg_new);

rw_float(Float :: MApplyInt(lam.clone(), args.clone()), Float :: MApplyInt(Box :: new(lam_new.clone()), args.clone())) <--
    float(t),
    if let Float :: MApplyInt(ref lam, ref args) = t,
    rw_float(lam.as_ref().clone(), lam_new);

rw_float(Float :: ApplyFloat(lam.clone(), arg.clone()), Float :: ApplyFloat(Box :: new(lam_new.clone()), arg.clone())) <--
    float(t),
    if let Float :: ApplyFloat(ref lam, ref arg) = t,
    rw_float(lam.as_ref().clone(), lam_new);

rw_float(Float :: ApplyFloat(lam.clone(), arg.clone()), Float :: ApplyFloat(lam.clone(), Box :: new(arg_new.clone()))) <--
    float(t),
    if let Float :: ApplyFloat(ref lam, ref arg) = t,
    rw_float(arg.as_ref().clone(), arg_new);

rw_float(Float :: MApplyFloat(lam.clone(), args.clone()), Float :: MApplyFloat(Box :: new(lam_new.clone()), args.clone())) <--
    float(t),
    if let Float :: MApplyFloat(ref lam, ref args) = t,
    rw_float(lam.as_ref().clone(), lam_new);

rw_float(Float :: ApplyBool(lam.clone(), arg.clone()), Float :: ApplyBool(Box :: new(lam_new.clone()), arg.clone())) <--
    float(t),
    if let Float :: ApplyBool(ref lam, ref arg) = t,
    rw_float(lam.as_ref().clone(), lam_new);

rw_float(Float :: ApplyBool(lam.clone(), arg.clone()), Float :: ApplyBool(lam.clone(), Box :: new(arg_new.clone()))) <--
    float(t),
    if let Float :: ApplyBool(ref lam, ref arg) = t,
    rw_bool(arg.as_ref().clone(), arg_new);

rw_float(Float :: MApplyBool(lam.clone(), args.clone()), Float :: MApplyBool(Box :: new(lam_new.clone()), args.clone())) <--
    float(t),
    if let Float :: MApplyBool(ref lam, ref args) = t,
    rw_float(lam.as_ref().clone(), lam_new);

rw_float(Float :: ApplyStr(lam.clone(), arg.clone()), Float :: ApplyStr(Box :: new(lam_new.clone()), arg.clone())) <--
    float(t),
    if let Float :: ApplyStr(ref lam, ref arg) = t,
    rw_float(lam.as_ref().clone(), lam_new);

rw_float(Float :: ApplyStr(lam.clone(), arg.clone()), Float :: ApplyStr(lam.clone(), Box :: new(arg_new.clone()))) <--
    float(t),
    if let Float :: ApplyStr(ref lam, ref arg) = t,
    rw_str(arg.as_ref().clone(), arg_new);

rw_float(Float :: MApplyStr(lam.clone(), args.clone()), Float :: MApplyStr(Box :: new(lam_new.clone()), args.clone())) <--
    float(t),
    if let Float :: MApplyStr(ref lam, ref args) = t,
    rw_float(lam.as_ref().clone(), lam_new);

bool(c1.clone()) <--
    bool(c0),
    rw_bool(c0, c1);

int(field_0.as_ref().clone()),
int(field_1.as_ref().clone()) <--
    bool(t),
    if let Bool :: Eq(field_0, field_1) = t;

float(field_0.as_ref().clone()),
float(field_1.as_ref().clone()) <--
    bool(t),
    if let Bool :: EqFloat(field_0, field_1) = t;

bool(field_0.as_ref().clone()),
bool(field_1.as_ref().clone()) <--
    bool(t),
    if let Bool :: EqBool(field_0, field_1) = t;

str(field_0.as_ref().clone()),
str(field_1.as_ref().clone()) <--
    bool(t),
    if let Bool :: EqStr(field_0, field_1) = t;

bool(field_0.as_ref().clone()) <--
    bool(t),
    if let Bool :: Not(field_0) = t;

bool(field_0.as_ref().clone()),
bool(field_1.as_ref().clone()) <--
    bool(t),
    if let Bool :: Comp(field_0, field_1) = t;

bool(lam.as_ref().clone()),
int(arg.as_ref().clone()) <--
    bool(t),
    if let Bool :: ApplyInt(lam, arg) = t;

bool(lam.as_ref().clone()) <--
    bool(t),
    if let Bool :: MApplyInt(lam, _) = t;

int(arg.clone()) <--
    bool(t),
    if let Bool :: MApplyInt(_, args) = t,
    for arg in args.iter();

bool((* scope.inner().unsafe_body).clone()) <--
    bool(t),
    if let Bool :: LamInt(scope) = t;

bool((* scope.inner().unsafe_body).clone()) <--
    bool(t),
    if let Bool :: MLamInt(scope) = t;

bool(lam.as_ref().clone()),
float(arg.as_ref().clone()) <--
    bool(t),
    if let Bool :: ApplyFloat(lam, arg) = t;

bool(lam.as_ref().clone()) <--
    bool(t),
    if let Bool :: MApplyFloat(lam, _) = t;

float(arg.clone()) <--
    bool(t),
    if let Bool :: MApplyFloat(_, args) = t,
    for arg in args.iter();

bool((* scope.inner().unsafe_body).clone()) <--
    bool(t),
    if let Bool :: LamFloat(scope) = t;

bool((* scope.inner().unsafe_body).clone()) <--
    bool(t),
    if let Bool :: MLamFloat(scope) = t;

bool(lam.as_ref().clone()),
bool(arg.as_ref().clone()) <--
    bool(t),
    if let Bool :: ApplyBool(lam, arg) = t;

bool(lam.as_ref().clone()) <--
    bool(t),
    if let Bool :: MApplyBool(lam, _) = t;

bool(arg.clone()) <--
    bool(t),
    if let Bool :: MApplyBool(_, args) = t,
    for arg in args.iter();

bool((* scope.inner().unsafe_body).clone()) <--
    bool(t),
    if let Bool :: LamBool(scope) = t;

bool((* scope.inner().unsafe_body).clone()) <--
    bool(t),
    if let Bool :: MLamBool(scope) = t;

bool(lam.as_ref().clone()),
str(arg.as_ref().clone()) <--
    bool(t),
    if let Bool :: ApplyStr(lam, arg) = t;

bool(lam.as_ref().clone()) <--
    bool(t),
    if let Bool :: MApplyStr(lam, _) = t;

str(arg.clone()) <--
    bool(t),
    if let Bool :: MApplyStr(_, args) = t,
    for arg in args.iter();

bool((* scope.inner().unsafe_body).clone()) <--
    bool(t),
    if let Bool :: LamStr(scope) = t;

bool((* scope.inner().unsafe_body).clone()) <--
    bool(t),
    if let Bool :: MLamStr(scope) = t;

rw_bool(Bool :: ApplyInt(lam.clone(), arg.clone()), Bool :: ApplyInt(Box :: new(lam_new.clone()), arg.clone())) <--
    bool(t),
    if let Bool :: ApplyInt(ref lam, ref arg) = t,
    rw_bool(lam.as_ref().clone(), lam_new);

rw_bool(Bool :: ApplyInt(lam.clone(), arg.clone()), Bool :: ApplyInt(lam.clone(), Box :: new(arg_new.clone()))) <--
    bool(t),
    if let Bool :: ApplyInt(ref lam, ref arg) = t,
    rw_int(arg.as_ref().clone(), arg_new);

rw_bool(Bool :: MApplyInt(lam.clone(), args.clone()), Bool :: MApplyInt(Box :: new(lam_new.clone()), args.clone())) <--
    bool(t),
    if let Bool :: MApplyInt(ref lam, ref args) = t,
    rw_bool(lam.as_ref().clone(), lam_new);

rw_bool(Bool :: ApplyFloat(lam.clone(), arg.clone()), Bool :: ApplyFloat(Box :: new(lam_new.clone()), arg.clone())) <--
    bool(t),
    if let Bool :: ApplyFloat(ref lam, ref arg) = t,
    rw_bool(lam.as_ref().clone(), lam_new);

rw_bool(Bool :: ApplyFloat(lam.clone(), arg.clone()), Bool :: ApplyFloat(lam.clone(), Box :: new(arg_new.clone()))) <--
    bool(t),
    if let Bool :: ApplyFloat(ref lam, ref arg) = t,
    rw_float(arg.as_ref().clone(), arg_new);

rw_bool(Bool :: MApplyFloat(lam.clone(), args.clone()), Bool :: MApplyFloat(Box :: new(lam_new.clone()), args.clone())) <--
    bool(t),
    if let Bool :: MApplyFloat(ref lam, ref args) = t,
    rw_bool(lam.as_ref().clone(), lam_new);

rw_bool(Bool :: ApplyBool(lam.clone(), arg.clone()), Bool :: ApplyBool(Box :: new(lam_new.clone()), arg.clone())) <--
    bool(t),
    if let Bool :: ApplyBool(ref lam, ref arg) = t,
    rw_bool(lam.as_ref().clone(), lam_new);

rw_bool(Bool :: ApplyBool(lam.clone(), arg.clone()), Bool :: ApplyBool(lam.clone(), Box :: new(arg_new.clone()))) <--
    bool(t),
    if let Bool :: ApplyBool(ref lam, ref arg) = t,
    rw_bool(arg.as_ref().clone(), arg_new);

rw_bool(Bool :: MApplyBool(lam.clone(), args.clone()), Bool :: MApplyBool(Box :: new(lam_new.clone()), args.clone())) <--
    bool(t),
    if let Bool :: MApplyBool(ref lam, ref args) = t,
    rw_bool(lam.as_ref().clone(), lam_new);

rw_bool(Bool :: ApplyStr(lam.clone(), arg.clone()), Bool :: ApplyStr(Box :: new(lam_new.clone()), arg.clone())) <--
    bool(t),
    if let Bool :: ApplyStr(ref lam, ref arg) = t,
    rw_bool(lam.as_ref().clone(), lam_new);

rw_bool(Bool :: ApplyStr(lam.clone(), arg.clone()), Bool :: ApplyStr(lam.clone(), Box :: new(arg_new.clone()))) <--
    bool(t),
    if let Bool :: ApplyStr(ref lam, ref arg) = t,
    rw_str(arg.as_ref().clone(), arg_new);

rw_bool(Bool :: MApplyStr(lam.clone(), args.clone()), Bool :: MApplyStr(Box :: new(lam_new.clone()), args.clone())) <--
    bool(t),
    if let Bool :: MApplyStr(ref lam, ref args) = t,
    rw_bool(lam.as_ref().clone(), lam_new);

str(c1.clone()) <--
    str(c0),
    rw_str(c0, c1);

str(field_0.as_ref().clone()),
str(field_1.as_ref().clone()) <--
    str(t),
    if let Str :: AddStr(field_0, field_1) = t;

str(lam.as_ref().clone()),
int(arg.as_ref().clone()) <--
    str(t),
    if let Str :: ApplyInt(lam, arg) = t;

str(lam.as_ref().clone()) <--
    str(t),
    if let Str :: MApplyInt(lam, _) = t;

int(arg.clone()) <--
    str(t),
    if let Str :: MApplyInt(_, args) = t,
    for arg in args.iter();

str((* scope.inner().unsafe_body).clone()) <--
    str(t),
    if let Str :: LamInt(scope) = t;

str((* scope.inner().unsafe_body).clone()) <--
    str(t),
    if let Str :: MLamInt(scope) = t;

str(lam.as_ref().clone()),
float(arg.as_ref().clone()) <--
    str(t),
    if let Str :: ApplyFloat(lam, arg) = t;

str(lam.as_ref().clone()) <--
    str(t),
    if let Str :: MApplyFloat(lam, _) = t;

float(arg.clone()) <--
    str(t),
    if let Str :: MApplyFloat(_, args) = t,
    for arg in args.iter();

str((* scope.inner().unsafe_body).clone()) <--
    str(t),
    if let Str :: LamFloat(scope) = t;

str((* scope.inner().unsafe_body).clone()) <--
    str(t),
    if let Str :: MLamFloat(scope) = t;

str(lam.as_ref().clone()),
bool(arg.as_ref().clone()) <--
    str(t),
    if let Str :: ApplyBool(lam, arg) = t;

str(lam.as_ref().clone()) <--
    str(t),
    if let Str :: MApplyBool(lam, _) = t;

bool(arg.clone()) <--
    str(t),
    if let Str :: MApplyBool(_, args) = t,
    for arg in args.iter();

str((* scope.inner().unsafe_body).clone()) <--
    str(t),
    if let Str :: LamBool(scope) = t;

str((* scope.inner().unsafe_body).clone()) <--
    str(t),
    if let Str :: MLamBool(scope) = t;

str(lam.as_ref().clone()),
str(arg.as_ref().clone()) <--
    str(t),
    if let Str :: ApplyStr(lam, arg) = t;

str(lam.as_ref().clone()) <--
    str(t),
    if let Str :: MApplyStr(lam, _) = t;

str(arg.clone()) <--
    str(t),
    if let Str :: MApplyStr(_, args) = t,
    for arg in args.iter();

str((* scope.inner().unsafe_body).clone()) <--
    str(t),
    if let Str :: LamStr(scope) = t;

str((* scope.inner().unsafe_body).clone()) <--
    str(t),
    if let Str :: MLamStr(scope) = t;

rw_str(Str :: ApplyInt(lam.clone(), arg.clone()), Str :: ApplyInt(Box :: new(lam_new.clone()), arg.clone())) <--
    str(t),
    if let Str :: ApplyInt(ref lam, ref arg) = t,
    rw_str(lam.as_ref().clone(), lam_new);

rw_str(Str :: ApplyInt(lam.clone(), arg.clone()), Str :: ApplyInt(lam.clone(), Box :: new(arg_new.clone()))) <--
    str(t),
    if let Str :: ApplyInt(ref lam, ref arg) = t,
    rw_int(arg.as_ref().clone(), arg_new);

rw_str(Str :: MApplyInt(lam.clone(), args.clone()), Str :: MApplyInt(Box :: new(lam_new.clone()), args.clone())) <--
    str(t),
    if let Str :: MApplyInt(ref lam, ref args) = t,
    rw_str(lam.as_ref().clone(), lam_new);

rw_str(Str :: ApplyFloat(lam.clone(), arg.clone()), Str :: ApplyFloat(Box :: new(lam_new.clone()), arg.clone())) <--
    str(t),
    if let Str :: ApplyFloat(ref lam, ref arg) = t,
    rw_str(lam.as_ref().clone(), lam_new);

rw_str(Str :: ApplyFloat(lam.clone(), arg.clone()), Str :: ApplyFloat(lam.clone(), Box :: new(arg_new.clone()))) <--
    str(t),
    if let Str :: ApplyFloat(ref lam, ref arg) = t,
    rw_float(arg.as_ref().clone(), arg_new);

rw_str(Str :: MApplyFloat(lam.clone(), args.clone()), Str :: MApplyFloat(Box :: new(lam_new.clone()), args.clone())) <--
    str(t),
    if let Str :: MApplyFloat(ref lam, ref args) = t,
    rw_str(lam.as_ref().clone(), lam_new);

rw_str(Str :: ApplyBool(lam.clone(), arg.clone()), Str :: ApplyBool(Box :: new(lam_new.clone()), arg.clone())) <--
    str(t),
    if let Str :: ApplyBool(ref lam, ref arg) = t,
    rw_str(lam.as_ref().clone(), lam_new);

rw_str(Str :: ApplyBool(lam.clone(), arg.clone()), Str :: ApplyBool(lam.clone(), Box :: new(arg_new.clone()))) <--
    str(t),
    if let Str :: ApplyBool(ref lam, ref arg) = t,
    rw_bool(arg.as_ref().clone(), arg_new);

rw_str(Str :: MApplyBool(lam.clone(), args.clone()), Str :: MApplyBool(Box :: new(lam_new.clone()), args.clone())) <--
    str(t),
    if let Str :: MApplyBool(ref lam, ref args) = t,
    rw_str(lam.as_ref().clone(), lam_new);

rw_str(Str :: ApplyStr(lam.clone(), arg.clone()), Str :: ApplyStr(Box :: new(lam_new.clone()), arg.clone())) <--
    str(t),
    if let Str :: ApplyStr(ref lam, ref arg) = t,
    rw_str(lam.as_ref().clone(), lam_new);

rw_str(Str :: ApplyStr(lam.clone(), arg.clone()), Str :: ApplyStr(lam.clone(), Box :: new(arg_new.clone()))) <--
    str(t),
    if let Str :: ApplyStr(ref lam, ref arg) = t,
    rw_str(arg.as_ref().clone(), arg_new);

rw_str(Str :: MApplyStr(lam.clone(), args.clone()), Str :: MApplyStr(Box :: new(lam_new.clone()), args.clone())) <--
    str(t),
    if let Str :: MApplyStr(ref lam, ref args) = t,
    rw_str(lam.as_ref().clone(), lam_new);


    // Equation rules
eq_int(t.clone(), t.clone()) <--
    int(t);

eq_float(t.clone(), t.clone()) <--
    float(t);

eq_bool(t.clone(), t.clone()) <--
    bool(t);

eq_str(t.clone(), t.clone()) <--
    str(t);

eq_bool(s.clone(), t.clone()) <--
    bool(s),
    if let Bool :: Eq(ref s_f0, ref s_f1) = s,
    bool(t),
    if let Bool :: Eq(ref t_f0, ref t_f1) = t,
    eq_int(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_int(s_f1.as_ref().clone(), t_f1.as_ref().clone());

eq_bool(s.clone(), t.clone()) <--
    bool(s),
    if let Bool :: EqFloat(ref s_f0, ref s_f1) = s,
    bool(t),
    if let Bool :: EqFloat(ref t_f0, ref t_f1) = t,
    eq_float(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_float(s_f1.as_ref().clone(), t_f1.as_ref().clone());

eq_bool(s.clone(), t.clone()) <--
    bool(s),
    if let Bool :: EqBool(ref s_f0, ref s_f1) = s,
    bool(t),
    if let Bool :: EqBool(ref t_f0, ref t_f1) = t,
    eq_bool(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_bool(s_f1.as_ref().clone(), t_f1.as_ref().clone());

eq_bool(s.clone(), t.clone()) <--
    bool(s),
    if let Bool :: EqStr(ref s_f0, ref s_f1) = s,
    bool(t),
    if let Bool :: EqStr(ref t_f0, ref t_f1) = t,
    eq_str(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_str(s_f1.as_ref().clone(), t_f1.as_ref().clone());

eq_bool(s.clone(), t.clone()) <--
    bool(s),
    if let Bool :: Not(ref s_f0) = s,
    bool(t),
    if let Bool :: Not(ref t_f0) = t,
    eq_bool(s_f0.as_ref().clone(), t_f0.as_ref().clone());

eq_bool(s.clone(), t.clone()) <--
    bool(s),
    if let Bool :: Comp(ref s_f0, ref s_f1) = s,
    bool(t),
    if let Bool :: Comp(ref t_f0, ref t_f1) = t,
    eq_bool(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_bool(s_f1.as_ref().clone(), t_f1.as_ref().clone());

eq_int(s.clone(), t.clone()) <--
    int(s),
    if let Int :: Len(ref s_f0) = s,
    int(t),
    if let Int :: Len(ref t_f0) = t,
    eq_str(s_f0.as_ref().clone(), t_f0.as_ref().clone());

eq_str(s.clone(), t.clone()) <--
    str(s),
    if let Str :: AddStr(ref s_f0, ref s_f1) = s,
    str(t),
    if let Str :: AddStr(ref t_f0, ref t_f1) = t,
    eq_str(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_str(s_f1.as_ref().clone(), t_f1.as_ref().clone());

eq_int(s.clone(), t.clone()) <--
    int(s),
    if let Int :: AddInt(ref s_f0, ref s_f1) = s,
    int(t),
    if let Int :: AddInt(ref t_f0, ref t_f1) = t,
    eq_int(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_int(s_f1.as_ref().clone(), t_f1.as_ref().clone());

eq_int(s.clone(), t.clone()) <--
    int(s),
    if let Int :: SubInt(ref s_f0, ref s_f1) = s,
    int(t),
    if let Int :: SubInt(ref t_f0, ref t_f1) = t,
    eq_int(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_int(s_f1.as_ref().clone(), t_f1.as_ref().clone());

eq_int(s.clone(), t.clone()) <--
    int(s),
    if let Int :: MulInt(ref s_f0, ref s_f1) = s,
    int(t),
    if let Int :: MulInt(ref t_f0, ref t_f1) = t,
    eq_int(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_int(s_f1.as_ref().clone(), t_f1.as_ref().clone());

eq_int(s.clone(), t.clone()) <--
    int(s),
    if let Int :: DivInt(ref s_f0, ref s_f1) = s,
    int(t),
    if let Int :: DivInt(ref t_f0, ref t_f1) = t,
    eq_int(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_int(s_f1.as_ref().clone(), t_f1.as_ref().clone());

eq_int(s.clone(), t.clone()) <--
    int(s),
    if let Int :: ModInt(ref s_f0, ref s_f1) = s,
    int(t),
    if let Int :: ModInt(ref t_f0, ref t_f1) = t,
    eq_int(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_int(s_f1.as_ref().clone(), t_f1.as_ref().clone());

eq_int(s.clone(), t.clone()) <--
    int(s),
    if let Int :: PowInt(ref s_f0, ref s_f1) = s,
    int(t),
    if let Int :: PowInt(ref t_f0, ref t_f1) = t,
    eq_int(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_int(s_f1.as_ref().clone(), t_f1.as_ref().clone());

eq_float(s.clone(), t.clone()) <--
    float(s),
    if let Float :: AddFloat(ref s_f0, ref s_f1) = s,
    float(t),
    if let Float :: AddFloat(ref t_f0, ref t_f1) = t,
    eq_float(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_float(s_f1.as_ref().clone(), t_f1.as_ref().clone());

eq_float(s.clone(), t.clone()) <--
    float(s),
    if let Float :: SubFloat(ref s_f0, ref s_f1) = s,
    float(t),
    if let Float :: SubFloat(ref t_f0, ref t_f1) = t,
    eq_float(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_float(s_f1.as_ref().clone(), t_f1.as_ref().clone());

eq_float(s.clone(), t.clone()) <--
    float(s),
    if let Float :: ToFloat(ref s_f0) = s,
    float(t),
    if let Float :: ToFloat(ref t_f0) = t,
    eq_int(s_f0.as_ref().clone(), t_f0.as_ref().clone());

eq_int(s.clone(), t.clone()) <--
    int(s),
    if let Int :: ToInt(ref s_f0) = s,
    int(t),
    if let Int :: ToInt(ref t_f0) = t,
    eq_float(s_f0.as_ref().clone(), t_f0.as_ref().clone());

eq_int(s.clone(), t.clone()) <--
    int(s),
    if let Int :: IntId(ref s_f0) = s,
    int(t),
    if let Int :: IntId(ref t_f0) = t,
    eq_int(s_f0.as_ref().clone(), t_f0.as_ref().clone());

eq_float(s.clone(), t.clone()) <--
    float(s),
    if let Float :: FloatId(ref s_f0) = s,
    float(t),
    if let Float :: FloatId(ref t_f0) = t,
    eq_float(s_f0.as_ref().clone(), t_f0.as_ref().clone());

eq_int(s.clone(), t.clone()) <--
    int(s),
    if let Int :: CustomOp(ref s_f0, ref s_f1) = s,
    int(t),
    if let Int :: CustomOp(ref t_f0, ref t_f1) = t,
    eq_int(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_int(s_f1.as_ref().clone(), t_f1.as_ref().clone());


    // Rewrite rules
rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool :: Eq(left, right) = s,
    if let Int :: NumLit(a_ref) = left.as_ref(),
    if let Int :: NumLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool :: BoolLit((a == b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool :: EqFloat(left, right) = s,
    if let Float :: FloatLit(a_ref) = left.as_ref(),
    if let Float :: FloatLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool :: BoolLit((a.get() == b.get()));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool :: EqBool(left, right) = s,
    if let Bool :: BoolLit(a_ref) = left.as_ref(),
    if let Bool :: BoolLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool :: BoolLit((a == b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool :: EqStr(left, right) = s,
    if let Str :: StringLit(a_ref) = left.as_ref(),
    if let Str :: StringLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool :: BoolLit((a == b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool :: Comp(left, right) = s,
    if let Bool :: BoolLit(a_ref) = left.as_ref(),
    if let Bool :: BoolLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool :: BoolLit((a && b));

rw_str(s.clone(), t) <--
    str(s),
    if let Str :: AddStr(left, right) = s,
    if let Str :: StringLit(a_ref) = left.as_ref(),
    if let Str :: StringLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Str :: StringLit(({ let mut x = a.clone();

x.push_str(& b);

x }));

rw_int(s.clone(), t) <--
    int(s),
    if let Int :: PowInt(left, right) = s,
    if let Int :: NumLit(a_ref) = left.as_ref(),
    if let Int :: NumLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Int :: NumLit((a.pow(b as u32)));

rw_bool(orig.clone(), t) <--
    bool(orig),
    if let Bool :: Not(inner) = orig,
    if let Bool :: BoolLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Bool :: BoolLit(({ match a { true => false, false => true, } }));

rw_int(orig.clone(), t) <--
    int(orig),
    if let Int :: Len(inner) = orig,
    if let Str :: StringLit(s_ref) = inner.as_ref(),
    let s = s_ref.clone(),
    let t = Int :: NumLit((s.len() as i32));

rw_float(orig.clone(), t) <--
    float(orig),
    if let Float :: ToFloat(inner) = orig,
    if let Int :: NumLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Float :: FloatLit((mettail_runtime :: CanonicalFloat64 :: from(a as f64)));

rw_int(orig.clone(), t) <--
    int(orig),
    if let Int :: ToInt(inner) = orig,
    if let Float :: FloatLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Int :: NumLit((a.get() as i32));

rw_int(orig.clone(), t) <--
    int(orig),
    if let Int :: IntId(inner) = orig,
    if let Int :: NumLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Int :: NumLit((a));

rw_float(orig.clone(), t) <--
    float(orig),
    if let Float :: FloatId(inner) = orig,
    if let Float :: FloatLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Float :: FloatLit((a));

fold_int(t.clone(), t.clone()) <--
    int(t),
    if let Int :: NumLit(_) = t;

fold_int(s.clone(), res) <--
    int(s),
    if let Int :: AddInt(left, right) = s,
    fold_int(left.as_ref().clone(), lv),
    fold_int(right.as_ref().clone(), rv),
    if let Int :: NumLit(a_ref) = & lv,
    if let Int :: NumLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Int :: NumLit((a + b));

fold_int(s.clone(), res) <--
    int(s),
    if let Int :: SubInt(left, right) = s,
    fold_int(left.as_ref().clone(), lv),
    fold_int(right.as_ref().clone(), rv),
    if let Int :: NumLit(a_ref) = & lv,
    if let Int :: NumLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Int :: NumLit((a - b));

fold_int(s.clone(), res) <--
    int(s),
    if let Int :: MulInt(left, right) = s,
    fold_int(left.as_ref().clone(), lv),
    fold_int(right.as_ref().clone(), rv),
    if let Int :: NumLit(a_ref) = & lv,
    if let Int :: NumLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Int :: NumLit((a * b));

fold_int(s.clone(), res) <--
    int(s),
    if let Int :: DivInt(left, right) = s,
    fold_int(left.as_ref().clone(), lv),
    fold_int(right.as_ref().clone(), rv),
    if let Int :: NumLit(a_ref) = & lv,
    if let Int :: NumLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Int :: NumLit((a / b));

fold_int(s.clone(), res) <--
    int(s),
    if let Int :: ModInt(left, right) = s,
    fold_int(left.as_ref().clone(), lv),
    fold_int(right.as_ref().clone(), rv),
    if let Int :: NumLit(a_ref) = & lv,
    if let Int :: NumLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Int :: NumLit((a % b));

fold_int(s.clone(), res) <--
    int(s),
    if let Int :: PowInt(left, right) = s,
    fold_int(left.as_ref().clone(), lv),
    fold_int(right.as_ref().clone(), rv),
    if let Int :: NumLit(a_ref) = & lv,
    if let Int :: NumLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Int :: NumLit((a.pow(b as u32)));

fold_int(s.clone(), res) <--
    int(s),
    if let Int :: CustomOp(left, right) = s,
    fold_int(left.as_ref().clone(), lv),
    fold_int(right.as_ref().clone(), rv),
    if let Int :: NumLit(a_ref) = & lv,
    if let Int :: NumLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Int :: NumLit((2 * a + 3 * b));

rw_int(s.clone(), t.clone()) <--
    int(s),
    if let Int :: AddInt(_, _) = s,
    fold_int(s, t);

rw_int(s.clone(), t.clone()) <--
    int(s),
    if let Int :: SubInt(_, _) = s,
    fold_int(s, t);

rw_int(s.clone(), t.clone()) <--
    int(s),
    if let Int :: MulInt(_, _) = s,
    fold_int(s, t);

rw_int(s.clone(), t.clone()) <--
    int(s),
    if let Int :: DivInt(_, _) = s,
    fold_int(s, t);

rw_int(s.clone(), t.clone()) <--
    int(s),
    if let Int :: ModInt(_, _) = s,
    fold_int(s, t);

rw_int(s.clone(), t.clone()) <--
    int(s),
    if let Int :: CustomOp(_, _) = s,
    fold_int(s, t);

fold_float(t.clone(), t.clone()) <--
    float(t),
    if let Float :: FloatLit(_) = t;

fold_float(s.clone(), res) <--
    float(s),
    if let Float :: AddFloat(left, right) = s,
    fold_float(left.as_ref().clone(), lv),
    fold_float(right.as_ref().clone(), rv),
    if let Float :: FloatLit(a_ref) = & lv,
    if let Float :: FloatLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Float :: FloatLit((a + b));

fold_float(s.clone(), res) <--
    float(s),
    if let Float :: SubFloat(left, right) = s,
    fold_float(left.as_ref().clone(), lv),
    fold_float(right.as_ref().clone(), rv),
    if let Float :: FloatLit(a_ref) = & lv,
    if let Float :: FloatLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Float :: FloatLit((a - b));

rw_float(s.clone(), t.clone()) <--
    float(s),
    if let Float :: AddFloat(_, _) = s,
    fold_float(s, t);

rw_float(s.clone(), t.clone()) <--
    float(s),
    if let Float :: SubFloat(_, _) = s,
    fold_float(s, t);

rw_str(lhs.clone(), rhs) <--
    str(lhs),
    if let Str :: AddStr(ref x0, ref x1) = lhs,
    rw_str((* * x0).clone(), t),
    let rhs = Str :: AddStr(Box :: new(t.clone()), x1.clone());

rw_str(lhs.clone(), rhs) <--
    str(lhs),
    if let Str :: AddStr(ref x0, ref x1) = lhs,
    rw_str((* * x1).clone(), t),
    let rhs = Str :: AddStr(x0.clone(), Box :: new(t.clone()));

rw_bool(lhs.clone(), rhs) <--
    bool(lhs),
    if let Bool :: Comp(ref x0, ref x1) = lhs,
    rw_bool((* * x0).clone(), t),
    let rhs = Bool :: Comp(Box :: new(t.clone()), x1.clone());

rw_bool(lhs.clone(), rhs) <--
    bool(lhs),
    if let Bool :: Comp(ref x0, ref x1) = lhs,
    rw_bool((* * x1).clone(), t),
    let rhs = Bool :: Comp(x0.clone(), Box :: new(t.clone()));

rw_bool(lhs.clone(), rhs) <--
    bool(lhs),
    if let Bool :: Not(ref x0) = lhs,
    rw_bool((* * x0).clone(), t),
    let rhs = Bool :: Not(Box :: new(t.clone()));

rw_bool(lhs.clone(), rhs) <--
    bool(lhs),
    if let Bool :: Eq(ref x0, ref x1) = lhs,
    rw_int((* * x0).clone(), t),
    let rhs = Bool :: Eq(Box :: new(t.clone()), x1.clone());

rw_bool(lhs.clone(), rhs) <--
    bool(lhs),
    if let Bool :: Eq(ref x0, ref x1) = lhs,
    rw_int((* * x1).clone(), t),
    let rhs = Bool :: Eq(x0.clone(), Box :: new(t.clone()));

rw_bool(lhs.clone(), rhs) <--
    bool(lhs),
    if let Bool :: EqFloat(ref x0, ref x1) = lhs,
    rw_float((* * x0).clone(), t),
    let rhs = Bool :: EqFloat(Box :: new(t.clone()), x1.clone());

rw_bool(lhs.clone(), rhs) <--
    bool(lhs),
    if let Bool :: EqFloat(ref x0, ref x1) = lhs,
    rw_float((* * x1).clone(), t),
    let rhs = Bool :: EqFloat(x0.clone(), Box :: new(t.clone()));

rw_bool(lhs.clone(), rhs) <--
    bool(lhs),
    if let Bool :: EqBool(ref x0, ref x1) = lhs,
    rw_bool((* * x0).clone(), t),
    let rhs = Bool :: EqBool(Box :: new(t.clone()), x1.clone());

rw_bool(lhs.clone(), rhs) <--
    bool(lhs),
    if let Bool :: EqBool(ref x0, ref x1) = lhs,
    rw_bool((* * x1).clone(), t),
    let rhs = Bool :: EqBool(x0.clone(), Box :: new(t.clone()));

rw_bool(lhs.clone(), rhs) <--
    bool(lhs),
    if let Bool :: EqStr(ref x0, ref x1) = lhs,
    rw_str((* * x0).clone(), t),
    let rhs = Bool :: EqStr(Box :: new(t.clone()), x1.clone());

rw_bool(lhs.clone(), rhs) <--
    bool(lhs),
    if let Bool :: EqStr(ref x0, ref x1) = lhs,
    rw_str((* * x1).clone(), t),
    let rhs = Bool :: EqStr(x0.clone(), Box :: new(t.clone()));

rw_int(lhs.clone(), rhs) <--
    int(lhs),
    if let Int :: AddInt(ref x0, ref x1) = lhs,
    rw_int((* * x0).clone(), t),
    let rhs = Int :: AddInt(Box :: new(t.clone()), x1.clone());

rw_int(lhs.clone(), rhs) <--
    int(lhs),
    if let Int :: AddInt(ref x0, ref x1) = lhs,
    rw_int((* * x1).clone(), t),
    let rhs = Int :: AddInt(x0.clone(), Box :: new(t.clone()));

rw_int(lhs.clone(), rhs) <--
    int(lhs),
    if let Int :: SubInt(ref x0, ref x1) = lhs,
    rw_int((* * x0).clone(), t),
    let rhs = Int :: SubInt(Box :: new(t.clone()), x1.clone());

rw_int(lhs.clone(), rhs) <--
    int(lhs),
    if let Int :: SubInt(ref x0, ref x1) = lhs,
    rw_int((* * x1).clone(), t),
    let rhs = Int :: SubInt(x0.clone(), Box :: new(t.clone()));

rw_int(lhs.clone(), rhs) <--
    int(lhs),
    if let Int :: MulInt(ref x0, ref x1) = lhs,
    rw_int((* * x0).clone(), t),
    let rhs = Int :: MulInt(Box :: new(t.clone()), x1.clone());

rw_int(lhs.clone(), rhs) <--
    int(lhs),
    if let Int :: MulInt(ref x0, ref x1) = lhs,
    rw_int((* * x1).clone(), t),
    let rhs = Int :: MulInt(x0.clone(), Box :: new(t.clone()));

rw_int(lhs.clone(), rhs) <--
    int(lhs),
    if let Int :: DivInt(ref x0, ref x1) = lhs,
    rw_int((* * x0).clone(), t),
    let rhs = Int :: DivInt(Box :: new(t.clone()), x1.clone());

rw_int(lhs.clone(), rhs) <--
    int(lhs),
    if let Int :: DivInt(ref x0, ref x1) = lhs,
    rw_int((* * x1).clone(), t),
    let rhs = Int :: DivInt(x0.clone(), Box :: new(t.clone()));

rw_int(lhs.clone(), rhs) <--
    int(lhs),
    if let Int :: ModInt(ref x0, ref x1) = lhs,
    rw_int((* * x0).clone(), t),
    let rhs = Int :: ModInt(Box :: new(t.clone()), x1.clone());

rw_int(lhs.clone(), rhs) <--
    int(lhs),
    if let Int :: ModInt(ref x0, ref x1) = lhs,
    rw_int((* * x1).clone(), t),
    let rhs = Int :: ModInt(x0.clone(), Box :: new(t.clone()));

rw_int(lhs.clone(), rhs) <--
    int(lhs),
    if let Int :: PowInt(ref x0, ref x1) = lhs,
    rw_int((* * x0).clone(), t),
    let rhs = Int :: PowInt(Box :: new(t.clone()), x1.clone());

rw_float(lhs.clone(), rhs) <--
    float(lhs),
    if let Float :: AddFloat(ref x0, ref x1) = lhs,
    rw_float((* * x0).clone(), t),
    let rhs = Float :: AddFloat(Box :: new(t.clone()), x1.clone());

rw_float(lhs.clone(), rhs) <--
    float(lhs),
    if let Float :: AddFloat(ref x0, ref x1) = lhs,
    rw_float((* * x1).clone(), t),
    let rhs = Float :: AddFloat(x0.clone(), Box :: new(t.clone()));

rw_float(lhs.clone(), rhs) <--
    float(lhs),
    if let Float :: SubFloat(ref x0, ref x1) = lhs,
    rw_float((* * x0).clone(), t),
    let rhs = Float :: SubFloat(Box :: new(t.clone()), x1.clone());

rw_float(lhs.clone(), rhs) <--
    float(lhs),
    if let Float :: SubFloat(ref x0, ref x1) = lhs,
    rw_float((* * x1).clone(), t),
    let rhs = Float :: SubFloat(x0.clone(), Box :: new(t.clone()));

rw_float(lhs.clone(), rhs) <--
    float(lhs),
    if let Float :: ToFloat(ref x0) = lhs,
    rw_int((* * x0).clone(), t),
    let rhs = Float :: ToFloat(Box :: new(t.clone()));

rw_int(lhs.clone(), rhs) <--
    int(lhs),
    if let Int :: ToInt(ref x0) = lhs,
    rw_float((* * x0).clone(), t),
    let rhs = Int :: ToInt(Box :: new(t.clone()));

rw_int(lhs.clone(), rhs) <--
    int(lhs),
    if let Int :: IntId(ref x0) = lhs,
    rw_int((* * x0).clone(), t),
    let rhs = Int :: IntId(Box :: new(t.clone()));

rw_float(lhs.clone(), rhs) <--
    float(lhs),
    if let Float :: FloatId(ref x0) = lhs,
    rw_float((* * x0).clone(), t),
    let rhs = Float :: FloatId(Box :: new(t.clone()));

}

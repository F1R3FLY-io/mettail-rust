// Generated Ascent Datalog for calculator theory
// This file is generated by the theory! macro and is for inspection only.
// Do not edit manually - changes will be overwritten.

ascent_source! {
    calculator_source:

    // Relations
relation int(Int);

#[ds(crate :: eqrel)] relation eq_int(Int, Int);

relation rw_int(Int, Int);

relation fold_int(Int, Int);


    // Category rules
int(c1) <--
    int(c0),
    rw_int(c0, c1);

int(field_0.as_ref().clone()),
int(field_1.as_ref().clone()) <--
    int(t),
    if let Int :: Add(field_0, field_1) = t;

int(field_0.as_ref().clone()),
int(field_1.as_ref().clone()) <--
    int(t),
    if let Int :: Sub(field_0, field_1) = t;

int(field_0.as_ref().clone()),
int(field_1.as_ref().clone()) <--
    int(t),
    if let Int :: Up(field_0, field_1) = t;


    // Equation rules
eq_int(t.clone(), t.clone()) <--
    int(t);

eq_int(s.clone(), t.clone()) <--
    int(s),
    if let Int :: Add(ref s_f0, ref s_f1) = s,
    int(t),
    if let Int :: Add(ref t_f0, ref t_f1) = t,
    eq_int(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_int(s_f1.as_ref().clone(), t_f1.as_ref().clone());

eq_int(s.clone(), t.clone()) <--
    int(s),
    if let Int :: Sub(ref s_f0, ref s_f1) = s,
    int(t),
    if let Int :: Sub(ref t_f0, ref t_f1) = t,
    eq_int(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_int(s_f1.as_ref().clone(), t_f1.as_ref().clone());

eq_int(s.clone(), t.clone()) <--
    int(s),
    if let Int :: Up(ref s_f0, ref s_f1) = s,
    int(t),
    if let Int :: Up(ref t_f0, ref t_f1) = t,
    eq_int(s_f0.as_ref().clone(), t_f0.as_ref().clone()),
    eq_int(s_f1.as_ref().clone(), t_f1.as_ref().clone());


    // Rewrite rules
rw_int(s, t) <--
    int(s),
    if let Int :: Add(left, right) = s,
    if let Int :: NumLit(a) = left.as_ref(),
    if let Int :: NumLit(b) = right.as_ref(),
    let t = Int :: NumLit((a + b));

fold_int(t.clone(), t.clone()) <--
    int(t),
    if let Int :: NumLit(_) = t;

fold_int(s, res) <--
    int(s),
    if let Int :: Add(left, right) = s,
    fold_int(left.as_ref().clone(), lv),
    fold_int(right.as_ref().clone(), rv),
    if let Int :: NumLit(a) = & lv,
    if let Int :: NumLit(b) = & rv,
    let res = Int :: NumLit((a + b));

fold_int(s, res) <--
    int(s),
    if let Int :: Sub(left, right) = s,
    fold_int(left.as_ref().clone(), lv),
    fold_int(right.as_ref().clone(), rv),
    if let Int :: NumLit(a) = & lv,
    if let Int :: NumLit(b) = & rv,
    let res = Int :: NumLit((a - b));

fold_int(s, res) <--
    int(s),
    if let Int :: Up(left, right) = s,
    fold_int(left.as_ref().clone(), lv),
    fold_int(right.as_ref().clone(), rv),
    if let Int :: NumLit(a) = & lv,
    if let Int :: NumLit(b) = & rv,
    let res = Int :: NumLit((2 * a + 3 * b));

rw_int(s, t) <--
    int(s),
    if let Int :: Sub(_, _) = s,
    fold_int(s, t);

rw_int(s, t) <--
    int(s),
    if let Int :: Up(_, _) = s,
    fold_int(s, t);

rw_int(lhs, rhs) <--
    int(lhs),
    if let Int :: Add(ref x0, ref x1) = lhs,
    rw_int((* * x0).clone(), t),
    let rhs = Int :: Add(Box :: new(t.clone()), x1.clone());

rw_int(lhs, rhs) <--
    int(lhs),
    if let Int :: Add(ref x0, ref x1) = lhs,
    rw_int((* * x1).clone(), t),
    let rhs = Int :: Add(x0.clone(), Box :: new(t.clone()));

rw_int(lhs, rhs) <--
    int(lhs),
    if let Int :: Sub(ref x0, ref x1) = lhs,
    rw_int((* * x0).clone(), t),
    let rhs = Int :: Sub(Box :: new(t.clone()), x1.clone());

rw_int(lhs, rhs) <--
    int(lhs),
    if let Int :: Sub(ref x0, ref x1) = lhs,
    rw_int((* * x1).clone(), t),
    let rhs = Int :: Sub(x0.clone(), Box :: new(t.clone()));

}

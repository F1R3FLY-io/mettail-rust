// Generated Ascent Datalog for calculator theory
// This file is generated by the theory! macro and is for inspection only.
// Do not edit manually - changes will be overwritten.

ascent_source! {
    calculator_source:

    // Relations
relation int(Int);

#[ds(crate::eqrel)] relation eq_int(Int, Int);

relation rw_int(Int, Int);

relation fold_int(Int, Int);

relation bool(Bool);

#[ds(crate::eqrel)] relation eq_bool(Bool, Bool);

relation rw_bool(Bool, Bool);

relation str(Str);

#[ds(crate::eqrel)] relation eq_str(Str, Str);

relation rw_str(Str, Str);

relation step_term(Int);


    // Category rules
int(sub.clone()) <--
    int(t),
    for sub in (match t {
        Int::Tern(f0, f1, f2) => vec![f0.as_ref().clone(), f1.as_ref().clone(), f2.as_ref().clone()],
        Int::Pow(f0, f1) => vec![f0.as_ref().clone(), f1.as_ref().clone()],
        Int::Add(f0, f1) => vec![f0.as_ref().clone(), f1.as_ref().clone()],
        Int::Neg(f0) => vec![f0.as_ref().clone()],
        Int::Sub(f0, f1) => vec![f0.as_ref().clone(), f1.as_ref().clone()],
        Int::CustomOp(f0, f1) => vec![f0.as_ref().clone(), f1.as_ref().clone()],
        Int::Fact(f0) => vec![f0.as_ref().clone()],
        Int::ApplyInt(lam, arg) => vec![lam.as_ref().clone(), arg.as_ref().clone()],
        Int::MApplyInt(lam, args) => {
            let mut v = Vec::with_capacity(1 + args.len());
            v.push(lam.as_ref().clone());
            v.extend(args.iter().cloned());
            v
        },
        Int::LamInt(scope) => vec![scope.inner().unsafe_body.as_ref().clone()],
        Int::MLamInt(scope) => vec![scope.inner().unsafe_body.as_ref().clone()],
        Int::ApplyBool(lam, _) => vec![lam.as_ref().clone()],
        Int::MApplyBool(lam, _) => vec![lam.as_ref().clone()],
        Int::LamBool(scope) => vec![scope.inner().unsafe_body.as_ref().clone()],
        Int::MLamBool(scope) => vec![scope.inner().unsafe_body.as_ref().clone()],
        Int::ApplyStr(lam, _) => vec![lam.as_ref().clone()],
        Int::MApplyStr(lam, _) => vec![lam.as_ref().clone()],
        Int::LamStr(scope) => vec![scope.inner().unsafe_body.as_ref().clone()],
        Int::MLamStr(scope) => vec![scope.inner().unsafe_body.as_ref().clone()],
        _ => vec![],
    }).into_iter();

bool(sub.clone()) <--
    int(t),
    for sub in (match t {
        Int::ApplyBool(_, arg) => vec![arg.as_ref().clone()],
        Int::MApplyBool(_, args) => args.iter().cloned().collect(),
        _ => vec![],
    }).into_iter();

str(sub.clone()) <--
    int(t),
    for sub in (match t {
        Int::Len(f0) => vec![f0.as_ref().clone()],
        Int::ApplyStr(_, arg) => vec![arg.as_ref().clone()],
        Int::MApplyStr(_, args) => args.iter().cloned().collect(),
        _ => vec![],
    }).into_iter();

int(sub.clone()) <--
    bool(t),
    for sub in (match t {
        Bool::Eq(f0, f1) => vec![f0.as_ref().clone(), f1.as_ref().clone()],
        Bool::ApplyInt(_, arg) => vec![arg.as_ref().clone()],
        Bool::MApplyInt(_, args) => args.iter().cloned().collect(),
        _ => vec![],
    }).into_iter();

bool(sub.clone()) <--
    bool(t),
    for sub in (match t {
        Bool::EqBool(f0, f1) => vec![f0.as_ref().clone(), f1.as_ref().clone()],
        Bool::Not(f0) => vec![f0.as_ref().clone()],
        Bool::Comp(f0, f1) => vec![f0.as_ref().clone(), f1.as_ref().clone()],
        Bool::ApplyInt(lam, _) => vec![lam.as_ref().clone()],
        Bool::MApplyInt(lam, _) => vec![lam.as_ref().clone()],
        Bool::LamInt(scope) => vec![scope.inner().unsafe_body.as_ref().clone()],
        Bool::MLamInt(scope) => vec![scope.inner().unsafe_body.as_ref().clone()],
        Bool::ApplyBool(lam, arg) => vec![lam.as_ref().clone(), arg.as_ref().clone()],
        Bool::MApplyBool(lam, args) => {
            let mut v = Vec::with_capacity(1 + args.len());
            v.push(lam.as_ref().clone());
            v.extend(args.iter().cloned());
            v
        },
        Bool::LamBool(scope) => vec![scope.inner().unsafe_body.as_ref().clone()],
        Bool::MLamBool(scope) => vec![scope.inner().unsafe_body.as_ref().clone()],
        Bool::ApplyStr(lam, _) => vec![lam.as_ref().clone()],
        Bool::MApplyStr(lam, _) => vec![lam.as_ref().clone()],
        Bool::LamStr(scope) => vec![scope.inner().unsafe_body.as_ref().clone()],
        Bool::MLamStr(scope) => vec![scope.inner().unsafe_body.as_ref().clone()],
        _ => vec![],
    }).into_iter();

str(sub.clone()) <--
    bool(t),
    for sub in (match t {
        Bool::EqStr(f0, f1) => vec![f0.as_ref().clone(), f1.as_ref().clone()],
        Bool::ApplyStr(_, arg) => vec![arg.as_ref().clone()],
        Bool::MApplyStr(_, args) => args.iter().cloned().collect(),
        _ => vec![],
    }).into_iter();

int(sub.clone()) <--
    str(t),
    for sub in (match t {
        Str::ApplyInt(_, arg) => vec![arg.as_ref().clone()],
        Str::MApplyInt(_, args) => args.iter().cloned().collect(),
        _ => vec![],
    }).into_iter();

bool(sub.clone()) <--
    str(t),
    for sub in (match t {
        Str::ApplyBool(_, arg) => vec![arg.as_ref().clone()],
        Str::MApplyBool(_, args) => args.iter().cloned().collect(),
        _ => vec![],
    }).into_iter();

str(sub.clone()) <--
    str(t),
    for sub in (match t {
        Str::Concat(f0, f1) => vec![f0.as_ref().clone(), f1.as_ref().clone()],
        Str::AddStr(f0, f1) => vec![f0.as_ref().clone(), f1.as_ref().clone()],
        Str::ApplyInt(lam, _) => vec![lam.as_ref().clone()],
        Str::MApplyInt(lam, _) => vec![lam.as_ref().clone()],
        Str::LamInt(scope) => vec![scope.inner().unsafe_body.as_ref().clone()],
        Str::MLamInt(scope) => vec![scope.inner().unsafe_body.as_ref().clone()],
        Str::ApplyBool(lam, _) => vec![lam.as_ref().clone()],
        Str::MApplyBool(lam, _) => vec![lam.as_ref().clone()],
        Str::LamBool(scope) => vec![scope.inner().unsafe_body.as_ref().clone()],
        Str::MLamBool(scope) => vec![scope.inner().unsafe_body.as_ref().clone()],
        Str::ApplyStr(lam, arg) => vec![lam.as_ref().clone(), arg.as_ref().clone()],
        Str::MApplyStr(lam, args) => {
            let mut v = Vec::with_capacity(1 + args.len());
            v.push(lam.as_ref().clone());
            v.extend(args.iter().cloned());
            v
        },
        Str::LamStr(scope) => vec![scope.inner().unsafe_body.as_ref().clone()],
        Str::MLamStr(scope) => vec![scope.inner().unsafe_body.as_ref().clone()],
        _ => vec![],
    }).into_iter();

int(c1.clone()) <--
    int(c0),
    rw_int(c0, c1);

rw_int(t.clone(), match t {
    Int::ApplyInt(_, arg) => Int::ApplyInt(Box::new(new_lam.clone()), arg.clone()),
    Int::MApplyInt(_, args) => Int::MApplyInt(Box::new(new_lam.clone()), args.clone()),
    Int::ApplyBool(_, arg) => Int::ApplyBool(Box::new(new_lam.clone()), arg.clone()),
    Int::MApplyBool(_, args) => Int::MApplyBool(Box::new(new_lam.clone()), args.clone()),
    Int::ApplyStr(_, arg) => Int::ApplyStr(Box::new(new_lam.clone()), arg.clone()),
    Int::MApplyStr(_, args) => Int::MApplyStr(Box::new(new_lam.clone()), args.clone()),
    _ => unreachable!(),
}) <--
    int(t),
    for lam in (match t {
        Int::ApplyInt(lam, _) => vec![lam.as_ref().clone()],
        Int::MApplyInt(lam, _) => vec![lam.as_ref().clone()],
        Int::ApplyBool(lam, _) => vec![lam.as_ref().clone()],
        Int::MApplyBool(lam, _) => vec![lam.as_ref().clone()],
        Int::ApplyStr(lam, _) => vec![lam.as_ref().clone()],
        Int::MApplyStr(lam, _) => vec![lam.as_ref().clone()],
        _ => vec![],
    }).into_iter(),
    rw_int(lam, new_lam);

rw_int(t.clone(), match t {
    Int::ApplyInt(lam, _) => Int::ApplyInt(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
}) <--
    int(t),
    for arg in (match t {
        Int::ApplyInt(_, arg) => vec![arg.as_ref().clone()],
        _ => vec![],
    }).into_iter(),
    rw_int(arg, new_arg);

rw_int(t.clone(), match t {
    Int::ApplyBool(lam, _) => Int::ApplyBool(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
}) <--
    int(t),
    for arg in (match t {
        Int::ApplyBool(_, arg) => vec![arg.as_ref().clone()],
        _ => vec![],
    }).into_iter(),
    rw_bool(arg, new_arg);

rw_int(t.clone(), match t {
    Int::ApplyStr(lam, _) => Int::ApplyStr(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
}) <--
    int(t),
    for arg in (match t {
        Int::ApplyStr(_, arg) => vec![arg.as_ref().clone()],
        _ => vec![],
    }).into_iter(),
    rw_str(arg, new_arg);

bool(c1.clone()) <--
    bool(c0),
    rw_bool(c0, c1);

rw_bool(t.clone(), match t {
    Bool::ApplyInt(_, arg) => Bool::ApplyInt(Box::new(new_lam.clone()), arg.clone()),
    Bool::MApplyInt(_, args) => Bool::MApplyInt(Box::new(new_lam.clone()), args.clone()),
    Bool::ApplyBool(_, arg) => Bool::ApplyBool(Box::new(new_lam.clone()), arg.clone()),
    Bool::MApplyBool(_, args) => Bool::MApplyBool(Box::new(new_lam.clone()), args.clone()),
    Bool::ApplyStr(_, arg) => Bool::ApplyStr(Box::new(new_lam.clone()), arg.clone()),
    Bool::MApplyStr(_, args) => Bool::MApplyStr(Box::new(new_lam.clone()), args.clone()),
    _ => unreachable!(),
}) <--
    bool(t),
    for lam in (match t {
        Bool::ApplyInt(lam, _) => vec![lam.as_ref().clone()],
        Bool::MApplyInt(lam, _) => vec![lam.as_ref().clone()],
        Bool::ApplyBool(lam, _) => vec![lam.as_ref().clone()],
        Bool::MApplyBool(lam, _) => vec![lam.as_ref().clone()],
        Bool::ApplyStr(lam, _) => vec![lam.as_ref().clone()],
        Bool::MApplyStr(lam, _) => vec![lam.as_ref().clone()],
        _ => vec![],
    }).into_iter(),
    rw_bool(lam, new_lam);

rw_bool(t.clone(), match t {
    Bool::ApplyInt(lam, _) => Bool::ApplyInt(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
}) <--
    bool(t),
    for arg in (match t {
        Bool::ApplyInt(_, arg) => vec![arg.as_ref().clone()],
        _ => vec![],
    }).into_iter(),
    rw_int(arg, new_arg);

rw_bool(t.clone(), match t {
    Bool::ApplyBool(lam, _) => Bool::ApplyBool(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
}) <--
    bool(t),
    for arg in (match t {
        Bool::ApplyBool(_, arg) => vec![arg.as_ref().clone()],
        _ => vec![],
    }).into_iter(),
    rw_bool(arg, new_arg);

rw_bool(t.clone(), match t {
    Bool::ApplyStr(lam, _) => Bool::ApplyStr(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
}) <--
    bool(t),
    for arg in (match t {
        Bool::ApplyStr(_, arg) => vec![arg.as_ref().clone()],
        _ => vec![],
    }).into_iter(),
    rw_str(arg, new_arg);

str(c1.clone()) <--
    str(c0),
    rw_str(c0, c1);

rw_str(t.clone(), match t {
    Str::ApplyInt(_, arg) => Str::ApplyInt(Box::new(new_lam.clone()), arg.clone()),
    Str::MApplyInt(_, args) => Str::MApplyInt(Box::new(new_lam.clone()), args.clone()),
    Str::ApplyBool(_, arg) => Str::ApplyBool(Box::new(new_lam.clone()), arg.clone()),
    Str::MApplyBool(_, args) => Str::MApplyBool(Box::new(new_lam.clone()), args.clone()),
    Str::ApplyStr(_, arg) => Str::ApplyStr(Box::new(new_lam.clone()), arg.clone()),
    Str::MApplyStr(_, args) => Str::MApplyStr(Box::new(new_lam.clone()), args.clone()),
    _ => unreachable!(),
}) <--
    str(t),
    for lam in (match t {
        Str::ApplyInt(lam, _) => vec![lam.as_ref().clone()],
        Str::MApplyInt(lam, _) => vec![lam.as_ref().clone()],
        Str::ApplyBool(lam, _) => vec![lam.as_ref().clone()],
        Str::MApplyBool(lam, _) => vec![lam.as_ref().clone()],
        Str::ApplyStr(lam, _) => vec![lam.as_ref().clone()],
        Str::MApplyStr(lam, _) => vec![lam.as_ref().clone()],
        _ => vec![],
    }).into_iter(),
    rw_str(lam, new_lam);

rw_str(t.clone(), match t {
    Str::ApplyInt(lam, _) => Str::ApplyInt(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
}) <--
    str(t),
    for arg in (match t {
        Str::ApplyInt(_, arg) => vec![arg.as_ref().clone()],
        _ => vec![],
    }).into_iter(),
    rw_int(arg, new_arg);

rw_str(t.clone(), match t {
    Str::ApplyBool(lam, _) => Str::ApplyBool(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
}) <--
    str(t),
    for arg in (match t {
        Str::ApplyBool(_, arg) => vec![arg.as_ref().clone()],
        _ => vec![],
    }).into_iter(),
    rw_bool(arg, new_arg);

rw_str(t.clone(), match t {
    Str::ApplyStr(lam, _) => Str::ApplyStr(lam.clone(), Box::new(new_arg.clone())),
    _ => unreachable!(),
}) <--
    str(t),
    for arg in (match t {
        Str::ApplyStr(_, arg) => vec![arg.as_ref().clone()],
        _ => vec![],
    }).into_iter(),
    rw_str(arg, new_arg);


    // Equation rules
eq_int(t.clone(), t.clone()) <--
    int(t);

eq_bool(t.clone(), t.clone()) <--
    bool(t);

eq_str(t.clone(), t.clone()) <--
    str(t);

eq_bool(s.clone(), t.clone()) <--
    bool(s),
    bool(t),
    for (s_f0, t_f0) in (match (s, t) {
        (Bool::Not(sf0), Bool::Not(tf0)) => vec![(sf0.as_ref().clone(), tf0.as_ref().clone())],
        _ => vec![],
    }).into_iter(),
    eq_bool(s_f0, t_f0);

eq_bool(s.clone(), t.clone()) <--
    bool(s),
    bool(t),
    for (s_f0, s_f1, t_f0, t_f1) in (match (s, t) {
        (Bool::EqBool(sf0, sf1), Bool::EqBool(tf0, tf1)) => vec![(sf0.as_ref().clone(), sf1.as_ref().clone(), tf0.as_ref().clone(), tf1.as_ref().clone())],
        (Bool::Comp(sf0, sf1), Bool::Comp(tf0, tf1)) => vec![(sf0.as_ref().clone(), sf1.as_ref().clone(), tf0.as_ref().clone(), tf1.as_ref().clone())],
        _ => vec![],
    }).into_iter(),
    eq_bool(s_f0, t_f0),
    eq_bool(s_f1, t_f1);

eq_bool(s.clone(), t.clone()) <--
    bool(s),
    bool(t),
    for (s_f0, s_f1, t_f0, t_f1) in (match (s, t) {
        (Bool::Eq(sf0, sf1), Bool::Eq(tf0, tf1)) => vec![(sf0.as_ref().clone(), sf1.as_ref().clone(), tf0.as_ref().clone(), tf1.as_ref().clone())],
        _ => vec![],
    }).into_iter(),
    eq_int(s_f0, t_f0),
    eq_int(s_f1, t_f1);

eq_bool(s.clone(), t.clone()) <--
    bool(s),
    bool(t),
    for (s_f0, s_f1, t_f0, t_f1) in (match (s, t) {
        (Bool::EqStr(sf0, sf1), Bool::EqStr(tf0, tf1)) => vec![(sf0.as_ref().clone(), sf1.as_ref().clone(), tf0.as_ref().clone(), tf1.as_ref().clone())],
        _ => vec![],
    }).into_iter(),
    eq_str(s_f0, t_f0),
    eq_str(s_f1, t_f1);

eq_int(s.clone(), t.clone()) <--
    int(s),
    int(t),
    for (s_f0, t_f0) in (match (s, t) {
        (Int::Neg(sf0), Int::Neg(tf0)) => vec![(sf0.as_ref().clone(), tf0.as_ref().clone())],
        (Int::Fact(sf0), Int::Fact(tf0)) => vec![(sf0.as_ref().clone(), tf0.as_ref().clone())],
        _ => vec![],
    }).into_iter(),
    eq_int(s_f0, t_f0);

eq_int(s.clone(), t.clone()) <--
    int(s),
    int(t),
    for (s_f0, s_f1, t_f0, t_f1) in (match (s, t) {
        (Int::Pow(sf0, sf1), Int::Pow(tf0, tf1)) => vec![(sf0.as_ref().clone(), sf1.as_ref().clone(), tf0.as_ref().clone(), tf1.as_ref().clone())],
        (Int::Add(sf0, sf1), Int::Add(tf0, tf1)) => vec![(sf0.as_ref().clone(), sf1.as_ref().clone(), tf0.as_ref().clone(), tf1.as_ref().clone())],
        (Int::Sub(sf0, sf1), Int::Sub(tf0, tf1)) => vec![(sf0.as_ref().clone(), sf1.as_ref().clone(), tf0.as_ref().clone(), tf1.as_ref().clone())],
        (Int::CustomOp(sf0, sf1), Int::CustomOp(tf0, tf1)) => vec![(sf0.as_ref().clone(), sf1.as_ref().clone(), tf0.as_ref().clone(), tf1.as_ref().clone())],
        _ => vec![],
    }).into_iter(),
    eq_int(s_f0, t_f0),
    eq_int(s_f1, t_f1);

eq_int(s.clone(), t.clone()) <--
    int(s),
    int(t),
    for (s_f0, s_f1, s_f2, t_f0, t_f1, t_f2) in (match (s, t) {
        (Int::Tern(sf0, sf1, sf2), Int::Tern(tf0, tf1, tf2)) => vec![(sf0.as_ref().clone(), sf1.as_ref().clone(), sf2.as_ref().clone(), tf0.as_ref().clone(), tf1.as_ref().clone(), tf2.as_ref().clone())],
        _ => vec![],
    }).into_iter(),
    eq_int(s_f0, t_f0),
    eq_int(s_f1, t_f1),
    eq_int(s_f2, t_f2);

eq_int(s.clone(), t.clone()) <--
    int(s),
    int(t),
    for (s_f0, t_f0) in (match (s, t) {
        (Int::Len(sf0), Int::Len(tf0)) => vec![(sf0.as_ref().clone(), tf0.as_ref().clone())],
        _ => vec![],
    }).into_iter(),
    eq_str(s_f0, t_f0);

eq_str(s.clone(), t.clone()) <--
    str(s),
    str(t),
    for (s_f0, s_f1, t_f0, t_f1) in (match (s, t) {
        (Str::Concat(sf0, sf1), Str::Concat(tf0, tf1)) => vec![(sf0.as_ref().clone(), sf1.as_ref().clone(), tf0.as_ref().clone(), tf1.as_ref().clone())],
        (Str::AddStr(sf0, sf1), Str::AddStr(tf0, tf1)) => vec![(sf0.as_ref().clone(), sf1.as_ref().clone(), tf0.as_ref().clone(), tf1.as_ref().clone())],
        _ => vec![],
    }).into_iter(),
    eq_str(s_f0, t_f0),
    eq_str(s_f1, t_f1);


    // Rewrite rules
rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::Eq(left, right) = s,
    if let Int::NumLit(a_ref) = left.as_ref(),
    if let Int::NumLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a == b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::EqBool(left, right) = s,
    if let Bool::BoolLit(a_ref) = left.as_ref(),
    if let Bool::BoolLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a == b));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::EqStr(left, right) = s,
    if let Str::StringLit(a_ref) = left.as_ref(),
    if let Str::StringLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a == b));

rw_int(s.clone(), t) <--
    int(s),
    if let Int::Pow(left, right) = s,
    if let Int::NumLit(a_ref) = left.as_ref(),
    if let Int::NumLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Int::NumLit((a.pow(b as u32)));

rw_bool(s.clone(), t) <--
    bool(s),
    if let Bool::Comp(left, right) = s,
    if let Bool::BoolLit(a_ref) = left.as_ref(),
    if let Bool::BoolLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Bool::BoolLit((a && b));

rw_str(s.clone(), t) <--
    str(s),
    if let Str::Concat(left, right) = s,
    if let Str::StringLit(a_ref) = left.as_ref(),
    if let Str::StringLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Str::StringLit(([a, b].concat()));

rw_str(s.clone(), t) <--
    str(s),
    if let Str::AddStr(left, right) = s,
    if let Str::StringLit(a_ref) = left.as_ref(),
    if let Str::StringLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Str::StringLit(({ let mut x = a.clone(); x.push_str(& b); x }));

rw_int(s.clone(), t) <--
    int(s),
    if let Int::Add(left, right) = s,
    if let Int::NumLit(a_ref) = left.as_ref(),
    if let Int::NumLit(b_ref) = right.as_ref(),
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let t = Int::NumLit((a + b));

rw_bool(orig.clone(), t) <--
    bool(orig),
    if let Bool::Not(inner) = orig,
    if let Bool::BoolLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Bool::BoolLit(({ match a { true => false, false => true, } }));

rw_int(orig.clone(), t) <--
    int(orig),
    if let Int::Len(inner) = orig,
    if let Str::StringLit(s_ref) = inner.as_ref(),
    let s = s_ref.clone(),
    let t = Int::NumLit((s.len() as i32));

rw_int(orig.clone(), t) <--
    int(orig),
    if let Int::Fact(inner) = orig,
    if let Int::NumLit(s_ref) = inner.as_ref(),
    let a = s_ref.clone(),
    let t = Int::NumLit(({ (1 ..= a.max(0)).product::< i32 > () }));

rw_int(__src.clone(), __dst) <--
    int(__src),
    if let Int::Tern(f0, f1, f2) = __src,
    if let Int::NumLit(r0) = f0.as_ref(),
    if let Int::NumLit(r1) = f1.as_ref(),
    if let Int::NumLit(r2) = f2.as_ref(),
    let c = r0.clone(),
    let t = r1.clone(),
    let e = r2.clone(),
    let __dst = Int::NumLit(({ if c != 0 { t } else { e } }));

fold_int(t.clone(), t.clone()) <--
    int(t),
    if let Int::NumLit(_) = t;

fold_int(s.clone(), res) <--
    int(s),
    if let Int::Pow(left, right) = s,
    fold_int(left.as_ref().clone(), lv),
    fold_int(right.as_ref().clone(), rv),
    if let Int::NumLit(a_ref) = & lv,
    if let Int::NumLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Int::NumLit((a.pow(b as u32)));

fold_int(s.clone(), res) <--
    int(s),
    if let Int::Add(left, right) = s,
    fold_int(left.as_ref().clone(), lv),
    fold_int(right.as_ref().clone(), rv),
    if let Int::NumLit(a_ref) = & lv,
    if let Int::NumLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Int::NumLit((a + b));

fold_int(s.clone(), res) <--
    int(s),
    if let Int::Neg(inner) = s,
    fold_int(inner.as_ref().clone(), iv),
    if let Int::NumLit(a_ref) = & iv,
    let a = a_ref.clone(),
    let res = Int::NumLit(((- a)));

fold_int(s.clone(), res) <--
    int(s),
    if let Int::Sub(left, right) = s,
    fold_int(left.as_ref().clone(), lv),
    fold_int(right.as_ref().clone(), rv),
    if let Int::NumLit(a_ref) = & lv,
    if let Int::NumLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Int::NumLit((a - b));

fold_int(s.clone(), res) <--
    int(s),
    if let Int::CustomOp(left, right) = s,
    fold_int(left.as_ref().clone(), lv),
    fold_int(right.as_ref().clone(), rv),
    if let Int::NumLit(a_ref) = & lv,
    if let Int::NumLit(b_ref) = & rv,
    let a = a_ref.clone(),
    let b = b_ref.clone(),
    let res = Int::NumLit((2 * a + 3 * b));

fold_int(s.clone(), res) <--
    int(s),
    if let Int::Fact(inner) = s,
    fold_int(inner.as_ref().clone(), iv),
    if let Int::NumLit(a_ref) = & iv,
    let a = a_ref.clone(),
    let res = Int::NumLit(({ (1 ..= a.max(0)).product::< i32 > () }));

rw_int(s.clone(), t.clone()) <--
    int(s),
    if (match s {
        Int::Neg(_) => true,
        Int::Sub(_, _) => true,
        Int::CustomOp(_, _) => true,
        _ => false,
    }),
    fold_int(s, t);

rw_bool(lhs.clone(), match (lhs, vi) {
    (Bool::Comp(_, x1), 0usize) => Bool::Comp(Box::new(t.clone()), x1.clone()),
    (Bool::Comp(x0, _), 1usize) => Bool::Comp(x0.clone(), Box::new(t.clone())),
    (Bool::Not(_), 2usize) => Bool::Not(Box::new(t.clone())),
    (Bool::EqBool(_, x1), 3usize) => Bool::EqBool(Box::new(t.clone()), x1.clone()),
    (Bool::EqBool(x0, _), 4usize) => Bool::EqBool(x0.clone(), Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    bool(lhs),
    for (field_val, vi) in (match lhs {
        Bool::Comp(x0, x1) => vec![((** x0).clone(), 0usize), ((** x1).clone(), 1usize)],
        Bool::EqBool(x0, x1) => vec![((** x0).clone(), 3usize), ((** x1).clone(), 4usize)],
        Bool::Not(x0) => vec![((** x0).clone(), 2usize)],
        _ => vec![],
    }).into_iter(),
    rw_bool(field_val, t);

rw_bool(lhs.clone(), match (lhs, vi) {
    (Bool::Eq(_, x1), 0usize) => Bool::Eq(Box::new(t.clone()), x1.clone()),
    (Bool::Eq(x0, _), 1usize) => Bool::Eq(x0.clone(), Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    bool(lhs),
    for (field_val, vi) in (match lhs {
        Bool::Eq(x0, x1) => vec![((** x0).clone(), 0usize), ((** x1).clone(), 1usize)],
        _ => vec![],
    }).into_iter(),
    rw_int(field_val, t);

rw_bool(lhs.clone(), match (lhs, vi) {
    (Bool::EqStr(_, x1), 0usize) => Bool::EqStr(Box::new(t.clone()), x1.clone()),
    (Bool::EqStr(x0, _), 1usize) => Bool::EqStr(x0.clone(), Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    bool(lhs),
    for (field_val, vi) in (match lhs {
        Bool::EqStr(x0, x1) => vec![((** x0).clone(), 0usize), ((** x1).clone(), 1usize)],
        _ => vec![],
    }).into_iter(),
    rw_str(field_val, t);

rw_int(lhs.clone(), match (lhs, vi) {
    (Int::Add(_, x1), 0usize) => Int::Add(Box::new(t.clone()), x1.clone()),
    (Int::Add(x0, _), 1usize) => Int::Add(x0.clone(), Box::new(t.clone())),
    (Int::Neg(_), 2usize) => Int::Neg(Box::new(t.clone())),
    (Int::Sub(_, x1), 3usize) => Int::Sub(Box::new(t.clone()), x1.clone()),
    (Int::Sub(x0, _), 4usize) => Int::Sub(x0.clone(), Box::new(t.clone())),
    (Int::Fact(_), 5usize) => Int::Fact(Box::new(t.clone())),
    (Int::Tern(_, x1, x2), 6usize) => Int::Tern(Box::new(t.clone()), x1.clone(), x2.clone()),
    (Int::Tern(x0, _, x2), 7usize) => Int::Tern(x0.clone(), Box::new(t.clone()), x2.clone()),
    (Int::Tern(x0, x1, _), 8usize) => Int::Tern(x0.clone(), x1.clone(), Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    int(lhs),
    for (field_val, vi) in (match lhs {
        Int::Add(x0, x1) => vec![((** x0).clone(), 0usize), ((** x1).clone(), 1usize)],
        Int::Fact(x0) => vec![((** x0).clone(), 5usize)],
        Int::Neg(x0) => vec![((** x0).clone(), 2usize)],
        Int::Sub(x0, x1) => vec![((** x0).clone(), 3usize), ((** x1).clone(), 4usize)],
        Int::Tern(x0, x1, x2) => vec![((** x0).clone(), 6usize), ((** x1).clone(), 7usize), ((** x2).clone(), 8usize)],
        _ => vec![],
    }).into_iter(),
    rw_int(field_val, t);

rw_str(lhs.clone(), match (lhs, vi) {
    (Str::AddStr(_, x1), 0usize) => Str::AddStr(Box::new(t.clone()), x1.clone()),
    (Str::AddStr(x0, _), 1usize) => Str::AddStr(x0.clone(), Box::new(t.clone())),
    _ => unreachable!(),
}) <--
    str(lhs),
    for (field_val, vi) in (match lhs {
        Str::AddStr(x0, x1) => vec![((** x0).clone(), 0usize), ((** x1).clone(), 1usize)],
        _ => vec![],
    }).into_iter(),
    rw_str(field_val, t);

}

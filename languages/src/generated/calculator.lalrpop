// Generated LALRPOP grammar for theory: Calculator
// This file is auto-generated - do not edit manually

use super::{Int, Bool, Str};

grammar;

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => { v.push(e); v }
    }
};

Ident: std::string::String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string(),
};

Integer: i32 = {
    r"[0-9]+" => <>.parse().unwrap_or(0),
};

Boolean: bool = {
    "true" => true,
    "false" => false,
};

StringLiteral: std::string::String = {
    r#""[^"]*""# => <>.trim_matches('"').to_string(),
};

pub Int: Int = {
    #[precedence(level="2")]
    <IntInfix>
};

IntInfix: Int = {
    #[precedence(level="0")]
    <IntAtom>,
    #[precedence(level="1")] #[assoc(side="left")]
    <left:IntInfix> "^" <right:IntAtom> => Int::Pow(Box::new(left), Box::new(right)),
    #[precedence(level="1")] #[assoc(side="left")]
    <left:IntInfix> "+" <right:IntAtom> => Int::Add(Box::new(left), Box::new(right)),
    #[precedence(level="1")] #[assoc(side="left")]
    <left:IntInfix> "-" <right:IntAtom> => Int::Sub(Box::new(left), Box::new(right)),
    #[precedence(level="1")] #[assoc(side="left")]
    <left:IntInfix> "~" <right:IntAtom> => Int::CustomOp(Box::new(left), Box::new(right)),
};

IntAtom: Int = {
    "(" <Int> ")",
    "|" <s:Str> "|" => Int::Len(Box::new(s)),
    "-" <i:Integer> => Int::NumLit(-i),
    <i:Integer> => Int::NumLit(i),
    <v:Ident> => Int::IVar(mettail_runtime::OrdVar(mettail_runtime::Var::Free(mettail_runtime::get_or_create_var(v.clone()))))
};

pub Bool: Bool = {
    #[precedence(level="2")]
    <BoolInfix>
};

BoolInfix: Bool = {
    #[precedence(level="0")]
    <BoolAtom>,
    #[precedence(level="1")] #[assoc(side="left")]
    <left:BoolInfix> "==" <right:BoolAtom> => Bool::EqBool(Box::new(left), Box::new(right)),
    #[precedence(level="1")] #[assoc(side="left")]
    <left:BoolInfix> "&&" <right:BoolAtom> => Bool::Comp(Box::new(left), Box::new(right)),
};

BoolAtom: Bool = {
    "(" <Bool> ")",
    <a:Int> "==" <b:Int> => Bool::Eq(Box::new(a), Box::new(b)),
    <a:Str> "==" <b:Str> => Bool::EqStr(Box::new(a), Box::new(b)),
    "not" <a:BoolAtom> => Bool::Not(Box::new(a)),
    <b:Boolean> => Bool::BoolLit(b),
    "bool:" <v:Ident> => Bool::BVar(mettail_runtime::OrdVar(mettail_runtime::Var::Free(mettail_runtime::get_or_create_var(v.clone()))))
};

pub Str: Str = {
    #[precedence(level="2")]
    <StrInfix>
};

StrInfix: Str = {
    #[precedence(level="0")]
    <StrAtom>,
    #[precedence(level="1")] #[assoc(side="left")]
    <left:StrInfix> "++" <right:StrAtom> => Str::Concat(Box::new(left), Box::new(right)),
    #[precedence(level="1")] #[assoc(side="left")]
    <left:StrInfix> "+" <right:StrAtom> => Str::AddStr(Box::new(left), Box::new(right)),
};

StrAtom: Str = {
    "(" <Str> ")",
    <s:StringLiteral> => Str::StringLit(s.clone()),
    "str:" <v:Ident> => Str::SVar(mettail_runtime::OrdVar(mettail_runtime::Var::Free(mettail_runtime::get_or_create_var(v.clone()))))
};


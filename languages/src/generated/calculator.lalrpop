// Generated LALRPOP grammar for theory: Calculator
// This file is auto-generated - do not edit manually

use super::{Int, Float, Bool, Str, VarCategory};

grammar;

match {
    "float",
    "bool",
    "str",
} else {
    r"[a-zA-Z_][a-zA-Z0-9_]*",
    _
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => { v.push(e); v }
    }
};

Ident: std::string::String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string(),
};

Integer: i32 = {
    r"[0-9]+" => <>.parse().unwrap_or(0),
};

FloatLiteral: f64 = {
    r"[0-9]+\.[0-9]+((e|E)(\+|-)?[0-9]+)?(f32|f64)?" => { let s = <>.trim_end_matches("f64").trim_end_matches("f32"); s.parse().unwrap_or(0.0) },
};

Boolean: bool = {
    "true" => true,
    "false" => false,
};

StringLiteral: std::string::String = {
    r#""[^"]*""# => <>.trim_matches('"').to_string(),
};

pub Int: Int = {
    <IntInfix>
};

IntInfix: Int = {
    <IntAtom>,
    <left:IntInfix> "^" <right:IntAtom> => Int::Pow(Box::new(left), Box::new(right)),
    <left:IntInfix> "+" <right:IntAtom> => Int::Add(Box::new(left), Box::new(right)),
    <left:IntInfix> "-" <right:IntAtom> => Int::Sub(Box::new(left), Box::new(right)),
    <left:IntInfix> "~" <right:IntAtom> => Int::CustomOp(Box::new(left), Box::new(right)),
};

IntAtom: Int = {
    "(" <Int> ")",
    "+" <i:Integer> => Int::NumLit(i),
    "-" <i:Integer> => Int::NumLit(-i),
    "|" <s:Str> "|" => Int::Len(Box::new(s)),
    <i:Integer> => Int::NumLit(i),
    <v:Ident> => Int::IVar(mettail_runtime::OrdVar(mettail_runtime::Var::Free(mettail_runtime::get_or_create_var(v.clone())))),
    "^" <x:Ident> "." "{" <body:Int> "}" => {
        let binder = mettail_runtime::Binder(mettail_runtime::get_or_create_var(x.clone()));
        // Infer binder type from usage in body (supports higher-order types)
        match body.infer_var_type(&x) {
            Some(ref t) => match t.base_type() {
                VarCategory::Int => Int::LamInt(mettail_runtime::Scope::new(binder, Box::new(body))),
                VarCategory::Float => Int::LamFloat(mettail_runtime::Scope::new(binder, Box::new(body))),
                VarCategory::Bool => Int::LamBool(mettail_runtime::Scope::new(binder, Box::new(body))),
                VarCategory::Str => Int::LamStr(mettail_runtime::Scope::new(binder, Box::new(body))),
            },
            None => panic!("Lambda binder '{}' not used in body", x),
        }
    },
    "^" "[" <xs:Comma<Ident>> "]" "." "{" <body:Int> "}" => {
        let binder_names: Vec<_> = xs.clone();
        let binders: Vec<_> = xs.into_iter()
            .map(|x| mettail_runtime::Binder(mettail_runtime::get_or_create_var(x)))
            .collect();
        // Infer binder type from first binder's usage in body
        let first_binder = binder_names.first().expect("Multi-lambda needs at least one binder");
        match body.infer_var_type(first_binder) {
            Some(ref t) => match t.base_type() {
                VarCategory::Int => Int::MLamInt(mettail_runtime::Scope::new(binders, Box::new(body))),
                VarCategory::Float => Int::MLamFloat(mettail_runtime::Scope::new(binders, Box::new(body))),
                VarCategory::Bool => Int::MLamBool(mettail_runtime::Scope::new(binders, Box::new(body))),
                VarCategory::Str => Int::MLamStr(mettail_runtime::Scope::new(binders, Box::new(body))),
            },
            None => panic!("Lambda binder '{}' not used in body", first_binder),
        }
    },
    "$int" "(" <lam:Int> "," <arg:Int> ")" => {
        Int::ApplyInt(Box::new(lam), Box::new(arg))
    },
    "$float" "(" <lam:Int> "," <arg:Float> ")" => {
        Int::ApplyFloat(Box::new(lam), Box::new(arg))
    },
    "$bool" "(" <lam:Int> "," <arg:Bool> ")" => {
        Int::ApplyBool(Box::new(lam), Box::new(arg))
    },
    "$str" "(" <lam:Int> "," <arg:Str> ")" => {
        Int::ApplyStr(Box::new(lam), Box::new(arg))
    },
    "$$int(" <lam:Int> "," <args:Comma<Int>> ")" => {
        Int::MApplyInt(Box::new(lam), args)
    },
    "$$float(" <lam:Int> "," <args:Comma<Float>> ")" => {
        Int::MApplyFloat(Box::new(lam), args)
    },
    "$$bool(" <lam:Int> "," <args:Comma<Bool>> ")" => {
        Int::MApplyBool(Box::new(lam), args)
    },
    "$$str(" <lam:Int> "," <args:Comma<Str>> ")" => {
        Int::MApplyStr(Box::new(lam), args)
    }
};

pub Float: Float = {
    <FloatInfix>
};

FloatInfix: Float = {
    <FloatAtom>,
    <left:FloatInfix> "+" <right:FloatAtom> => Float::AddFloat(Box::new(left), Box::new(right)),
};

FloatAtom: Float = {
    "(" <Float> ")",
    "+" <f:FloatLiteral> => Float::FloatLit(mettail_runtime::CanonicalFloat64::from(f)),
    "-" <f:FloatLiteral> => Float::FloatLit(mettail_runtime::CanonicalFloat64::from(-f)),
    <f:FloatLiteral> => Float::FloatLit(mettail_runtime::CanonicalFloat64::from(f)),
    "float" ":" <v:Ident> => Float::FVar(mettail_runtime::OrdVar(mettail_runtime::Var::Free(mettail_runtime::get_or_create_var(v.clone()))))
};

pub Bool: Bool = {
    <BoolInfix>
};

BoolInfix: Bool = {
    <BoolAtom>,
    <left:BoolInfix> "==" <right:BoolAtom> => Bool::EqBool(Box::new(left), Box::new(right)),
    <left:BoolInfix> "&&" <right:BoolAtom> => Bool::Comp(Box::new(left), Box::new(right)),
};

BoolAtom: Bool = {
    "(" <Bool> ")",
    <a:Int> "==" <b:Int> => Bool::Eq(Box::new(a), Box::new(b)),
    <a:Float> "==" <b:Float> => Bool::EqFloat(Box::new(a), Box::new(b)),
    <a:Str> "==" <b:Str> => Bool::EqStr(Box::new(a), Box::new(b)),
    "not" <a:BoolAtom> => Bool::Not(Box::new(a)),
    <b:Boolean> => Bool::BoolLit(b),
    "bool" ":" <v:Ident> => Bool::BVar(mettail_runtime::OrdVar(mettail_runtime::Var::Free(mettail_runtime::get_or_create_var(v.clone()))))
};

pub Str: Str = {
    <StrInfix>
};

StrInfix: Str = {
    <StrAtom>,
    <left:StrInfix> "++" <right:StrAtom> => Str::Concat(Box::new(left), Box::new(right)),
    <left:StrInfix> "+" <right:StrAtom> => Str::AddStr(Box::new(left), Box::new(right)),
};

StrAtom: Str = {
    "(" <Str> ")",
    <s:StringLiteral> => Str::StringLit(s.clone()),
    "str" ":" <v:Ident> => Str::SVar(mettail_runtime::OrdVar(mettail_runtime::Var::Free(mettail_runtime::get_or_create_var(v.clone()))))
};


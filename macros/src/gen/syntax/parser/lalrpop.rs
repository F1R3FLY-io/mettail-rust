// LALRPOP grammar generation for MeTTaIL languages
//
// This module generates `.lalrpop` grammar files from language definitions.
// The generated grammars parse text into the AST types generated by codegen.rs

#![allow(clippy::cmp_owned, clippy::useless_format)]

use crate::ast::{
    grammar::{GrammarItem, GrammarRule, PatternOp, SyntaxExpr, TermParam},
    language::LanguageDef,
    types::{CollectionType, TypeExpr},
};

/// Collection parameter: (name, coll_type, mapped_info)
type CollectionParamInfo = (String, CollectionType, Option<(usize, usize)>);
use crate::gen::native::{has_native_type, native_type_to_string};
use crate::gen::{generate_literal_label, generate_var_label, is_integer_rule, is_var_rule};

/// Generate token parser for native type if needed
fn generate_native_type_tokens(language: &LanguageDef) -> String {
    let mut tokens = String::new();

    // Check all types for native types and generate appropriate token parsers
    for lang_type in &language.types {
        if let Some(ref native_type) = lang_type.native_type {
            let type_str = native_type_to_string(native_type);

            // Generate token parser based on native type
            if type_str == "i32" || type_str == "i64" {
                tokens.push_str(&format!("Integer: {} = {{\n", type_str));
                // Only match positive integers at token level
                // Negative integers will be handled in the grammar via unary minus
                tokens.push_str("    r\"[0-9]+\" => <>.parse().unwrap_or(0),\n");
                tokens.push_str("};\n\n");
            } else if type_str == "f32" || type_str == "f64" {
                // Token name FloatLiteral to avoid collision with category Float
                tokens.push_str(&format!("FloatLiteral: {} = {{\n", type_str));
                tokens.push_str("    r\"[0-9]+\\.[0-9]+\" => <>.parse().unwrap_or(0.0),\n");
                tokens.push_str("};\n\n");
            } else if type_str == "bool" {
                tokens.push_str("Boolean: bool = {\n");
                tokens.push_str("    \"true\" => true,\n");
                tokens.push_str("    \"false\" => false,\n");
                tokens.push_str("};\n\n");
            } else if type_str == "str" || type_str == "String" {
                // Quoted string literal: single regex to avoid ambiguity with Integer/digits
                tokens.push_str("StringLiteral: std::string::String = {\n");
                tokens.push_str(
                    r##"    r#""[^"]*""# => <>.trim_matches('"').to_string(),"##,
                );
                tokens.push_str("\n};\n\n");
            }
            // Add more native types as needed
        }
    }

    tokens
}

/// Generate a LALRPOP grammar file content for a theory
///
/// This produces the text content of a `.lalrpop` file that can parse
/// the theory's syntax into its AST types.
pub fn generate_lalrpop_grammar(language: &LanguageDef) -> String {
    let language_name = &language.name;

    let mut grammar = String::new();

    // Add header
    grammar.push_str(&format!("// Generated LALRPOP grammar for theory: {}\n", language_name));
    grammar.push_str("// This file is auto-generated - do not edit manually\n\n");

    // Add use statements for runtime helpers. Only include what's needed
    let has_binders = language.terms.iter().any(|r| !r.bindings.is_empty());

    // Check if any category needs Var (i.e., has non-native types OR has Var rules)
    let _needs_var = language.types.iter().any(|t| t.native_type.is_none())
        || language.terms.iter().any(is_var_rule);

    // Check if any term uses HashBag collections (for #sep)
    let needs_hashbag = language.terms.iter().any(|r| {
        r.term_context.as_ref().is_some_and(|ctx| {
            ctx.iter().any(|param| {
                matches!(
                    param,
                    TermParam::Simple {
                        ty: TypeExpr::Collection { coll_type: CollectionType::HashBag, .. },
                        ..
                    }
                )
            })
        })
    });

    // Build the runtime imports (Var is not needed - generated code uses mettail_runtime::Var::Free etc.)
    let mut imports = Vec::new();
    if has_binders {
        imports.push("Binder");
        imports.push("Scope");
    }
    if needs_hashbag {
        imports.push("HashBag");
    }

    if !imports.is_empty() {
        grammar.push_str(&format!("use mettail_runtime::{{{}}};\n", imports.join(", ")));
    }

    // Import the AST types from the crate where the theory is defined
    // When used in test modules, this will be super::{...}
    // When used in library modules, LALRPOP will handle the paths correctly
    let mut type_names: Vec<String> = language.types.iter().map(|t| t.name.to_string()).collect();

    // Add VarCategory for lambda type inference (only if there are non-native types)
    let has_non_native_types = language.types.iter().any(|t| t.native_type.is_none());
    if has_non_native_types {
        type_names.push("VarCategory".to_string());
    }

    if !type_names.is_empty() {
        grammar.push_str(&format!("use super::{{{}}};\n", type_names.join(", ")));
    }

    grammar.push('\n');

    // Add grammar directive
    grammar.push_str("grammar;\n\n");

    // Add Comma helper macro for comma-separated lists
    grammar.push_str("Comma<T>: Vec<T> = {\n");
    grammar.push_str("    <mut v:(<T> \",\")*> <e:T?> => match e {\n");
    grammar.push_str("        None => v,\n");
    grammar.push_str("        Some(e) => { v.push(e); v }\n");
    grammar.push_str("    }\n");
    grammar.push_str("};\n\n");

    // Add identifier token definition (needed for binders and variables)
    grammar.push_str("Ident: std::string::String = {\n");
    grammar.push_str("    r\"[a-zA-Z_][a-zA-Z0-9_]*\" => <>.to_string(),\n");
    grammar.push_str("};\n\n");

    // Generate native type token parsers if needed
    grammar.push_str(&generate_native_type_tokens(language));

    // Generate productions for each type
    for lang_type in &language.types {
        let cat_name = &lang_type.name;

        // Find all rules for this category
        let rules: Vec<&GrammarRule> = language
            .terms
            .iter()
            .filter(|r| r.category == *cat_name)
            .collect();

        // Always generate production (even if no rules, we might need Var)
        grammar.push_str(&generate_category_production(cat_name, &rules, language));
        grammar.push('\n');
    }

    grammar
}

/// Check if a rule starts with Var followed by a terminal (e.g., Var "=" Int)
/// These rules need special handling to avoid ambiguity with bare VarRef rules
fn is_var_terminal_rule(rule: &GrammarRule) -> bool {
    rule.items.len() >= 2
        && matches!(&rule.items[0], GrammarItem::NonTerminal(nt) if nt.to_string() == "Var")
        && matches!(&rule.items[1], GrammarItem::Terminal(_))
}

/// Generate a LALRPOP production for a category
///
/// This handles precedence by creating tiered rules for infix operators
fn generate_category_production(
    category: &syn::Ident,
    rules: &[&GrammarRule],
    language: &LanguageDef,
) -> String {
    let _cat_str = category.to_string();

    // Checks if there's already a Var rule
    let has_var_rule = rules.iter().any(|r| is_var_rule(r));

    // Separate rules that start with Var+terminal (need special handling for ambiguity)
    let (var_terminal_rules, non_var_terminal_rules): (Vec<&GrammarRule>, Vec<&GrammarRule>) =
        rules.iter().copied().partition(|r| is_var_terminal_rule(r));

    // Classify remaining rules by type (both old BNFC infix and HOL infix need tiered production)
    let (infix_rules, other_rules): (Vec<&GrammarRule>, Vec<&GrammarRule>) = non_var_terminal_rules
        .iter()
        .copied()
        .partition(|r| is_infix_rule(r) || is_hol_infix_rule(r));

    // If we have infix operators or var+terminal rules, generate tiered rules for precedence
    if !infix_rules.is_empty() || !var_terminal_rules.is_empty() {
        generate_tiered_production(
            category,
            &infix_rules,
            &other_rules,
            &var_terminal_rules,
            has_var_rule,
            language,
        )
    } else {
        // No infix operators - generate simple production
        generate_simple_production(category, &other_rules, has_var_rule, language)
    }
}

/// Check if a rule is an infix operator (e.g., Proc ::= Proc "|" Proc)
fn is_infix_rule(rule: &GrammarRule) -> bool {
    // An infix rule has the pattern: NonTerm (Terminal | NonTerm)+ NonTerm
    // where the first and last non-terminals are the same as the rule's category
    if rule.items.len() < 3 {
        return false;
    }

    // Check if first item is the same category
    let first_match = matches!(&rule.items[0],
        GrammarItem::NonTerminal(nt) if nt == &rule.category);

    // Check if last item is the same category
    let last_match = matches!(rule.items.last(),
        Some(GrammarItem::NonTerminal(nt)) if nt == &rule.category);

    // Check if there's a terminal in the middle (the operator)
    let has_terminal = rule.items[1..rule.items.len() - 1]
        .iter()
        .any(|item| matches!(item, GrammarItem::Terminal(_)));

    first_match && last_match && has_terminal
}

/// Check if a HOL-style rule is binary infix (e.g., a:Int, b:Int |- a "+" b : Int)
/// Such rules need tiered production for left-associativity and precedence.
fn is_hol_infix_rule(rule: &GrammarRule) -> bool {
    let (term_context, syntax_pattern) = match (&rule.term_context, &rule.syntax_pattern) {
        (Some(tc), Some(sp)) => (tc, sp),
        _ => return false,
    };
    // Pattern must be exactly [Param, Literal, Param]
    if syntax_pattern.len() != 3 {
        return false;
    }
    let (left_param, right_param) =
        match (&syntax_pattern[0], &syntax_pattern[1], &syntax_pattern[2]) {
            (SyntaxExpr::Param(l), SyntaxExpr::Literal(_op), SyntaxExpr::Param(r)) => (l, r),
            _ => return false,
        };
    // Both params must have type equal to rule.category (compare by string for robustness)
    let param_ty = |name: &syn::Ident| -> Option<&syn::Ident> {
        let name_str = name.to_string();
        term_context.iter().find_map(|p| {
            if let TermParam::Simple { name: n, ty } = p {
                if n.to_string() == name_str {
                    if let TypeExpr::Base(t) = ty {
                        return Some(t);
                    }
                }
            }
            None
        })
    };
    let left_ty = match param_ty(left_param) {
        Some(t) => t,
        None => return false,
    };
    let right_ty = match param_ty(right_param) {
        Some(t) => t,
        None => return false,
    };
    let cat_str = rule.category.to_string();
    left_ty.to_string() == cat_str && right_ty.to_string() == cat_str
}

/// Generate tiered production for handling precedence
fn generate_tiered_production(
    category: &syn::Ident,
    infix_rules: &[&GrammarRule],
    other_rules: &[&GrammarRule],
    var_terminal_rules: &[&GrammarRule],
    has_var_rule: bool,
    language: &LanguageDef,
) -> String {
    let cat_str = category.to_string();
    let mut production = String::new();

    // Top-level rule: handle var+terminal rules first (most specific), then delegate to infix.
    // Low precedence on <CatInfix> so that when we see an infix op (e.g. "+") we shift rather than reduce (fixes shift/reduce conflict).
    production.push_str(&format!("pub {}: {} = {{\n", cat_str, cat_str));

    // Add var+terminal rules at top level (highest specificity - tried first)
    if !var_terminal_rules.is_empty() {
        for rule in var_terminal_rules.iter() {
            production.push_str("    ");
            production.push_str(&generate_var_terminal_alternative(rule, &cat_str));
            production.push_str(",\n");
        }
    }

    // Then delegate to infix tier (low precedence so infix ops prefer shift)
    production.push_str("    #[precedence(level=\"2\")]\n");
    production.push_str(&format!("    <{}Infix>\n", cat_str));
    production.push_str("};\n\n");

    // Infix tier - atom at level 0 first (LALRPOP disallows assoc on the first precedence level), then infix at level 1 with assoc
    production.push_str(&format!("{}Infix: {} = {{\n", cat_str, cat_str));

    // Base case first with precedence 0 so that level 1 can use associativity
    production.push_str("    #[precedence(level=\"0\")]\n");
    production.push_str(&format!("    <{}Atom>,\n", cat_str));

    // Generate left-recursive rules for infix operators
    for rule in infix_rules.iter() {
        production.push_str("    #[precedence(level=\"1\")] #[assoc(side=\"left\")]\n");
        production.push_str("    ");
        let alt = if is_hol_infix_rule(rule) {
            generate_hol_infix_alternative(rule, &cat_str)
        } else {
            generate_infix_alternative(rule, &cat_str)
        };
        production.push_str(&alt);
        production.push_str(",\n");
    }
    // Remove trailing comma from last infix rule (LALRPOP allows trailing comma)
    production.push_str("};\n\n");

    // Atom tier - handles non-infix constructs and parentheses
    production.push_str(&format!("{}Atom: {} = {{\n", cat_str, cat_str));

    // Add parenthesized expressions - reference the top-level rule
    production.push_str(&format!("    \"(\" <{}> \")\",\n", cat_str));

    // Filter out var+terminal rules from other_rules (they're handled at top level)
    let filtered_other_rules: Vec<&GrammarRule> = other_rules
        .iter()
        .filter(|r| !is_var_terminal_rule(r))
        .copied()
        .collect();

    // Add unary minus support for native integer types (before other rules for precedence)
    if let Some(native_type) = has_native_type(category, language) {
        let type_str = native_type_to_string(native_type);
        if type_str == "i32" || type_str == "i64" {
            // Find the Integer rule (for integer literals)
            if let Some(integer_rule) = filtered_other_rules.iter().find(|r| is_integer_rule(r)) {
                let integer_label = integer_rule.label.to_string();
                production.push_str(&format!(
                    "    \"-\" <i:Integer> => {}::{}(-i),\n",
                    cat_str, integer_label
                ));
            }
        }
    }

    // Add non-infix rules (excluding var+terminal rules, which are handled at top level)
    // Use Atom for same-category params to avoid ambiguity with Infix tier
    for (i, rule) in filtered_other_rules.iter().enumerate() {
        production.push_str("    ");
        production.push_str(&generate_rule_alternative_with_language(rule, Some(language), true));

        if i < filtered_other_rules.len() - 1 {
            production.push_str(",\n");
        }
        // Last rule: no trailing newline so auto-alternatives can add ",\n    <Var>"
    }

    // Check if there's an explicit Integer rule (NumLit . Cat ::= Integer)
    let has_integer_rule = filtered_other_rules.iter().any(|r| is_integer_rule(r));

    // Add auto-generated alternatives (Var and literal rules)
    production.push_str(&generate_auto_alternatives(
        category,
        has_var_rule,
        has_integer_rule,
        language,
        !filtered_other_rules.is_empty(), // needs_leading_comma
    ));

    production.push_str("\n};\n");
    production
}

/// Generate alternative for HOL-style infix rule (left-associative)
/// Pattern is [Param, Literal, Param]; produces <left:CatInfix> "op" <right:CatAtom> => ...
fn generate_hol_infix_alternative(rule: &GrammarRule, cat_str: &str) -> String {
    let label = &rule.label;
    let category = &rule.category;
    let syntax_pattern = rule
        .syntax_pattern
        .as_ref()
        .expect("HOL infix rule has syntax_pattern");
    let op_str = match &syntax_pattern[1] {
        SyntaxExpr::Literal(s) => s.as_str(),
        _ => panic!("HOL infix pattern[1] must be Literal"),
    };
    // Escape " and \ for LALRPOP string literal
    let escaped = op_str.replace('\\', "\\\\").replace('"', "\\\"");
    format!(
        "<left:{}Infix> \"{}\" <right:{}Atom> => {}::{}(Box::new(left), Box::new(right))",
        cat_str, escaped, cat_str, category, label
    )
}

/// Generate alternative for infix operator (left-associative)
fn generate_infix_alternative(rule: &GrammarRule, cat_str: &str) -> String {
    let label = &rule.label;
    let category = &rule.category;

    // Pattern: <left:Cat> "op" <right:CatAtom>
    // This ensures left-associativity
    let mut pattern = format!("<left:{}Infix>", cat_str);

    // Process items to find operator and right operand
    for (i, item) in rule.items.iter().enumerate() {
        if i == 0 {
            continue; // Skip first (it's the left operand)
        }

        match item {
            GrammarItem::Terminal(term) => {
                pattern.push_str(&format!(" \"{}\"", term));
            },
            GrammarItem::NonTerminal(nt) if nt == category && i == rule.items.len() - 1 => {
                // Last item - use Atom tier to avoid ambiguity
                pattern.push_str(&format!(" <right:{}Atom>", cat_str));
            },
            GrammarItem::NonTerminal(nt) if nt == category => {
                // Middle recursive reference - shouldn't happen in binary infix
                pattern.push_str(&format!(" <mid{}>", i));
            },
            GrammarItem::NonTerminal(_) => {
                pattern.push_str(&format!(" <f{}>", i));
            },
            GrammarItem::Collection { .. } => {
                // Collections in infix operators not yet supported (Phase 4)
                panic!("Collection types in infix operators not yet implemented (Phase 4)");
            },
            GrammarItem::Binder { .. } => {
                // Binders in infix operators - unusual but handle it
                pattern.push_str(&format!(" <x_{}>", i));
            },
        }
    }

    // Generate action
    let action = format!(" => {}::{}(Box::new(left), Box::new(right))", category, label);

    format!("{}{}", pattern, action)
}

/// Generate alternative for rules starting with Var followed by terminal (e.g., Var "=" Int)
/// These rules use CatInfix for recursive references to avoid ambiguity with the top-level rule
fn generate_var_terminal_alternative(rule: &GrammarRule, cat_str: &str) -> String {
    let label = &rule.label;
    let category = &rule.category;

    let mut pattern = String::new();
    let mut args = Vec::new();
    let mut field_idx = 0;

    for item in &rule.items {
        match item {
            GrammarItem::Terminal(term) => {
                pattern.push_str(&format!(" \"{}\"", term));
            },
            GrammarItem::NonTerminal(nt) => {
                let var_name = format!("f{}", field_idx);

                if nt.to_string() == "Var" {
                    // Var should parse as Ident, then convert to OrdVar
                    pattern.push_str(&format!(" <{}:Ident>", var_name));
                    args.push(format!("mettail_runtime::OrdVar(mettail_runtime::Var::Free(mettail_runtime::get_or_create_var({}.clone())))", var_name));
                } else if nt == category {
                    // Recursive reference: use CatInfix to avoid circular reference
                    pattern.push_str(&format!(" <{}:{}Infix>", var_name, cat_str));
                    args.push(format!("Box::new({})", var_name));
                } else {
                    // Different category: use as-is
                    pattern.push_str(&format!(" <{}:{}>", var_name, nt));
                    args.push(format!("Box::new({})", var_name));
                }
                field_idx += 1;
            },
            GrammarItem::Collection { .. } => {
                // Collections in var+terminal rules - unusual but skip for now
            },
            GrammarItem::Binder { .. } => {
                // Binders in var+terminal rules - unusual but skip for now
            },
        }
    }

    // Construct the AST node
    let args_str = args.join(", ");
    format!("{} => {}::{}({})", pattern.trim(), category, label, args_str)
}

/// Generate simple production (no infix operators)
fn generate_simple_production(
    category: &syn::Ident,
    rules: &[&GrammarRule],
    has_var_rule: bool,
    language: &LanguageDef,
) -> String {
    let mut production = String::new();

    // Production header: pub CategoryName: CategoryName = {
    production.push_str(&format!("pub {}: {} = {{\n", category, category));

    // Generate alternative for each rule (no Atom tier, so don't use CatAtom for same-category)
    for (i, rule) in rules.iter().enumerate() {
        production.push_str("    ");
        // Pass theory context for native type detection
        production.push_str(&generate_rule_alternative_with_language(rule, Some(language), false));

        if i < rules.len() - 1 {
            production.push_str(",\n");
        } else {
            production.push('\n');
        }
    }

    // Check if there's an explicit Integer rule (NumLit . Cat ::= Integer)
    let has_integer_rule = rules.iter().any(|r| is_integer_rule(r));

    // Add auto-generated alternatives (Var and literal rules)
    production.push_str(&generate_auto_alternatives(
        category,
        has_var_rule,
        has_integer_rule,
        language,
        !rules.is_empty(), // needs_leading_comma
    ));

    production.push_str("\n};\n");
    production
}

/// Generate a LALRPOP alternative for a single grammar rule
///
/// This is the main entry point - delegates to unified analyze/generate flow.
/// When use_atom_for_same_category is true (Atom tier in tiered production),
/// same-category params use CatAtom to avoid shift/reduce ambiguity.
fn generate_rule_alternative_with_language(
    rule: &GrammarRule,
    _language: Option<&LanguageDef>,
    use_atom_for_same_category: bool,
) -> String {
    let cat_str = rule.category.to_string();

    // Collection rules (old BNFC-style) have special pattern/action generation
    // Pattern-style collection rules are handled by analyze_pattern_rule
    if rule.syntax_pattern.is_none() {
        if rule.items.len() == 1 {
            if let GrammarItem::Collection {
                coll_type,
                element_type,
                separator,
                delimiters,
            } = &rule.items[0]
            {
                return generate_collection_alternative(
                    rule,
                    coll_type,
                    element_type,
                    separator,
                    delimiters.as_ref(),
                );
            }
        }
        for item in &rule.items {
            if let GrammarItem::Collection {
                coll_type,
                element_type,
                separator,
                delimiters,
            } = item
            {
                return generate_collection_alternative(
                    rule,
                    coll_type,
                    element_type,
                    separator,
                    delimiters.as_ref(),
                );
            }
        }
    }

    // All rules go through unified analyze/generate flow
    let analyzed = analyze_rule(rule, &cat_str, use_atom_for_same_category);
    generate_alternative(&analyzed, &rule.category, &rule.label)
}

//==============================================================================
// CORE STRUCTURES
//==============================================================================

/// How a captured value is used in the action code
#[derive(Debug, Clone)]
enum CaptureUsage {
    /// Box::new(var)
    Boxed,
    /// Use as-is (e.g., for OrdVar, collections)
    Direct,
    /// Convert to OrdVar: OrdVar(Var::Free(get_or_create_var(var)))
    AsVar,
    /// Used as binder name in Scope creation
    Binder,
    /// Used as body in Scope creation
    Body,
}

/// A single capture in a LALRPOP pattern
#[derive(Debug, Clone)]
struct Capture {
    /// Variable name in LALRPOP pattern (e.g., "f0", "body")
    var_name: String,
    /// LALRPOP non-terminal to parse (e.g., "Proc", "Ident") - used for debugging
    #[allow(dead_code)]
    nonterminal: String,
    /// How to use this capture in the action
    usage: CaptureUsage,
}

/// What kind of action to generate
#[derive(Debug, Clone)]
#[allow(dead_code)]
enum ActionKind {
    /// Simple constructor: Category::Label(args...)
    Simple,
    /// Unit constructor: Category::Label
    Unit,
    /// Needs single-binder Scope creation
    Binder { binder_var: String, body_var: String },
    /// Needs multi-binder Scope with Vec<Binder>
    MultiBinder {
        collection_param: String,
        body_param: String,
        /// Pattern elements for tuple destructuring
        elements: Vec<SepElement>,
    },
    /// Builds a collection from separated list (BNFC-style rules)
    Collection {
        name: String,
        elem_type: String,
        coll_type: CollectionType,
    },
    /// Simple with collection parameters that need _v/_e combining
    SimpleWithCollections {
        /// Collection params: (name, coll_type, mapped_info)
        /// mapped_info: Some((element_index, tuple_len)) if from #map, None if simple
        collections: Vec<CollectionParamInfo>,
    },
}

/// Element in a separated list pattern (for multi-binder)
#[derive(Debug, Clone)]
#[allow(dead_code)]
enum SepElement {
    /// Literal - matched but not captured (becomes _ in tuple)
    Literal(String),
    /// Captured as collection element
    CollectionCapture(String),
    /// Captured as binder string
    BinderCapture(String),
}

/// Analyzed rule ready for LALRPOP generation
#[derive(Debug, Clone)]
struct AnalyzedRule {
    /// LALRPOP pattern string
    pattern: String,
    /// Captures in order (for simple/binder rules)
    captures: Vec<Capture>,
    /// What kind of action to generate
    action_kind: ActionKind,
}

//==============================================================================
// UNIFIED RULE ANALYSIS
//==============================================================================

/// Analyze a grammar rule to produce an AnalyzedRule
///
/// This is the single entry point for converting any GrammarRule into
/// the unified AnalyzedRule representation.
/// Analyze a single-item rule
fn analyze_single_item_rule(rule: &GrammarRule) -> AnalyzedRule {
    match &rule.items[0] {
        GrammarItem::Terminal(_term) => {
            // Unit constructor: "0" => Proc::PZero
            AnalyzedRule {
                pattern: format!("\"{}\"", _term),
                captures: vec![],
                action_kind: ActionKind::Unit,
            }
        },
        GrammarItem::NonTerminal(nt) if nt.to_string() == "Integer" => AnalyzedRule {
            pattern: "<i:Integer>".to_string(),
            captures: vec![Capture {
                var_name: "i".to_string(),
                nonterminal: "Integer".to_string(),
                usage: CaptureUsage::Direct,
            }],
            action_kind: ActionKind::Simple,
        },
        GrammarItem::NonTerminal(nt) if nt.to_string() == "Var" => AnalyzedRule {
            pattern: "<v:Ident>".to_string(),
            captures: vec![Capture {
                var_name: "v".to_string(),
                nonterminal: "Ident".to_string(),
                usage: CaptureUsage::AsVar,
            }],
            action_kind: ActionKind::Simple,
        },
        GrammarItem::NonTerminal(nt) => AnalyzedRule {
            pattern: format!("<val:{}>", nt),
            captures: vec![Capture {
                var_name: "val".to_string(),
                nonterminal: nt.to_string(),
                usage: CaptureUsage::Boxed,
            }],
            action_kind: ActionKind::Simple,
        },
        GrammarItem::Collection {
            coll_type,
            element_type,
            separator,
            delimiters,
        } => analyze_collection_rule(rule, coll_type, element_type, separator, delimiters.as_ref()),
        GrammarItem::Binder { .. } => {
            // Binder alone shouldn't happen in valid grammar rules
            panic!(
                "GrammarItem::Binder should not appear alone - use binder syntax in term context"
            )
        },
    }
}

/// Analyze a sequence rule (multiple items, no binders)
fn analyze_sequence_rule(rule: &GrammarRule, _cat_str: &str) -> AnalyzedRule {
    let mut pattern_parts = Vec::new();
    let mut captures = Vec::new();
    let mut field_idx = 0;

    for item in &rule.items {
        match item {
            GrammarItem::Terminal(term) => {
                pattern_parts.push(format!("\"{}\"", term));
            },
            GrammarItem::NonTerminal(nt) => {
                let var_name = format!("f{}", field_idx);

                if nt.to_string() == "Var" {
                    pattern_parts.push(format!("<{}:Ident>", var_name));
                    captures.push(Capture {
                        var_name: var_name.clone(),
                        nonterminal: "Ident".to_string(),
                        usage: CaptureUsage::AsVar,
                    });
                } else {
                    pattern_parts.push(format!("<{}:{}>", var_name, nt));
                    captures.push(Capture {
                        var_name: var_name.clone(),
                        nonterminal: nt.to_string(),
                        usage: CaptureUsage::Boxed,
                    });
                }
                field_idx += 1;
            },
            GrammarItem::Collection {
                coll_type,
                element_type,
                separator,
                delimiters,
            } => {
                // Collection in sequence - return full collection rule
                return analyze_collection_rule(
                    rule,
                    coll_type,
                    element_type,
                    separator,
                    delimiters.as_ref(),
                );
            },
            GrammarItem::Binder { .. } => {
                let var_name = format!("b{}", field_idx);
                pattern_parts.push(format!("<{}:Ident>", var_name));
                captures.push(Capture {
                    var_name,
                    nonterminal: "Ident".to_string(),
                    usage: CaptureUsage::Binder,
                });
                field_idx += 1;
            },
        }
    }

    AnalyzedRule {
        pattern: pattern_parts.join(" "),
        captures,
        action_kind: ActionKind::Simple,
    }
}

/// Analyze a grammar rule to produce an AnalyzedRule
///
/// When use_atom_for_same_category is true (Atom tier), same-category params
/// use CatAtom to avoid ambiguity with the Infix tier.
fn analyze_rule(rule: &GrammarRule, cat_str: &str, use_atom_for_same_category: bool) -> AnalyzedRule {
    // Check for new judgement-style syntax first
    if let (Some(ref term_context), Some(ref syntax_pattern)) =
        (&rule.term_context, &rule.syntax_pattern)
    {
        return analyze_pattern_rule(rule, term_context, syntax_pattern, use_atom_for_same_category);
    }

    // Handle old BNFC-style rules
    if rule.items.len() == 1 {
        analyze_single_item_rule(rule)
    } else if !rule.bindings.is_empty() {
        analyze_binder_rule(rule)
    } else {
        analyze_sequence_rule(rule, cat_str)
    }
}

/// Analyze a rule with binders
fn analyze_binder_rule(rule: &GrammarRule) -> AnalyzedRule {
    let (binder_idx, body_indices) = &rule.bindings[0];
    let body_idx = body_indices[0];

    let mut pattern_parts = Vec::new();
    let mut captures = Vec::new();
    let mut binder_var = String::new();
    let mut body_var = String::new();
    let mut field_idx = 0;

    for (i, item) in rule.items.iter().enumerate() {
        match item {
            GrammarItem::Terminal(term) => {
                pattern_parts.push(format!("\"{}\"", term));
            },
            GrammarItem::NonTerminal(nt) => {
                if i == body_idx {
                    body_var = format!("body_{}", field_idx);
                    pattern_parts.push(format!("<{}:{}>", body_var, nt));
                    captures.push(Capture {
                        var_name: body_var.clone(),
                        nonterminal: nt.to_string(),
                        usage: CaptureUsage::Body,
                    });
                } else {
                    let var_name = format!("f{}", field_idx);
                    pattern_parts.push(format!("<{}:{}>", var_name, nt));

                    let usage = if nt.to_string() == "Var" {
                        CaptureUsage::Direct
                    } else {
                        CaptureUsage::Boxed
                    };
                    captures.push(Capture {
                        var_name,
                        nonterminal: nt.to_string(),
                        usage,
                    });
                }
                field_idx += 1;
            },
            GrammarItem::Collection { .. } => {
                panic!("Collection types in binder rules not yet implemented");
            },
            GrammarItem::Binder { .. } => {
                if i == *binder_idx {
                    binder_var = format!("x_{}", field_idx);
                    pattern_parts.push(format!("<{}:Ident>", binder_var));
                    captures.push(Capture {
                        var_name: binder_var.clone(),
                        nonterminal: "Ident".to_string(),
                        usage: CaptureUsage::Binder,
                    });
                }
                field_idx += 1;
            },
        }
    }

    AnalyzedRule {
        pattern: pattern_parts.join(" "),
        captures,
        action_kind: ActionKind::Binder { binder_var, body_var },
    }
}

/// Analyze a collection rule
fn analyze_collection_rule(
    _rule: &GrammarRule,
    coll_type: &CollectionType,
    element_type: &syn::Ident,
    separator: &str,
    delimiters: Option<&(String, String)>,
) -> AnalyzedRule {
    let sep_escaped = if separator == "|" {
        r"\|".to_string()
    } else {
        separator.replace("\"", "\\\"")
    };

    let sep_pattern = if separator == "|" {
        format!("r\"{}\"", sep_escaped)
    } else {
        format!("\"{}\"", sep_escaped)
    };

    let pattern = if let Some((open, close)) = delimiters {
        let open_escaped = open.replace("\"", "\\\"");
        let close_escaped = close.replace("\"", "\\\"");
        format!(
            "\"{}\" <elems:(<{}> {})*> <last:{}?> \"{}\"",
            open_escaped, element_type, sep_pattern, element_type, close_escaped
        )
    } else {
        format!("<first:{}> <rest:({} <{}>)*>", element_type, sep_pattern, element_type)
    };

    AnalyzedRule {
        pattern,
        captures: vec![], // Collection captures are handled specially
        action_kind: ActionKind::Collection {
            name: "coll".to_string(),
            elem_type: element_type.to_string(),
            coll_type: coll_type.clone(),
        },
    }
}

/// Analyze a pattern-style rule (new judgement syntax)
///
/// When use_atom_for_same_category is true and a parameter's type is the same
/// as the rule's category, we use CatAtom instead of Cat. This avoids
/// shift/reduce ambiguities in the Atom tier (e.g. "!" Bool vs BoolInfix "&&" BoolAtom).
fn analyze_pattern_rule(
    rule: &GrammarRule,
    term_context: &[TermParam],
    syntax_pattern: &[SyntaxExpr],
    use_atom_for_same_category: bool,
) -> AnalyzedRule {
    let param_types = build_param_types(term_context);
    let rule_category = if use_atom_for_same_category {
        rule.category.to_string()
    } else {
        String::new()
    };

    let mut pattern_parts = Vec::new();
    let mut captures = Vec::new();
    let mut binder_var: Option<String> = None;
    let mut body_var: Option<String> = None;
    let mut multi_binder: Option<(String, String, Vec<SepElement>)> = None;
    let mut collection_params: Vec<CollectionParamInfo> = Vec::new();

    for expr in syntax_pattern {
        analyze_syntax_expr_with_collections(
            expr,
            &param_types,
            &rule_category,
            &mut pattern_parts,
            &mut captures,
            &mut binder_var,
            &mut body_var,
            &mut multi_binder,
            &mut collection_params,
        );
    }

    let action_kind = if let Some((collection_param, body_param, elements)) = multi_binder {
        ActionKind::MultiBinder { collection_param, body_param, elements }
    } else if let (Some(bv), Some(bdy)) = (binder_var, body_var) {
        ActionKind::Binder { binder_var: bv, body_var: bdy }
    } else if !collection_params.is_empty() {
        ActionKind::SimpleWithCollections { collections: collection_params }
    } else if captures.is_empty() {
        ActionKind::Unit
    } else {
        ActionKind::Simple
    };

    AnalyzedRule {
        pattern: pattern_parts.join(" "),
        captures,
        action_kind,
    }
}

/// Analyze a single syntax expression (with collection tracking)
///
/// When rule_category is set and a Simple param's type equals it, we use CatAtom
/// instead of Cat so Atom-tier rules (e.g. unary prefix) stay unambiguous.
#[allow(clippy::too_many_arguments)]
fn analyze_syntax_expr_with_collections(
    expr: &SyntaxExpr,
    param_types: &std::collections::HashMap<String, ParamInfo>,
    rule_category: &str,
    pattern_parts: &mut Vec<String>,
    captures: &mut Vec<Capture>,
    binder_var: &mut Option<String>,
    body_var: &mut Option<String>,
    multi_binder: &mut Option<(String, String, Vec<SepElement>)>,
    collection_params: &mut Vec<CollectionParamInfo>,
) {
    match expr {
        SyntaxExpr::Literal(s) => {
            pattern_parts.push(format!("\"{}\"", s));
        },
        SyntaxExpr::Param(id) => {
            let name = id.to_string();
            if let Some(info) = param_types.get(&name) {
                match info.kind {
                    ParamKind::Simple => {
                        let mut nonterminal = type_to_nonterminal(&info.ty);
                        if !rule_category.is_empty() && nonterminal == rule_category {
                            nonterminal = format!("{}Atom", rule_category);
                        }
                        pattern_parts.push(format!("<{}:{}>", name, nonterminal));
                        captures.push(Capture {
                            var_name: name,
                            nonterminal,
                            usage: CaptureUsage::Boxed,
                        });
                    },
                    ParamKind::Binder => {
                        pattern_parts.push(format!("<{}:Ident>", name));
                        *binder_var = Some(name.clone());
                        captures.push(Capture {
                            var_name: name,
                            nonterminal: "Ident".to_string(),
                            usage: CaptureUsage::Binder,
                        });
                    },
                    ParamKind::MultiBinder => {
                        pattern_parts.push(format!("<{}:Ident>", name));
                        *binder_var = Some(name.clone());
                        captures.push(Capture {
                            var_name: name,
                            nonterminal: "Ident".to_string(),
                            usage: CaptureUsage::Binder,
                        });
                    },
                    ParamKind::Body => {
                        let nonterminal = type_to_nonterminal(&info.ty);
                        pattern_parts.push(format!("<{}:{}>", name, nonterminal));
                        *body_var = Some(name.clone());
                        captures.push(Capture {
                            var_name: name,
                            nonterminal,
                            usage: CaptureUsage::Body,
                        });
                    },
                    ParamKind::Collection => {
                        if let TypeExpr::Collection { element, .. } = &info.ty {
                            let elem_type = type_to_nonterminal(element);
                            pattern_parts.push(format!(
                                "<{}:((<{}> \"|\")* <{}>?)>",
                                name, elem_type, elem_type
                            ));
                            captures.push(Capture {
                                var_name: name,
                                nonterminal: elem_type,
                                usage: CaptureUsage::Direct,
                            });
                        }
                    },
                }
            }
        },
        SyntaxExpr::Op(op) => {
            analyze_pattern_op_with_collections(
                op,
                param_types,
                pattern_parts,
                captures,
                multi_binder,
                collection_params,
            );
        },
    }
}

/// Analyze a single syntax expression (legacy, without collection tracking)
fn analyze_syntax_expr(
    expr: &SyntaxExpr,
    param_types: &std::collections::HashMap<String, ParamInfo>,
    pattern_parts: &mut Vec<String>,
    captures: &mut Vec<Capture>,
    binder_var: &mut Option<String>,
    body_var: &mut Option<String>,
    multi_binder: &mut Option<(String, String, Vec<SepElement>)>,
) {
    let mut collection_params = Vec::new();
    analyze_syntax_expr_with_collections(
        expr,
        param_types,
        "", // no rule context: don't apply Atom-tier same-category rule
        pattern_parts,
        captures,
        binder_var,
        body_var,
        multi_binder,
        &mut collection_params,
    );
}

/// Analyze a pattern operation (with collection tracking)
fn analyze_pattern_op_with_collections(
    op: &PatternOp,
    param_types: &std::collections::HashMap<String, ParamInfo>,
    pattern_parts: &mut Vec<String>,
    captures: &mut Vec<Capture>,
    multi_binder: &mut Option<(String, String, Vec<SepElement>)>,
    collection_params: &mut Vec<CollectionParamInfo>,
) {
    match op {
        PatternOp::Sep { collection, separator, source } => {
            if let Some(chain_source) = source {
                // Chained operation with map
                if let PatternOp::Map { source: map_source, params, body } = chain_source.as_ref() {
                    // Check what the map source is
                    if let PatternOp::Zip { left, right } = map_source.as_ref() {
                        // Multi-binder pattern: #zip(...).#map(...).#sep(",")
                        let left_name = left.to_string();
                        let right_name = right.to_string();

                        let (collection_param, _binder_param) = if param_types
                            .get(&left_name)
                            .map(|i| matches!(i.kind, ParamKind::MultiBinder))
                            .unwrap_or(false)
                        {
                            (right_name.clone(), left_name.clone())
                        } else {
                            (left_name.clone(), right_name.clone())
                        };

                        let body_param = param_types
                            .iter()
                            .find(|(name, info)| {
                                matches!(info.kind, ParamKind::Body)
                                    || (*name != &collection_param
                                        && *name != &_binder_param
                                        && matches!(info.ty, TypeExpr::Base(_)))
                            })
                            .map(|(name, _)| name.clone())
                            .unwrap_or_else(|| "p".to_string());

                        // Map closure params to zip operands
                        let mut param_map: std::collections::HashMap<String, &syn::Ident> =
                            std::collections::HashMap::new();
                        if params.len() >= 2 {
                            param_map.insert(params[0].to_string(), left);
                            param_map.insert(params[1].to_string(), right);
                        }

                        let mut elements: Vec<SepElement> = Vec::new();
                        let mut lalrpop_parts: Vec<String> = Vec::new();

                        for expr in body {
                            match expr {
                                SyntaxExpr::Literal(s) => {
                                    elements.push(SepElement::Literal(s.clone()));
                                    lalrpop_parts.push(format!("\"{}\"", s));
                                },
                                SyntaxExpr::Param(id) => {
                                    let name = id.to_string();
                                    if let Some(&orig_param) = param_map.get(&name) {
                                        let orig_name = orig_param.to_string();
                                        if let Some(info) = param_types.get(&orig_name) {
                                            let (lalrpop, elem) = match info.kind {
                                                ParamKind::MultiBinder => (
                                                    "Ident".to_string(),
                                                    SepElement::BinderCapture(name),
                                                ),
                                                _ => {
                                                    let nt = type_to_nonterminal(&info.ty);
                                                    (nt.clone(), SepElement::CollectionCapture(nt))
                                                },
                                            };
                                            elements.push(elem);
                                            lalrpop_parts.push(lalrpop);
                                        }
                                    }
                                },
                                _ => {},
                            }
                        }

                        let inner_pattern = lalrpop_parts.join(" ");
                        pattern_parts.push(format!(
                            "<__pairs_v:(({}) \"{}\")*> <__pair_e:({})?>",
                            inner_pattern, separator, inner_pattern
                        ));

                        *multi_binder = Some((collection_param, body_param, elements));
                        return;
                    } else {
                        // Map without Zip: ns.#map(|n| n "!").#sep(",")
                        // Single collection map - transform each element

                        // The map source should be a Var referencing the collection
                        let coll_name = match map_source.as_ref() {
                            PatternOp::Var(id) => id.to_string(),
                            _ => {
                                panic!("Map source should be a variable reference to a collection")
                            },
                        };

                        // Get collection info
                        let coll_info = param_types
                            .get(&coll_name)
                            .expect("Map source collection not found in params");
                        let coll_type =
                            if let TypeExpr::Collection { coll_type, .. } = &coll_info.ty {
                                coll_type.clone()
                            } else {
                                panic!("Map source must be a collection type");
                            };

                        // Build the inner pattern from map body
                        // params[0] maps to the collection element
                        let elem_param = if !params.is_empty() {
                            params[0].to_string()
                        } else {
                            "x".to_string()
                        };

                        let mut lalrpop_parts: Vec<String> = Vec::new();
                        let mut elem_index: Option<usize> = None;
                        let mut tuple_len = 0;

                        for expr in body {
                            match expr {
                                SyntaxExpr::Literal(s) => {
                                    lalrpop_parts.push(format!("\"{}\"", s));
                                    tuple_len += 1;
                                },
                                SyntaxExpr::Param(id) => {
                                    let name = id.to_string();
                                    if name == elem_param {
                                        // This is the collection element - track its position
                                        elem_index = Some(tuple_len);
                                        if let TypeExpr::Collection { element, .. } = &coll_info.ty
                                        {
                                            let nt = type_to_nonterminal(element);
                                            lalrpop_parts.push(nt);
                                        }
                                    }
                                    tuple_len += 1;
                                },
                                _ => {},
                            }
                        }

                        let inner_pattern = lalrpop_parts.join(" ");
                        pattern_parts.push(format!(
                            "<{}_v:(({}) \"{}\")*> <{}_e:({})?>",
                            coll_name, inner_pattern, separator, coll_name, inner_pattern
                        ));

                        // Track as mapped collection with element index
                        let mapped_info = elem_index.map(|idx| (idx, tuple_len));
                        collection_params.push((coll_name.clone(), coll_type, mapped_info));
                        captures.push(Capture {
                            var_name: coll_name,
                            nonterminal: "mapped".to_string(),
                            usage: CaptureUsage::Direct,
                        });

                        return;
                    }
                }
            }

            // Simple collection separator: ps.#sep("|")
            let name = collection.to_string();
            if let Some(info) = param_types.get(&name) {
                if let TypeExpr::Collection { element, coll_type } = &info.ty {
                    let elem_type = type_to_nonterminal(element);
                    pattern_parts.push(format!(
                        "<{}_v:(<{}> \"{}\")*> <{}_e:{}?>",
                        name, elem_type, separator, name, elem_type
                    ));
                    // Track collection param for action generation (None = not mapped)
                    collection_params.push((name.clone(), coll_type.clone(), None));
                    captures.push(Capture {
                        var_name: name,
                        nonterminal: elem_type,
                        usage: CaptureUsage::Direct,
                    });
                }
            }
        },
        PatternOp::Var(id) => {
            let name = id.to_string();
            if let Some(info) = param_types.get(&name) {
                let nonterminal = type_to_nonterminal(&info.ty);
                pattern_parts.push(format!("<{}:{}>", name, nonterminal));
                captures.push(Capture {
                    var_name: name,
                    nonterminal,
                    usage: CaptureUsage::Direct,
                });
            }
        },
        PatternOp::Zip { .. } | PatternOp::Map { .. } => {
            // Standalone Zip/Map not yet supported
            // Currently supported:
            //   - collection.#sep(",") - simple separated list
            //   - #zip(a,b).#map(|x,y| ...).#sep(",") - multi-binder pattern
            // Not yet implemented:
            //   - collection.#map(|x| ...).#sep(",") - single collection map
            panic!("Standalone PatternOp::Zip/Map not supported - chain with #sep() or use simple collection.#sep()")
        },
        PatternOp::Opt { inner } => {
            let mut inner_parts = Vec::new();
            for expr in inner {
                analyze_syntax_expr(
                    expr,
                    param_types,
                    &mut inner_parts,
                    captures,
                    &mut None,
                    &mut None,
                    &mut None,
                );
            }
            pattern_parts.push(format!("({})?", inner_parts.join(" ")));
        },
    }
}

//==============================================================================
// UNIFIED ACTION GENERATION
//==============================================================================

/// Generate action code from an AnalyzedRule
fn generate_action(analyzed: &AnalyzedRule, category: &syn::Ident, label: &syn::Ident) -> String {
    match &analyzed.action_kind {
        ActionKind::Unit => {
            format!("{}::{}", category, label)
        },
        ActionKind::Simple => {
            let args: Vec<String> = analyzed.captures.iter().map(capture_to_arg).collect();
            format!("{}::{}({})", category, label, args.join(", "))
        },
        ActionKind::Binder { binder_var, body_var } => {
            generate_binder_action(&analyzed.captures, binder_var, body_var, category, label)
        },
        ActionKind::MultiBinder { collection_param, body_param, elements } => {
            let mut action = "{\n".to_string();
            action.push_str(&generate_multi_binder_action(collection_param, body_param, elements));
            action.push_str(&format!(
                "        {}::{}({}, __scope)\n",
                category, label, collection_param
            ));
            action.push_str("    }");
            action
        },
        ActionKind::Collection { name, coll_type, .. } => {
            generate_collection_action(name, coll_type)
        },
        ActionKind::SimpleWithCollections { collections } => {
            let mut action = "{\n".to_string();
            // Generate code to combine _v and _e captures into collections
            for (coll_name, coll_type, mapped_info) in collections {
                let coll_type_name = match coll_type {
                    CollectionType::HashBag => "HashBag",
                    CollectionType::HashSet => "HashSet",
                    CollectionType::Vec => "Vec",
                };

                // Generate extraction code based on whether it's a mapped collection
                let (extract_item, extract_opt) = if let Some((elem_idx, tuple_len)) = mapped_info {
                    // Mapped collection - need to destructure tuple
                    // LALRPOP pattern ((inner_tuple) sep)* produces Vec<(tuple, ())>
                    // Generate pattern like (_, elem, _) or (elem, _) etc.
                    let mut pattern_parts: Vec<&str> = vec!["_"; *tuple_len];
                    pattern_parts[*elem_idx] = "elem";
                    let pattern = pattern_parts.join(", ");

                    let op = if coll_type_name == "Vec" {
                        "push"
                    } else {
                        "insert"
                    };
                    let v_extract = format!(
                        "for (({pattern}), _) in {name}_v {{ {name}.{op}(elem); }}",
                        pattern = pattern,
                        name = coll_name,
                        op = op
                    );
                    let e_extract = format!(
                        "if let Some(({pattern})) = {name}_e {{ {name}.{op}(elem); }}",
                        pattern = pattern,
                        name = coll_name,
                        op = op
                    );
                    (v_extract, e_extract)
                } else {
                    // Simple collection - LALRPOP (<Elem> "sep")* produces Vec<Elem> (sep not captured)
                    let op = if coll_type_name == "Vec" {
                        "push"
                    } else {
                        "insert"
                    };
                    let v_extract = format!(
                        "for item in {name}_v {{ {name}.{op}(item); }}",
                        name = coll_name,
                        op = op
                    );
                    let e_extract = format!(
                        "if let Some(item) = {name}_e {{ {name}.{op}(item); }}",
                        name = coll_name,
                        op = op
                    );
                    (v_extract, e_extract)
                };

                action.push_str(&format!(
                    "        let mut {name} = {coll_type}::new();\n\
                     {extract_v}\n\
                     {extract_e}\n",
                    name = coll_name,
                    coll_type = coll_type_name,
                    extract_v = extract_item,
                    extract_e = extract_opt
                ));
            }
            // Build constructor args, using collection names directly
            #[allow(clippy::unnecessary_filter_map)]
            let args: Vec<String> = analyzed
                .captures
                .iter()
                .filter_map(|c| {
                    // Skip captures that are from _v/_e split (they're handled above)
                    let is_collection = collections.iter().any(|(n, _, _)| n == &c.var_name);
                    if is_collection {
                        Some(c.var_name.clone())
                    } else {
                        Some(capture_to_arg(c))
                    }
                })
                .collect();
            action.push_str(&format!("        {}::{}({})\n", category, label, args.join(", ")));
            action.push_str("    }");
            action
        },
    }
}

/// Convert a capture to its action code representation
fn capture_to_arg(capture: &Capture) -> String {
    match &capture.usage {
        CaptureUsage::Boxed => format!("Box::new({})", capture.var_name),
        CaptureUsage::Direct => {
            // StringLiteral (std::string::String) may be passed by ref when reducing; clone to avoid move
            if capture.nonterminal == "StringLiteral" {
                format!("{}.clone()", capture.var_name)
            } else {
                capture.var_name.clone()
            }
        },
        CaptureUsage::AsVar => {
            // Ident is std::string::String; LALRPOP may pass by ref when reducing - clone to avoid move
            format!(
                "mettail_runtime::OrdVar(mettail_runtime::Var::Free(mettail_runtime::get_or_create_var({}.clone())))",
                capture.var_name
            )
        },
        CaptureUsage::Binder | CaptureUsage::Body => capture.var_name.clone(),
    }
}

/// Generate action code for binder rules
fn generate_binder_action(
    captures: &[Capture],
    binder_var: &str,
    body_var: &str,
    category: &syn::Ident,
    label: &syn::Ident,
) -> String {
    let mut action = "{\n".to_string();
    action.push_str("        use mettail_runtime::BoundTerm;\n");
    action.push_str(&format!("        let free_vars = {}.free_vars();\n", body_var));
    action.push_str(&format!(
        "        let binder = if let Some(fv) = free_vars.iter().find(|fv| fv.pretty_name.as_deref() == Some(&{})) {{\n",
        binder_var
    ));
    action.push_str("            Binder((*fv).clone())\n");
    action.push_str("        } else {\n");
    action.push_str(&format!(
        "            Binder(mettail_runtime::get_or_create_var({}))\n",
        binder_var
    ));
    action.push_str("        };\n");
    action.push_str(&format!("        let scope = Scope::new(binder, Box::new({}));\n", body_var));

    // Build constructor call with regular args + scope
    let mut all_args: Vec<String> = captures
        .iter()
        .filter(|c| c.var_name != binder_var && c.var_name != body_var)
        .map(capture_to_arg)
        .collect();
    all_args.push("scope".to_string());

    action.push_str(&format!("        {}::{}({})\n", category, label, all_args.join(", ")));
    action.push_str("    }");
    action
}

/// Generate action code for collection rules
fn generate_collection_action(name: &str, coll_type: &CollectionType) -> String {
    let coll_constructor = match coll_type {
        CollectionType::HashBag => "mettail_runtime::HashBag",
        CollectionType::HashSet => "std::collections::HashSet",
        CollectionType::Vec => "Vec",
    };

    let mut action = "{\n".to_string();
    action.push_str(&format!("        let mut {} = {}::new();\n", name, coll_constructor));

    // For delimited collections (elems + last pattern)
    let insert_method = match coll_type {
        CollectionType::HashBag | CollectionType::HashSet => "insert",
        CollectionType::Vec => "push",
    };

    action.push_str(&format!("        for e in elems {{ {}.{}(e); }}\n", name, insert_method));
    action
        .push_str(&format!("        if let Some(e) = last {{ {}.{}(e); }}\n", name, insert_method));
    action.push_str(&format!("        {}\n", name));
    action.push_str("    }");
    action
}

//==============================================================================
// UNIFIED ALTERNATIVE GENERATION
//==============================================================================

/// Generate a complete LALRPOP alternative from an AnalyzedRule
fn generate_alternative(
    analyzed: &AnalyzedRule,
    category: &syn::Ident,
    label: &syn::Ident,
) -> String {
    let action = generate_action(analyzed, category, label);
    format!("{} => {}", analyzed.pattern, action)
}

//==============================================================================
// LEGACY ACTION GENERATION (to be removed after migration)
//==============================================================================

/// Generate action code for multi-binder patterns
///
/// Handles tuple destructuring from __pairs_v and __pair_e captures
fn generate_multi_binder_action(
    collection_param: &str,
    body_param: &str,
    elements: &[SepElement],
) -> String {
    let mut action = String::new();

    // Generate tuple destructuring pattern from elements
    let mut tuple_vars = Vec::new();
    let mut binder_indices = Vec::new();
    let mut coll_indices = Vec::new();

    for (i, elem) in elements.iter().enumerate() {
        match elem {
            SepElement::Literal(_) => {
                tuple_vars.push("_".to_string());
            },
            SepElement::BinderCapture(_) => {
                tuple_vars.push(format!("__e{}", i));
                binder_indices.push(i);
            },
            SepElement::CollectionCapture(_) => {
                tuple_vars.push(format!("__e{}", i));
                coll_indices.push(i);
            },
        }
    }

    let tuple_pattern = tuple_vars.join(", ");

    // Generate push statements
    let binder_pushes: Vec<String> = binder_indices
        .iter()
        .map(|i| format!("__binder_strs.push(__e{});", i))
        .collect();
    let coll_pushes: Vec<String> = coll_indices
        .iter()
        .map(|i| format!("{}.push(__e{});", collection_param, i))
        .collect();

    // Initialize collections
    action.push_str(&format!(
        "        let mut {} = Vec::new();\n\
         let mut __binder_strs = Vec::new();\n",
        collection_param
    ));

    // Process __pairs_v (with separator)
    action.push_str(&format!("        for (({}), _) in __pairs_v {{\n", tuple_pattern));
    for push in &binder_pushes {
        action.push_str(&format!("             {}\n", push));
    }
    for push in &coll_pushes {
        action.push_str(&format!("             {}\n", push));
    }
    action.push_str("        }\n");

    // Process __pair_e (without separator)
    action.push_str(&format!("        if let Some(({tuple_pattern})) = __pair_e {{\n"));
    for push in &binder_pushes {
        action.push_str(&format!("             {}\n", push));
    }
    for push in &coll_pushes {
        action.push_str(&format!("             {}\n", push));
    }
    action.push_str("        }\n");

    // Create binders from strings
    action.push_str(
        "        let __binders: Vec<Binder<String>> = __binder_strs.into_iter()\n\
         .map(|s| Binder(mettail_runtime::get_or_create_var(s)))\n\
         .collect();\n",
    );

    // Create the multi-binder scope
    action.push_str(&format!(
        "        let __scope = Scope::new(__binders, Box::new({}));\n",
        body_param
    ));

    action
}

/// Generate auto-generated alternatives (Var and literal rules)
///
/// This extracts the duplicated code from generate_tiered_production and generate_simple_production
fn generate_auto_alternatives(
    category: &syn::Ident,
    has_var_rule: bool,
    has_integer_rule: bool,
    language: &LanguageDef,
    needs_leading_comma: bool,
) -> String {
    let cat_str = category.to_string();
    let mut result = String::new();
    let mut needs_comma = needs_leading_comma;

    // Auto-generate literal parser for native types (if not explicitly declared)
    if let Some(native_type) = has_native_type(category, language) {
        let type_str = native_type_to_string(native_type);
        if !has_integer_rule {
            let literal_label = generate_literal_label(native_type);

            if needs_comma {
                result.push_str(",\n");
            }

            if type_str == "i32" || type_str == "i64" {
                // Add unary minus support for negative numbers
                result.push_str(&format!(
                    "    \"-\" <i:Integer> => {}::{}(-i),\n",
                    cat_str, literal_label
                ));
                result.push_str(&format!("    <i:Integer> => {}::{}(i)", cat_str, literal_label));
            } else if type_str == "f32" || type_str == "f64" {
                result.push_str(&format!("    <f:FloatLiteral> => {}::{}(f)", cat_str, literal_label));
            } else if type_str == "bool" {
                result.push_str(&format!("    <b:Boolean> => {}::{}(b)", cat_str, literal_label));
            } else if type_str == "str" || type_str == "String" {
                // Clone to avoid "cannot move out of a shared reference" - LALRPOP may pass symbol by ref when reducing
                result.push_str(&format!("    <s:StringLiteral> => {}::{}(s.clone())", cat_str, literal_label));
            }
            needs_comma = true;
        }
    }

    // Auto-generate Var alternative if not explicitly defined.
    // When multiple categories get Var (Ident), only the first (by type order) gets bare Ident
    // to avoid reduce-reduce conflict; others use a prefix e.g. "bool:" <v:Ident>, "str:" <v:Ident>.
    if !has_var_rule {
        let categories_with_auto_var: Vec<String> = language
            .types
            .iter()
            .filter(|t| {
                !language
                    .terms
                    .iter()
                    .any(|r| r.category == t.name && is_var_rule(r))
            })
            .map(|t| t.name.to_string())
            .collect();
        let only_first_gets_bare_ident =
            categories_with_auto_var.len() <= 1
                || categories_with_auto_var
                    .first()
                    .map(|s| s.as_str())
                    == Some(cat_str.as_str());
        let var_label = generate_var_label(category);
        if needs_comma {
            result.push_str(",\n");
        } else {
            result.push('\n');
        }
        if only_first_gets_bare_ident {
            result.push_str(&format!(
                "    <v:Ident> => {}::{}(mettail_runtime::OrdVar(mettail_runtime::Var::Free(mettail_runtime::get_or_create_var(v.clone()))))",
                cat_str, var_label
            ));
        } else {
            let prefix_lit = format!("{}:", cat_str.to_string().to_lowercase());
            let prefix_escaped = prefix_lit.replace('\\', "\\\\").replace('"', "\\\"");
            result.push_str(&format!(
                "    \"{}\" <v:Ident> => {}::{}(mettail_runtime::OrdVar(mettail_runtime::Var::Free(mettail_runtime::get_or_create_var(v.clone()))))",
                prefix_escaped, cat_str, var_label
            ));
        }
        needs_comma = true;
    }

    // Auto-generate lambda alternatives
    // ONLY for the FIRST (primary) exported category to avoid grammar ambiguity
    // Other categories can still have lambda VARIANTS but no parser rules
    let first_export = language
        .types
        .iter()
        .find(|t| t.native_type.is_none())
        .map(|t| &t.name);

    // Only add lambda parser rules if this is the primary category
    let is_primary_category = first_export.map(|f| f == category).unwrap_or(false);

    if is_primary_category {
        // Get all non-native categories for the match arms
        let domain_cats: Vec<_> = language
            .types
            .iter()
            .filter(|t| t.native_type.is_none())
            .map(|t| &t.name)
            .collect();

        if !domain_cats.is_empty() {
            if needs_comma {
                result.push_str(",\n");
            }

            // Generate match arms using a nested match on base_type()
            // This ensures exhaustive pattern matching
            let base_type_arms: String = domain_cats.iter().map(|domain| {
                format!(
                    "                VarCategory::{} => {}::Lam{}(mettail_runtime::Scope::new(binder, Box::new(body))),\n",
                    domain, cat_str, domain
                )
            }).collect();

            // Single-binder lambda: ^x.{body} with type inference
            // Uses infer_var_type for full type inference (including function types)
            // and base_type() to get the representation category
            result.push_str(&format!(
                r#"    "^" <x:Ident> "." "{{" <body:{}> "}}" => {{
        let binder = mettail_runtime::Binder(mettail_runtime::get_or_create_var(x.clone()));
        // Infer binder type from usage in body (supports higher-order types)
        match body.infer_var_type(&x) {{
            Some(ref t) => match t.base_type() {{
{}            }},
            None => panic!("Lambda binder '{{}}' not used in body", x),
        }}
    }}"#,
                cat_str, base_type_arms
            ));

            // Generate match arms for multi-lambda
            let multi_base_type_arms: String = domain_cats.iter().map(|domain| {
                format!(
                    "                VarCategory::{} => {}::MLam{}(mettail_runtime::Scope::new(binders, Box::new(body))),\n",
                    domain, cat_str, domain
                )
            }).collect();

            // Multi-binder lambda: ^[x,y,z].{body}
            result.push_str(",\n");
            result.push_str(&format!(
                r#"    "^" "[" <xs:Comma<Ident>> "]" "." "{{" <body:{}> "}}" => {{
        let binder_names: Vec<_> = xs.clone();
        let binders: Vec<_> = xs.into_iter()
            .map(|x| mettail_runtime::Binder(mettail_runtime::get_or_create_var(x)))
            .collect();
        // Infer binder type from first binder's usage in body
        let first_binder = binder_names.first().expect("Multi-lambda needs at least one binder");
        match body.infer_var_type(first_binder) {{
            Some(ref t) => match t.base_type() {{
{}            }},
            None => panic!("Lambda binder '{{}}' not used in body", first_binder),
        }}
    }}"#,
                cat_str, multi_base_type_arms
            ));

            // Lambda application: $Domain(lam, arg) - explicit typed application syntax
            // Uses $ prefix with domain type to avoid grammar ambiguity
            // Beta reduction happens during Ascent evaluation
            for domain in &domain_cats {
                let domain_lower = domain.to_string().to_lowercase();
                result.push_str(",\n");
                result.push_str(&format!(
                    r#"    "${}" "(" <lam:{}> "," <arg:{}> ")" => {{
        {}::Apply{}(Box::new(lam), Box::new(arg))
    }}"#,
                    domain_lower, cat_str, domain, cat_str, domain
                ));
            }

            // Multi-lambda application: $$Domain(mlam, arg1, arg2, ...)
            for domain in &domain_cats {
                let domain_lower = domain.to_string().to_lowercase();
                result.push_str(",\n");
                result.push_str(&format!(
                    r#"    "$${}(" <lam:{}> "," <args:Comma<{}>> ")" => {{
        {}::MApply{}(Box::new(lam), args)
    }}"#,
                    domain_lower, cat_str, domain, cat_str, domain
                ));
            }
        }
    }

    result
}

//==============================================================================
// HELPER STRUCTURES FOR PATTERN ANALYSIS
//==============================================================================

/// Helper enum for parameter kinds
#[derive(Debug, Clone)]
enum ParamKind {
    Simple,
    Binder,
    MultiBinder,
    Body,
    Collection,
}

/// Helper struct for parameter info
#[derive(Debug, Clone)]
struct ParamInfo {
    kind: ParamKind,
    ty: TypeExpr,
}

/// Build param_types map from term context
fn build_param_types(term_context: &[TermParam]) -> std::collections::HashMap<String, ParamInfo> {
    let mut param_types = std::collections::HashMap::new();

    for param in term_context {
        match param {
            TermParam::Simple { name, ty } => {
                let kind = if matches!(ty, TypeExpr::Collection { .. }) {
                    ParamKind::Collection
                } else {
                    ParamKind::Simple
                };
                param_types.insert(name.to_string(), ParamInfo { kind, ty: ty.clone() });
            },
            TermParam::Abstraction { binder, body, ty } => {
                // Binder is captured as identifier
                param_types.insert(
                    binder.to_string(),
                    ParamInfo { kind: ParamKind::Binder, ty: ty.clone() },
                );
                // Body is the codomain type
                if let TypeExpr::Arrow { codomain, .. } = ty {
                    param_types.insert(
                        body.to_string(),
                        ParamInfo {
                            kind: ParamKind::Body,
                            ty: (**codomain).clone(),
                        },
                    );
                }
            },
            TermParam::MultiAbstraction { binder, body, ty } => {
                // Multi-binder is captured as multiple identifiers
                param_types.insert(
                    binder.to_string(),
                    ParamInfo {
                        kind: ParamKind::MultiBinder,
                        ty: ty.clone(),
                    },
                );
                // Body is the codomain type
                if let TypeExpr::Arrow { codomain, .. } = ty {
                    param_types.insert(
                        body.to_string(),
                        ParamInfo {
                            kind: ParamKind::Body,
                            ty: (**codomain).clone(),
                        },
                    );
                }
            },
        }
    }

    param_types
}

/// Convert a TypeExpr to a LALRPOP non-terminal name
fn type_to_nonterminal(ty: &TypeExpr) -> String {
    match ty {
        TypeExpr::Base(id) => id.to_string(),
        TypeExpr::Collection { element, .. } => {
            // Collections need special handling
            type_to_nonterminal(element)
        },
        _ => "UNKNOWN".to_string(),
    }
}

/// Generate alternative for a collection constructor
///
/// Generates LALRPOP rules for separated lists with optional delimiters.
/// Examples:
/// - `a | b | c` (no delimiters)
/// - `[a, b, c]` (with delimiters)
/// - `[]` (empty collection)
fn generate_collection_alternative(
    rule: &GrammarRule,
    coll_type: &CollectionType,
    element_type: &syn::Ident,
    separator: &str,
    delimiters: Option<&(String, String)>,
) -> String {
    let label = &rule.label;
    let category = &rule.category;

    // Escape separator for LALRPOP
    // Special handling for "|" which has meaning in LALRPOP grammar syntax
    let sep_escaped = if separator == "|" {
        r"\|".to_string()
    } else {
        separator.replace("\"", "\\\"")
    };

    // Determine if we need to use regex pattern (for special chars like |)
    let sep_pattern = if separator == "|" {
        format!("r\"{}\"", sep_escaped)
    } else {
        format!("\"{}\"", sep_escaped)
    };

    // Determine the collection type constructor
    let coll_constructor = match coll_type {
        CollectionType::HashBag => "mettail_runtime::HashBag",
        CollectionType::HashSet => "std::collections::HashSet",
        CollectionType::Vec => "Vec",
    };

    // Build the pattern
    // For separated lists, we use: <elems:(<Elem> "sep")*> <last:Elem?>
    // This allows optional trailing separator
    let mut pattern = String::new();

    if let Some((open, close)) = delimiters {
        // With delimiters: `{` <elems> `}`
        // LALRPOP syntax: (X Y)* creates Vec<(X,Y)>, but (<X> Y)* creates Vec<X>
        // LALRPOP automatically handles whitespace between tokens
        let open_escaped = open.replace("\"", "\\\"");
        let close_escaped = close.replace("\"", "\\\"");
        pattern.push_str(&format!("\"{}\" ", open_escaped));
        // Capture just the element, discard the separator
        pattern.push_str(&format!("<elems:(<{}> {})*> ", element_type, sep_pattern));
        pattern.push_str(&format!("<last:{}?> ", element_type));
        pattern.push_str(&format!("\"{}\"", close_escaped));
    } else {
        // Without delimiters: just the separated list
        // Use <> to only capture the element, not the separator
        // LALRPOP automatically handles whitespace between tokens
        pattern.push_str(&format!("<first:{}> ", element_type));
        pattern.push_str(&format!("<rest:({} <{}>)*>", sep_pattern, element_type));
    }

    // Build the action
    let mut action = String::from(" => {\n");
    action.push_str(&format!("        let mut coll = {}::new();\n", coll_constructor));

    if delimiters.is_some() {
        // With delimiters: use elems and last pattern
        action.push_str("        for e in elems {\n");
        match coll_type {
            CollectionType::HashBag => {
                action.push_str("            coll.insert(e);\n");
            },
            CollectionType::HashSet => {
                action.push_str("            coll.insert(e);\n");
            },
            CollectionType::Vec => {
                action.push_str("            coll.push(e);\n");
            },
        }
        action.push_str("        }\n");
        action.push_str("        if let Some(e) = last {\n");
        match coll_type {
            CollectionType::HashBag => {
                action.push_str("            coll.insert(e);\n");
            },
            CollectionType::HashSet => {
                action.push_str("            coll.insert(e);\n");
            },
            CollectionType::Vec => {
                action.push_str("            coll.push(e);\n");
            },
        }
        action.push_str("        }\n");
    } else {
        // Without delimiters: use first and rest pattern
        match coll_type {
            CollectionType::HashBag => {
                action.push_str("        coll.insert(first);\n");
                action.push_str("        for e in rest {\n");
                action.push_str("            coll.insert(e);\n");
                action.push_str("        }\n");
            },
            CollectionType::HashSet => {
                action.push_str("        coll.insert(first);\n");
                action.push_str("        for e in rest {\n");
                action.push_str("            coll.insert(e);\n");
                action.push_str("        }\n");
            },
            CollectionType::Vec => {
                action.push_str("        coll.push(first);\n");
                action.push_str("        for e in rest {\n");
                action.push_str("            coll.push(e);\n");
                action.push_str("        }\n");
            },
        }
    }

    action.push_str(&format!("        {}::{}(coll)\n", category, label));
    action.push_str("    }");

    format!("{}{}", pattern.trim(), action)
}

// LALRPOP grammar generation for MeTTaIL theories
//
// This module generates `.lalrpop` grammar files from theory definitions.
// The generated grammars parse text into the AST types generated by codegen.rs

#![allow(clippy::cmp_owned, clippy::useless_format)]

use crate::ast::{theory::{TheoryDef, Export}, grammar::{GrammarItem, GrammarRule, TermParam}, syntax::{SyntaxExpr, PatternOp}, types::{TypeExpr, CollectionType}};
use crate::codegen::{generate_literal_label, is_integer_rule, is_var_rule};
use crate::utils::{has_native_type, native_type_to_string};

/// Generates Var label for a category (first letter + "Var")
fn generate_var_label(category: &syn::Ident) -> String {
    let cat_str = category.to_string();
    let first_letter = cat_str
        .chars()
        .next()
        .unwrap_or('V')
        .to_uppercase()
        .collect::<String>();
    format!("{}Var", first_letter)
}

/// Generate token parser for native type if needed
fn generate_native_type_tokens(theory: &TheoryDef) -> String {
    let mut tokens = String::new();

    // Check all exports for native types and generate appropriate token parsers
    for export in &theory.exports {
        if let Some(ref native_type) = export.native_type {
            let type_str = native_type_to_string(native_type);

            // Generate token parser based on native type
            if type_str == "i32" || type_str == "i64" {
                tokens.push_str(&format!("Integer: {} = {{\n", type_str));
                // Only match positive integers at token level
                // Negative integers will be handled in the grammar via unary minus
                tokens.push_str("    r\"[0-9]+\" => <>.parse().unwrap_or(0),\n");
                tokens.push_str("};\n\n");
            } else if type_str == "f32" || type_str == "f64" {
                tokens.push_str(&format!("Float: {} = {{\n", type_str));
                tokens.push_str("    r\"[0-9]+\\.[0-9]+\" => <>.parse().unwrap_or(0.0),\n");
                tokens.push_str("};\n\n");
            } else if type_str == "bool" {
                tokens.push_str("Boolean: bool = {\n");
                tokens.push_str("    \"true\" => true,\n");
                tokens.push_str("    \"false\" => false,\n");
                tokens.push_str("};\n\n");
            }
            // Add more native types as needed
        }
    }

    tokens
}

/// Generate a LALRPOP grammar file content for a theory
///
/// This produces the text content of a `.lalrpop` file that can parse
/// the theory's syntax into its AST types.
pub fn generate_lalrpop_grammar(theory: &TheoryDef) -> String {
    let theory_name = &theory.name;

    let mut grammar = String::new();

    // Add header
    grammar.push_str(&format!("// Generated LALRPOP grammar for theory: {}\n", theory_name));
    grammar.push_str("// This file is auto-generated - do not edit manually\n\n");

    // Add use statements for runtime helpers. Only include what's needed
    let has_binders = theory.terms.iter().any(|r| !r.bindings.is_empty());

    // Check if any category needs Var (i.e., has non-native exports OR has Var rules)
    let needs_var = theory.exports.iter().any(|e| e.native_type.is_none())
        || theory.terms.iter().any(is_var_rule);

    // Check if any term uses HashBag collections (for #sep)
    let needs_hashbag = theory.terms.iter().any(|r| {
        r.term_context.as_ref().map_or(false, |ctx| {
            ctx.iter().any(|param| matches!(param, TermParam::Simple { ty: TypeExpr::Collection { coll_type: CollectionType::HashBag, .. }, .. }))
        })
    });

    // Build the runtime imports
    let mut imports = Vec::new();
    if needs_var { imports.push("Var"); }
    if has_binders { imports.push("Binder"); imports.push("Scope"); }
    if needs_hashbag { imports.push("HashBag"); }
    
    if !imports.is_empty() {
        grammar.push_str(&format!("use mettail_runtime::{{{}}};\n", imports.join(", ")));
    }

    // Import the AST types from the crate where the theory is defined
    // When used in test modules, this will be super::{...}
    // When used in library modules, LALRPOP will handle the paths correctly
    let type_names: Vec<String> = theory.exports.iter().map(|e| e.name.to_string()).collect();

    if !type_names.is_empty() {
        grammar.push_str(&format!("use super::{{{}}};\n", type_names.join(", ")));
    }

    grammar.push('\n');

    // Add grammar directive
    grammar.push_str("grammar;\n\n");

    // Add identifier token definition (needed for binders and variables)
    grammar.push_str("Ident: String = {\n");
    grammar.push_str("    r\"[a-zA-Z_][a-zA-Z0-9_]*\" => <>.to_string(),\n");
    grammar.push_str("};\n\n");

    // Generate native type token parsers if needed
    grammar.push_str(&generate_native_type_tokens(theory));

    // Generate productions for each exported category
    for export in &theory.exports {
        let cat_name = &export.name;

        // Find all rules for this category
        let rules: Vec<&GrammarRule> = theory
            .terms
            .iter()
            .filter(|r| r.category == *cat_name)
            .collect();

        // Always generate production (even if no rules, we might need Var)
        grammar.push_str(&generate_category_production(cat_name, &rules, theory));
        grammar.push('\n');
    }

    grammar
}

/// Check if a rule starts with Var followed by a terminal (e.g., Var "=" Int)
/// These rules need special handling to avoid ambiguity with bare VarRef rules
fn is_var_terminal_rule(rule: &GrammarRule) -> bool {
    rule.items.len() >= 2
        && matches!(&rule.items[0], GrammarItem::NonTerminal(nt) if nt.to_string() == "Var")
        && matches!(&rule.items[1], GrammarItem::Terminal(_))
}

/// Generate a LALRPOP production for a category
///
/// This handles precedence by creating tiered rules for infix operators
fn generate_category_production(
    category: &syn::Ident,
    rules: &[&GrammarRule],
    theory: &TheoryDef,
) -> String {
    let _cat_str = category.to_string();

    // Checks if there's already a Var rule
    let has_var_rule = rules.iter().any(|r| is_var_rule(r));

    // Separate rules that start with Var+terminal (need special handling for ambiguity)
    let (var_terminal_rules, non_var_terminal_rules): (Vec<&GrammarRule>, Vec<&GrammarRule>) =
        rules.iter().copied().partition(|r| is_var_terminal_rule(r));

    // Classify remaining rules by type
    let (infix_rules, other_rules): (Vec<&GrammarRule>, Vec<&GrammarRule>) = non_var_terminal_rules
        .iter()
        .copied()
        .partition(|r| is_infix_rule(r));

    // If we have infix operators or var+terminal rules, generate tiered rules for precedence
    if !infix_rules.is_empty() || !var_terminal_rules.is_empty() {
        generate_tiered_production(
            category,
            &infix_rules,
            &other_rules,
            &var_terminal_rules,
            has_var_rule,
            theory,
        )
    } else {
        // No infix operators - generate simple production
        generate_simple_production(category, &other_rules, has_var_rule, theory)
    }
}

/// Check if a rule is an infix operator (e.g., Proc ::= Proc "|" Proc)
fn is_infix_rule(rule: &GrammarRule) -> bool {
    // An infix rule has the pattern: NonTerm (Terminal | NonTerm)+ NonTerm
    // where the first and last non-terminals are the same as the rule's category
    if rule.items.len() < 3 {
        return false;
    }

    // Check if first item is the same category
    let first_match = matches!(&rule.items[0],
        GrammarItem::NonTerminal(nt) if nt == &rule.category);

    // Check if last item is the same category
    let last_match = matches!(rule.items.last(),
        Some(GrammarItem::NonTerminal(nt)) if nt == &rule.category);

    // Check if there's a terminal in the middle (the operator)
    let has_terminal = rule.items[1..rule.items.len() - 1]
        .iter()
        .any(|item| matches!(item, GrammarItem::Terminal(_)));

    first_match && last_match && has_terminal
}

/// Generate tiered production for handling precedence
fn generate_tiered_production(
    category: &syn::Ident,
    infix_rules: &[&GrammarRule],
    other_rules: &[&GrammarRule],
    var_terminal_rules: &[&GrammarRule],
    has_var_rule: bool,
    theory: &TheoryDef,
) -> String {
    let cat_str = category.to_string();
    let mut production = String::new();

    // Top-level rule: handle var+terminal rules first (most specific), then delegate to infix
    production.push_str(&format!("pub {}: {} = {{\n", cat_str, cat_str));

    // Add var+terminal rules at top level (highest specificity - tried first)
    if !var_terminal_rules.is_empty() {
        for rule in var_terminal_rules.iter() {
            production.push_str("    ");
            production.push_str(&generate_var_terminal_alternative(rule, &cat_str));
            production.push_str(",\n");
        }
    }

    // Then delegate to infix tier
    production.push_str(&format!("    <{}Infix>\n", cat_str));
    production.push_str("};\n\n");

    // Infix tier - handles left-associative operators
    production.push_str(&format!("{}Infix: {} = {{\n", cat_str, cat_str));

    // Generate left-recursive rules for infix operators
    for rule in infix_rules.iter() {
        production.push_str("    ");
        production.push_str(&generate_infix_alternative(rule, &cat_str));
        production.push_str(",\n");
    }

    // Base case - delegate to atom tier
    production.push_str(&format!("    <{}Atom>\n", cat_str));
    production.push_str("};\n\n");

    // Atom tier - handles non-infix constructs and parentheses
    production.push_str(&format!("{}Atom: {} = {{\n", cat_str, cat_str));

    // Add parenthesized expressions - reference the top-level rule
    production.push_str(&format!("    \"(\" <{}> \")\",\n", cat_str));

    // Filter out var+terminal rules from other_rules (they're handled at top level)
    let filtered_other_rules: Vec<&GrammarRule> = other_rules
        .iter()
        .filter(|r| !is_var_terminal_rule(r))
        .copied()
        .collect();

    // Add unary minus support for native integer types (before other rules for precedence)
    if let Some(native_type) = has_native_type(category, theory) {
        let type_str = native_type_to_string(native_type);
        if type_str == "i32" || type_str == "i64" {
            // Find the Integer rule (for integer literals)
            if let Some(integer_rule) = filtered_other_rules.iter().find(|r| is_integer_rule(r)) {
                let integer_label = integer_rule.label.to_string();
                production.push_str(&format!(
                    "    \"-\" <i:Integer> => {}::{}(-i),\n",
                    cat_str, integer_label
                ));
            }
        }
    }

    // Add non-infix rules (excluding var+terminal rules, which are handled at top level)
    for (i, rule) in filtered_other_rules.iter().enumerate() {
        production.push_str("    ");
        production.push_str(&generate_rule_alternative_with_theory(rule, Some(theory)));

        if i < filtered_other_rules.len() - 1 {
            production.push_str(",\n");
        } else {
            production.push('\n');
        }
    }

    // Check if we need to add a comma before auto-generated rules
    let mut needs_comma = !filtered_other_rules.is_empty();
    
    // Check if there's an explicit Integer rule (NumLit . Cat ::= Integer)
    let has_integer_rule = filtered_other_rules.iter().any(|r| is_integer_rule(r));

    // Auto-generate literal parser for native types (if not explicitly declared)
    if let Some(native_type) = has_native_type(category, theory) {
        let type_str = native_type_to_string(native_type);
        if !has_integer_rule {
            let literal_label = generate_literal_label(native_type);

            if needs_comma {
                production.push_str(",\n");
            }

            if type_str == "i32" || type_str == "i64" {
                // Integer literals: parse Integer token
                // Add unary minus support for negative numbers (before positive literals for precedence)
                production.push_str(&format!(
                    "    \"-\" <i:Integer> => {}::{}(-i),\n",
                    cat_str, literal_label
                ));
                production
                    .push_str(&format!("    <i:Integer> => {}::{}(i)", cat_str, literal_label));
            } else if type_str == "f32" || type_str == "f64" {
                // Float literals: parse Float token
                production
                    .push_str(&format!("    <f:Float> => {}::{}(f)", cat_str, literal_label));
            } else if type_str == "bool" {
                // Boolean literals: parse Boolean token
                production
                    .push_str(&format!("    <b:Boolean> => {}::{}(b)", cat_str, literal_label));
            }
            needs_comma = true; // Next rule (Var) needs comma
        }
    }

    // Automatically adds Var alternative if it doesn't exist (lowest precedence)
    // Variables always parse as Ident (not Integer), regardless of native type
    // Integer literals are handled separately via NumLit/Integer rules
    if !has_var_rule {
        let var_label = generate_var_label(category);
        // Variables always parse as Ident (not Integer)
        if needs_comma {
            production.push_str(",\n");
        } else {
            production.push('\n');
        }
        production.push_str(&format!(
            "    <v:Ident> => {}::{}(mettail_runtime::OrdVar(mettail_runtime::Var::Free(mettail_runtime::get_or_create_var(v))))",
            cat_str, var_label
        ));
    }

    production.push_str("\n};\n");
    production
}

/// Generate alternative for infix operator (left-associative)
fn generate_infix_alternative(rule: &GrammarRule, cat_str: &str) -> String {
    let label = &rule.label;
    let category = &rule.category;

    // Pattern: <left:Cat> "op" <right:CatAtom>
    // This ensures left-associativity
    let mut pattern = format!("<left:{}Infix>", cat_str);

    // Process items to find operator and right operand
    for (i, item) in rule.items.iter().enumerate() {
        if i == 0 {
            continue; // Skip first (it's the left operand)
        }

        match item {
            GrammarItem::Terminal(term) => {
                pattern.push_str(&format!(" \"{}\"", term));
            },
            GrammarItem::NonTerminal(nt) if nt == category && i == rule.items.len() - 1 => {
                // Last item - use Atom tier to avoid ambiguity
                pattern.push_str(&format!(" <right:{}Atom>", cat_str));
            },
            GrammarItem::NonTerminal(nt) if nt == category => {
                // Middle recursive reference - shouldn't happen in binary infix
                pattern.push_str(&format!(" <mid{}>", i));
            },
            GrammarItem::NonTerminal(_) => {
                pattern.push_str(&format!(" <f{}>", i));
            },
            GrammarItem::Collection { .. } => {
                // Collections in infix operators not yet supported (Phase 4)
                panic!("Collection types in infix operators not yet implemented (Phase 4)");
            },
            GrammarItem::Binder { .. } => {
                // Binders in infix operators - unusual but handle it
                pattern.push_str(&format!(" <x_{}>", i));
            },
        }
    }

    // Generate action
    let action = format!(" => {}::{}(Box::new(left), Box::new(right))", category, label);

    format!("{}{}", pattern, action)
}

/// Generate alternative for rules starting with Var followed by terminal (e.g., Var "=" Int)
/// These rules use CatInfix for recursive references to avoid ambiguity with the top-level rule
fn generate_var_terminal_alternative(rule: &GrammarRule, cat_str: &str) -> String {
    let label = &rule.label;
    let category = &rule.category;

    let mut pattern = String::new();
    let mut args = Vec::new();
    let mut field_idx = 0;

    for item in &rule.items {
        match item {
            GrammarItem::Terminal(term) => {
                pattern.push_str(&format!(" \"{}\"", term));
            },
            GrammarItem::NonTerminal(nt) => {
                let var_name = format!("f{}", field_idx);

                if nt.to_string() == "Var" {
                    // Var should parse as Ident, then convert to OrdVar
                    pattern.push_str(&format!(" <{}:Ident>", var_name));
                    args.push(format!("mettail_runtime::OrdVar(mettail_runtime::Var::Free(mettail_runtime::get_or_create_var({})))", var_name));
                } else if nt == category {
                    // Recursive reference: use CatInfix to avoid circular reference
                    pattern.push_str(&format!(" <{}:{}Infix>", var_name, cat_str));
                    args.push(format!("Box::new({})", var_name));
                } else {
                    // Different category: use as-is
                    pattern.push_str(&format!(" <{}:{}>", var_name, nt));
                    args.push(format!("Box::new({})", var_name));
                }
                field_idx += 1;
            },
            GrammarItem::Collection { .. } => {
                // Collections in var+terminal rules - unusual but skip for now
            },
            GrammarItem::Binder { .. } => {
                // Binders in var+terminal rules - unusual but skip for now
            },
        }
    }

    // Construct the AST node
    let args_str = args.join(", ");
    format!("{} => {}::{}({})", pattern.trim(), category, label, args_str)
}

/// Generate simple production (no infix operators)
fn generate_simple_production(
    category: &syn::Ident,
    rules: &[&GrammarRule],
    has_var_rule: bool,
    theory: &TheoryDef,
) -> String {
    let mut production = String::new();

    // Production header: pub CategoryName: CategoryName = {
    production.push_str(&format!("pub {}: {} = {{\n", category, category));

    // Generate alternative for each rule
    for (i, rule) in rules.iter().enumerate() {
        production.push_str("    ");
        // Pass theory context for native type detection
        production.push_str(&generate_rule_alternative_with_theory(rule, Some(theory)));

        if i < rules.len() - 1 {
            production.push_str(",\n");
        } else {
            production.push('\n');
        }
    }

    // Check if we need to add a comma before auto-generated rules
    let mut needs_comma = !rules.is_empty();
    
    // Check if there's an explicit Integer rule (NumLit . Cat ::= Integer)
    let has_integer_rule = rules.iter().any(|r| is_integer_rule(r));

    // Auto-generate literal parser for native types (if not explicitly declared)
    if let Some(native_type) = has_native_type(category, theory) {
        let type_str = native_type_to_string(native_type);
        if !has_integer_rule {
            let literal_label = generate_literal_label(native_type);

            if needs_comma {
                production.push_str(",\n");
            }

            if type_str == "i32" || type_str == "i64" {
                // Integer literals: parse Integer token
                // Add unary minus support for negative numbers (before positive literals for precedence)
                production.push_str(&format!(
                    "    \"-\" <i:Integer> => {}::{}(-i),\n",
                    category, literal_label
                ));
                production
                    .push_str(&format!("    <i:Integer> => {}::{}(i)", category, literal_label));
            } else if type_str == "f32" || type_str == "f64" {
                // Float literals: parse Float token
                production
                    .push_str(&format!("    <f:Float> => {}::{}(f)", category, literal_label));
            } else if type_str == "bool" {
                // Boolean literals: parse Boolean token
                production
                    .push_str(&format!("    <b:Boolean> => {}::{}(b)", category, literal_label));
            }
            needs_comma = true; // Next rule (Var) needs comma
        }
    }

    // Automatically adds Var alternative if it doesn't exist (lowest precedence)
    // Variables always parse as Ident (not Integer), regardless of native type
    // Integer literals are handled separately via NumLit/Integer rules
    if !has_var_rule {
        let var_label = generate_var_label(category);
        // Variables always parse as Ident (not Integer)
        if needs_comma {
            production.push_str(",\n");
        } else {
            production.push('\n');
        }
        production.push_str(&format!(
            "    <v:Ident> => {}::{}(mettail_runtime::OrdVar(mettail_runtime::Var::Free(mettail_runtime::get_or_create_var(v))))",
            category, var_label
        ));
    }

    production.push_str("\n};\n");
    production
}

/// Generate a LALRPOP alternative for a single grammar rule (with theory context for native types)
fn generate_rule_alternative_with_theory(
    rule: &GrammarRule,
    _theory: Option<&TheoryDef>,
) -> String {
    // If this rule has a syntax pattern (new judgement-style syntax), use it
    if let (Some(ref term_context), Some(ref syntax_pattern)) = (&rule.term_context, &rule.syntax_pattern) {
        return generate_pattern_alternative(rule, term_context, syntax_pattern);
    }

    let label = &rule.label;
    let mut alt = String::new();

    // Generate pattern for matching the syntax
    // Example: PZero . Proc ::= "0" ;
    //   becomes: "0" => Proc::PZero

    // Handle different cases based on rule structure
    if rule.items.len() == 1 {
        // Single item (terminal or non-terminal)
        match &rule.items[0] {
            GrammarItem::Terminal(term) => {
                // Terminal: just match the literal
                alt.push_str(&format!("\"{}\" => {}::{}", term, rule.category, label));
            },
            GrammarItem::NonTerminal(nt) if nt == "Integer" => {
                // Integer keyword: parse Integer token directly for native integer literals
                alt.push_str(&format!("<i:Integer> => {}::{}(i)", rule.category, label));
            },
            GrammarItem::NonTerminal(nt) if nt == "Var" => {
                // Variable: parse identifier as variable node
                // Use get_or_create_var to ensure same name = same ID within a parse
                alt.push_str(&format!("<v:Ident> => {}::{}(mettail_runtime::OrdVar(mettail_runtime::Var::Free(mettail_runtime::get_or_create_var(v))))",
                    rule.category, label));
            },
            GrammarItem::NonTerminal(nt) => {
                // Non-terminal: recursively parse
                alt.push_str(&format!(
                    "<val:{}> => {}::{}(Box::new(val))",
                    nt, rule.category, label
                ));
            },
            GrammarItem::Collection {
                coll_type,
                element_type,
                separator,
                delimiters,
            } => {
                // Single-item collection - generate the collection alternative
                return generate_collection_alternative(
                    rule,
                    coll_type,
                    element_type,
                    separator,
                    delimiters.as_ref(),
                );
            },
            GrammarItem::Binder { .. } => {
                // Binder alone shouldn't happen
                alt.push_str(&format!("// TODO: handle binder => {}::{}", rule.category, label));
            },
        }
    } else {
        // Multiple items: need to handle sequence
        alt.push_str(&generate_sequence_alternative(rule));
    }

    alt
}

/// Generate alternative for a rule with multiple items
fn generate_sequence_alternative(rule: &GrammarRule) -> String {
    let label = &rule.label;
    let category = &rule.category;

    // Check if this rule has binders
    if !rule.bindings.is_empty() {
        return generate_binder_alternative(rule);
    }

    let mut pattern = String::new();
    let mut args = Vec::new();
    let mut field_idx = 0;

    for item in &rule.items {
        match item {
            GrammarItem::Terminal(term) => {
                pattern.push_str(&format!(" \"{}\"", term));
            },
            GrammarItem::NonTerminal(nt) => {
                let var_name = format!("f{}", field_idx);

                if nt.to_string() == "Var" {
                    // Var should parse as Ident, then convert to OrdVar
                    pattern.push_str(&format!(" <{}:Ident>", var_name));
                    args.push(format!("mettail_runtime::OrdVar(mettail_runtime::Var::Free(mettail_runtime::get_or_create_var({})))", var_name));
                } else {
                    pattern.push_str(&format!(" <{}:{}>", var_name, nt));
                    args.push(format!("Box::new({})", var_name));
                }
                field_idx += 1;
            },
            GrammarItem::Collection {
                coll_type,
                element_type,
                separator,
                delimiters,
            } => {
                // Generate LALRPOP rule for separated list
                return generate_collection_alternative(
                    rule,
                    coll_type,
                    element_type,
                    separator,
                    delimiters.as_ref(),
                );
            },
            GrammarItem::Binder { category: _binder_cat } => {
                // Binder: parse as identifier
                let var_name = format!("b{}", field_idx);
                pattern.push_str(&format!(" <{}:Ident>", var_name));
                // Binders are captured in Scope, handled separately
                field_idx += 1;
            },
        }
    }

    // Construct the AST node
    let args_str = args.join(", ");
    format!("{} => {}::{}({})", pattern.trim(), category, label, args_str)
}

/// Generate alternative for a rule with binders (creates Scope)
fn generate_binder_alternative(rule: &GrammarRule) -> String {
    let label = &rule.label;
    let category = &rule.category;

    let (binder_idx, body_indices) = &rule.bindings[0];
    let body_idx = body_indices[0];

    // Generate pattern and track which items go where
    let mut pattern = String::new();
    let mut regular_fields = Vec::new();
    let mut binder_var = String::new();
    let mut body_var = String::new();
    let mut field_idx = 0;

    for (i, item) in rule.items.iter().enumerate() {
        match item {
            GrammarItem::Terminal(term) => {
                pattern.push_str(&format!(" \"{}\"", term));
            },
            GrammarItem::NonTerminal(nt) => {
                if i == body_idx {
                    // This is the body
                    body_var = format!("body_{}", field_idx);
                    pattern.push_str(&format!(" <{}:{}>", body_var, nt));
                } else {
                    // Regular field (not binder, not body)
                    let var_name = format!("f{}", field_idx);
                    pattern.push_str(&format!(" <{}:{}>", var_name, nt));

                    if nt.to_string() == "Var" {
                        regular_fields.push(var_name);
                    } else {
                        regular_fields.push(format!("Box::new({})", var_name));
                    }
                }
                field_idx += 1;
            },
            GrammarItem::Collection { .. } => {
                // Collections in binder rules not yet supported (Phase 4)
                panic!("Collection types in binder rules not yet implemented (Phase 4)");
            },
            GrammarItem::Binder { .. } => {
                if i == *binder_idx {
                    // This is the binder - parse as identifier
                    binder_var = format!("x_{}", field_idx);
                    pattern.push_str(&format!(" <{}:Ident>", binder_var));
                }
                field_idx += 1;
            },
        }
    }

    // Generate the action code that creates Scope
    // We need to extract the free variable from the body that matches the binder name
    // and use it as the binder, so moniker can properly bind it
    let mut action = format!(" => {{\n");
    action.push_str("        use mettail_runtime::BoundTerm;\n");
    action.push_str(&format!("        let free_vars = {}.free_vars();\n", body_var));
    action.push_str(&format!("        let binder = if let Some(fv) = free_vars.iter().find(|fv| fv.pretty_name.as_deref() == Some(&{})) {{\n", binder_var));
    action.push_str("            Binder((*fv).clone())\n");
    action.push_str("        } else {\n");
    action.push_str(&format!(
        "            Binder(mettail_runtime::get_or_create_var({}))\n",
        binder_var
    ));
    action.push_str("        };\n");
    action.push_str(&format!("        let scope = Scope::new(binder, Box::new({}));\n", body_var));

    // Build constructor call
    let mut all_args = regular_fields;
    all_args.push("scope".to_string());

    action.push_str(&format!("        {}::{}({})\n", category, label, all_args.join(", ")));
    action.push_str("    }");

    format!("{}{}", pattern.trim(), action)
}

/// Info for multi-binder patterns (#zip + #map + #sep chains)
#[derive(Debug, Clone)]
struct MultiBinderInfo {
    /// The collection parameter name (e.g., "ns")
    collection_param: String,
    /// The multi-binder parameter name (e.g., "xs")
    binder_param: String,
    /// The body parameter name (e.g., "p")
    body_param: String,
}

/// Generate alternative from a syntax pattern (new judgement-style syntax)
/// 
/// Maps syntax pattern expressions to LALRPOP pattern elements:
/// - Param references matching term_context become non-terminal captures
/// - Literals become quoted terminals
/// - Pattern operations (#sep, #map, etc.) generate appropriate grammar
fn generate_pattern_alternative(
    rule: &GrammarRule,
    term_context: &[TermParam],
    syntax_pattern: &[SyntaxExpr],
) -> String {
    let label = &rule.label;
    let category = &rule.category;

    // Build a map from parameter names to their types
    let param_types = build_param_types(term_context);

    // Generate pattern from syntax expressions
    let mut pattern = String::new();
    let mut args = Vec::new();
    let mut binder_var: Option<String> = None;
    let mut body_var: Option<String> = None;
    let mut has_binder = false;
    let mut collection_params: Vec<(String, String, String)> = Vec::new(); // (name, elem_type, separator)
    let mut multi_binder_info: Option<MultiBinderInfo> = None;
    
    for expr in syntax_pattern {
        generate_syntax_expr_pattern(
            expr,
            &param_types,
            &mut pattern,
            &mut args,
            &mut binder_var,
            &mut body_var,
            &mut has_binder,
            &mut collection_params,
            &mut multi_binder_info,
        );
    }

    // Generate the action
    if has_binder {
        // Generate action with Scope creation
        let binder = binder_var.clone().unwrap_or_else(|| "x".to_string());
        let body = body_var.clone().unwrap_or_else(|| "body".to_string());
        
        let mut action = " => {\n".to_string();
        action.push_str("        use mettail_runtime::BoundTerm;\n");
        action.push_str(&format!("        let free_vars = {}.free_vars();\n", body));
        action.push_str(&format!(
            "        let binder = if let Some(fv) = free_vars.iter().find(|fv| fv.pretty_name.as_deref() == Some(&{})) {{\n",
            binder
        ));
        action.push_str("            Binder((*fv).clone())\n");
        action.push_str("        } else {\n");
        action.push_str(&format!(
            "            Binder(mettail_runtime::get_or_create_var({}))\n",
            binder
        ));
        action.push_str("        };\n");
        action.push_str(&format!("        let scope = Scope::new(binder, Box::new({}));\n", body));

        // Build constructor call with regular args + scope
        let mut all_args: Vec<String> = args
            .iter()
            .filter(|(name, _)| Some(name) != binder_var.as_ref() && Some(name) != body_var.as_ref())
            .map(|(name, info)| {
                match &info.ty {
                    TypeExpr::Base(t) if t.to_string() == "Var" => name.clone(),
                    _ => format!("Box::new({})", name),
                }
            })
            .collect();
        all_args.push("scope".to_string());

        action.push_str(&format!("        {}::{}({})\n", category, label, all_args.join(", ")));
        action.push_str("    }");
        
        format!("{}{}", pattern.trim(), action)
    } else if args.is_empty() && collection_params.is_empty() && multi_binder_info.is_none() {
        // Nullary constructor - unit variant
        format!("{} => {}::{}", pattern.trim(), category, label)
    } else if let Some(ref mb_info) = multi_binder_info {
        // Multi-binder pattern: #zip(...).#map(...).#sep(...)
        // The pattern captures __pairs_v (Vec of tuples) and __pairs_e (Option of tuple)
        //
        // Pattern: <__pairs_v:((inner) "sep")*> <__pair_e:(inner)?>
        // - __pairs_v items have type ((inner_tuple), &str) - inner plus separator
        // - __pair_e has type Option<inner_tuple> - just the inner
        //
        // For inner pattern like `Ident "<-" Name`, inner_tuple = (String, &str, Name)
        let mut action = " => {\n".to_string();
        
        // Extract names and binder strings from captured tuples
        // __pairs_v: Vec<((String, &str, Name), &str)> - need ((x, _, n), _)
        // __pairs_e: Option<(String, &str, Name)> - need (x, _, n)
        action.push_str(&format!(
            "        let mut {coll} = Vec::new();\n\
             let mut __binder_strs = Vec::new();\n\
             for ((x, _, n), _) in __pairs_v {{\n\
                 __binder_strs.push(x);\n\
                 {coll}.push(n);\n\
             }}\n\
             if let Some((x, _, n)) = __pair_e {{\n\
                 __binder_strs.push(x);\n\
                 {coll}.push(n);\n\
             }}\n",
            coll = mb_info.collection_param
        ));
        
        // Create binders from strings
        action.push_str(
            "        let __binders: Vec<Binder<String>> = __binder_strs.into_iter()\n\
             .map(|s| Binder(mettail_runtime::get_or_create_var(s)))\n\
             .collect();\n"
        );
        
        // Create the multi-binder scope
        action.push_str(&format!(
            "        let __scope = Scope::new(__binders, Box::new({}));\n",
            mb_info.body_param
        ));
        
        // Build constructor call with collection and scope
        action.push_str(&format!(
            "        {}::{}({}, __scope)\n",
            category, label, mb_info.collection_param
        ));
        action.push_str("    }");
        
        format!("{}{}", pattern.trim(), action)
    } else if !collection_params.is_empty() {
        // Has collection parameters - need to combine _v and _e captures
        let mut action = " => {\n".to_string();
        
        // Generate code to combine collection captures
        for (coll_name, _elem_type, _sep) in &collection_params {
            action.push_str(&format!(
                "        let mut {name} = HashBag::new();\n\
                 for item in {name}_v {{ {name}.insert(item); }}\n\
                 if let Some(item) = {name}_e {{ {name}.insert(item); }}\n",
                name = coll_name
            ));
        }
        
        // Build constructor call
        let args_str: String = args
            .iter()
            .map(|(name, info)| {
                match &info.ty {
                    TypeExpr::Base(t) if t.to_string() == "Var" => name.clone(),
                    TypeExpr::Collection { .. } => name.clone(), // Already built above
                    _ => format!("Box::new({})", name),
                }
            })
            .collect::<Vec<_>>()
            .join(", ");
        
        action.push_str(&format!("        {}::{}({})\n", category, label, args_str));
        action.push_str("    }");
        
        format!("{}{}", pattern.trim(), action)
    } else {
        // Simple constructor call with args
        let args_str: String = args
            .iter()
            .map(|(name, info)| {
                match &info.ty {
                    TypeExpr::Base(t) if t.to_string() == "Var" => name.clone(),
                    _ => format!("Box::new({})", name),
                }
            })
            .collect::<Vec<_>>()
            .join(", ");
        
        format!("{} => {}::{}({})", pattern.trim(), category, label, args_str)
    }
}

/// Helper enum for parameter kinds
#[derive(Debug, Clone)]
enum ParamKind {
    Simple,
    Binder,
    MultiBinder,
    Body,
    Collection,
}

/// Helper struct for parameter info
#[derive(Debug, Clone)]
struct ParamInfo {
    kind: ParamKind,
    ty: TypeExpr,
}

/// Build param_types map from term context
fn build_param_types(term_context: &[TermParam]) -> std::collections::HashMap<String, ParamInfo> {
    let mut param_types = std::collections::HashMap::new();
    
    for param in term_context {
        match param {
            TermParam::Simple { name, ty } => {
                let kind = if matches!(ty, TypeExpr::Collection { .. }) {
                    ParamKind::Collection
                } else {
                    ParamKind::Simple
                };
                param_types.insert(name.to_string(), ParamInfo {
                    kind,
                    ty: ty.clone(),
                });
            }
            TermParam::Abstraction { binder, body, ty } => {
                // Binder is captured as identifier
                param_types.insert(binder.to_string(), ParamInfo {
                    kind: ParamKind::Binder,
                    ty: ty.clone(),
                });
                // Body is the codomain type
                if let TypeExpr::Arrow { codomain, .. } = ty {
                    param_types.insert(body.to_string(), ParamInfo {
                        kind: ParamKind::Body,
                        ty: (**codomain).clone(),
                    });
                }
            }
            TermParam::MultiAbstraction { binder, body, ty } => {
                // Multi-binder is captured as multiple identifiers
                param_types.insert(binder.to_string(), ParamInfo {
                    kind: ParamKind::MultiBinder,
                    ty: ty.clone(),
                });
                // Body is the codomain type
                if let TypeExpr::Arrow { codomain, .. } = ty {
                    param_types.insert(body.to_string(), ParamInfo {
                        kind: ParamKind::Body,
                        ty: (**codomain).clone(),
                    });
                }
            }
        }
    }
    
    param_types
}

/// Generate LALRPOP pattern elements for a single SyntaxExpr
#[allow(clippy::too_many_arguments)]
fn generate_syntax_expr_pattern(
    expr: &SyntaxExpr,
    param_types: &std::collections::HashMap<String, ParamInfo>,
    pattern: &mut String,
    args: &mut Vec<(String, ParamInfo)>,
    binder_var: &mut Option<String>,
    body_var: &mut Option<String>,
    has_binder: &mut bool,
    collection_params: &mut Vec<(String, String, String)>, // (name, elem_type, separator)
    multi_binder_info: &mut Option<MultiBinderInfo>,
) {
    match expr {
        SyntaxExpr::Literal(s) => {
            pattern.push_str(&format!(" \"{}\"", s));
        }
        SyntaxExpr::Param(id) => {
            let name = id.to_string();
            if let Some(info) = param_types.get(&name) {
                match info.kind {
                    ParamKind::Simple => {
                        let nonterminal = type_to_nonterminal(&info.ty);
                        pattern.push_str(&format!(" <{}:{}>", name, nonterminal));
                        args.push((name.clone(), info.clone()));
                    }
                    ParamKind::Binder => {
                        pattern.push_str(&format!(" <{}:Ident>", name));
                        *binder_var = Some(name.clone());
                        *has_binder = true;
                    }
                    ParamKind::MultiBinder => {
                        pattern.push_str(&format!(" <{}:Ident>", name));
                        *binder_var = Some(name.clone());
                        *has_binder = true;
                    }
                    ParamKind::Body => {
                        let nonterminal = type_to_nonterminal(&info.ty);
                        pattern.push_str(&format!(" <{}:{}>", name, nonterminal));
                        *body_var = Some(name.clone());
                    }
                    ParamKind::Collection => {
                        // Collection without #sep - use default separator
                        if let TypeExpr::Collection { element, .. } = &info.ty {
                            let elem_type = type_to_nonterminal(element);
                            // Default separator is "|" - but this should be specified via #sep
                            pattern.push_str(&format!(" <{}:((<{}> \"|\")* <{}>?)>", name, elem_type, elem_type));
                            args.push((name.clone(), info.clone()));
                        }
                    }
                }
            } else {
                // Unknown parameter - treat as literal (validation should catch this)
                pattern.push_str(&format!(" \"{}\"", name));
            }
        }
        SyntaxExpr::Op(op) => {
            generate_pattern_op_pattern(op, param_types, pattern, args, collection_params, multi_binder_info);
        }
    }
}

/// Generate LALRPOP pattern for a pattern operation
fn generate_pattern_op_pattern(
    op: &PatternOp,
    param_types: &std::collections::HashMap<String, ParamInfo>,
    pattern: &mut String,
    args: &mut Vec<(String, ParamInfo)>,
    collection_params: &mut Vec<(String, String, String)>,
    multi_binder_info: &mut Option<MultiBinderInfo>,
) {
    match op {
        PatternOp::Sep { collection, separator, source } => {
            // Check for chained operation (e.g., #zip(...).#map(...).#sep(","))
            if let Some(chain_source) = source {
                generate_chained_sep_pattern(chain_source, separator, param_types, pattern, args, collection_params, multi_binder_info);
                return;
            }
            
            // Simple collection separator
            let name = collection.to_string();
            if let Some(info) = param_types.get(&name) {
                if let TypeExpr::Collection { element, .. } = &info.ty {
                    let elem_type = type_to_nonterminal(element);
                    // Generate separated list pattern with two captures:
                    // <name_v:(<Elem> "sep")*> <name_e:Elem?>
                    // Then combine in action code
                    pattern.push_str(&format!(
                        " <{}_v:(<{}> \"{}\")*> <{}_e:{}?>",
                        name, elem_type, separator, name, elem_type
                    ));
                    args.push((name.clone(), info.clone()));
                    collection_params.push((name, elem_type, separator.clone()));
                }
            }
        }
        PatternOp::Var(id) => {
            // Variable reference in pattern op context - treat as param
            let name = id.to_string();
            if let Some(info) = param_types.get(&name) {
                let nonterminal = type_to_nonterminal(&info.ty);
                pattern.push_str(&format!(" <{}:{}>", name, nonterminal));
                args.push((name.clone(), info.clone()));
            }
        }
        PatternOp::Zip { .. } | PatternOp::Map { .. } => {
            // Zip and Map are typically chained with Sep
            // For now, we handle the common case: #zip(a,b).#map(|x,y| ...).#sep(",")
            // This needs more sophisticated handling for the full case
            // TODO: Implement full zip/map support
            pattern.push_str(" /* TODO: zip/map pattern */");
        }
        PatternOp::Opt { inner } => {
            // Optional pattern: (inner)?
            pattern.push_str(" (");
            for expr in inner {
                generate_syntax_expr_pattern(
                    expr,
                    param_types,
                    pattern,
                    args,
                    &mut None,
                    &mut None,
                    &mut false,
                    collection_params,
                    &mut None, // multi_binder_info not propagated to optional inner
                );
            }
            pattern.push_str(")?");
        }
    }
}

/// Generate LALRPOP pattern for chained #zip(...).#map(...).#sep(",")
/// 
/// This handles multi-binder patterns like:
///   `#zip(ns, xs).#map(|n,x| x "<-" n).#sep(",")`
/// Which generates:
///   `<__pairs_v:((Ident "<-" Name) ",")*> <__pair_e:(Ident "<-" Name)?>`
/// 
/// Note: LALRPOP doesn't allow named captures inside nested patterns,
/// so we use anonymous captures. The result is tuples that we destructure.
fn generate_chained_sep_pattern(
    source: &PatternOp,
    separator: &str,
    param_types: &std::collections::HashMap<String, ParamInfo>,
    pattern: &mut String,
    _args: &mut Vec<(String, ParamInfo)>,
    _collection_params: &mut Vec<(String, String, String)>,
    multi_binder_info: &mut Option<MultiBinderInfo>,
) {
    // Extract the Map and Zip from the chain
    if let PatternOp::Map { source: map_source, params, body } = source {
        if let PatternOp::Zip { left, right } = map_source.as_ref() {
            // We have: #zip(left, right).#map(|params| body).#sep(separator)
            
            // Determine which zip operand is the collection and which is the multi-binder
            let left_name = left.to_string();
            let right_name = right.to_string();
            
            let (collection_param, binder_param) = 
                if param_types.get(&left_name).map(|i| matches!(i.kind, ParamKind::MultiBinder)).unwrap_or(false) {
                    (right_name.clone(), left_name.clone())
                } else {
                    (left_name.clone(), right_name.clone())
                };
            
            // Find the body parameter name (the one that's not involved in the zip)
            let body_param = param_types.iter()
                .find(|(name, info)| {
                    matches!(info.kind, ParamKind::Body) || 
                    (*name != &collection_param && *name != &binder_param && 
                     matches!(info.ty, TypeExpr::Base(_)))
                })
                .map(|(name, _)| name.clone())
                .unwrap_or_else(|| "p".to_string());
            
            // Build the inner pattern from the map body
            // e.g., |n,x| x "<-" n â†’ "Ident \"<-\" Name"
            let mut inner_pattern = String::new();
            let mut param_map: std::collections::HashMap<String, &syn::Ident> = std::collections::HashMap::new();
            
            // Map closure params to zip operands
            if params.len() >= 2 {
                param_map.insert(params[0].to_string(), left);
                param_map.insert(params[1].to_string(), right);
            }
            
            for expr in body {
                match expr {
                    SyntaxExpr::Literal(s) => {
                        inner_pattern.push_str(&format!(" \"{}\"", s));
                    }
                    SyntaxExpr::Param(id) => {
                        let name = id.to_string();
                        if let Some(&orig_param) = param_map.get(&name) {
                            // This closure param maps to a zip operand
                            let orig_name = orig_param.to_string();
                            if let Some(info) = param_types.get(&orig_name) {
                                match info.kind {
                                    ParamKind::MultiBinder => {
                                        // Multi-binder captures as Ident (anonymous)
                                        inner_pattern.push_str(" Ident");
                                    }
                                    _ => {
                                        let nt = type_to_nonterminal(&info.ty);
                                        // Anonymous capture - LALRPOP doesn't allow named symbols in nested patterns
                                        inner_pattern.push_str(&format!(" {}", nt));
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            
            // Generate the full pattern with separator:
            // <__pairs_v:((inner) sep)*> <__pair_e:(inner)?>
            let inner_trimmed = inner_pattern.trim();
            pattern.push_str(&format!(
                " <__pairs_v:(({}) \"{}\")*> <__pair_e:({})?>",
                inner_trimmed, separator, inner_trimmed
            ));
            
            // Set multi-binder info for action generation
            *multi_binder_info = Some(MultiBinderInfo {
                collection_param,
                binder_param,
                body_param,
            });
            
            return;
        }
    }
    
    // Fallback: just output a placeholder
    pattern.push_str(" /* unhandled chained pattern */");
}

/// Convert a TypeExpr to a LALRPOP non-terminal name
fn type_to_nonterminal(ty: &TypeExpr) -> String {
    match ty {
        TypeExpr::Base(id) => id.to_string(),
        TypeExpr::Collection { element, .. } => {
            // Collections need special handling
            type_to_nonterminal(element)
        }
        _ => "UNKNOWN".to_string(),
    }
}

/// Generate alternative for a collection constructor
///
/// Generates LALRPOP rules for separated lists with optional delimiters.
/// Examples:
/// - `a | b | c` (no delimiters)
/// - `[a, b, c]` (with delimiters)
/// - `[]` (empty collection)
fn generate_collection_alternative(
    rule: &GrammarRule,
    coll_type: &CollectionType,
    element_type: &syn::Ident,
    separator: &str,
    delimiters: Option<&(String, String)>,
) -> String {
    let label = &rule.label;
    let category = &rule.category;

    // Escape separator for LALRPOP
    // Special handling for "|" which has meaning in LALRPOP grammar syntax
    let sep_escaped = if separator == "|" {
        r"\|".to_string()
    } else {
        separator.replace("\"", "\\\"")
    };

    // Determine if we need to use regex pattern (for special chars like |)
    let sep_pattern = if separator == "|" {
        format!("r\"{}\"", sep_escaped)
    } else {
        format!("\"{}\"", sep_escaped)
    };

    // Determine the collection type constructor
    let coll_constructor = match coll_type {
        CollectionType::HashBag => "mettail_runtime::HashBag",
        CollectionType::HashSet => "std::collections::HashSet",
        CollectionType::Vec => "Vec",
    };

    // Build the pattern
    // For separated lists, we use: <elems:(<Elem> "sep")*> <last:Elem?>
    // This allows optional trailing separator
    let mut pattern = String::new();

    if let Some((open, close)) = delimiters {
        // With delimiters: `{` <elems> `}`
        // LALRPOP syntax: (X Y)* creates Vec<(X,Y)>, but (<X> Y)* creates Vec<X>
        // LALRPOP automatically handles whitespace between tokens
        let open_escaped = open.replace("\"", "\\\"");
        let close_escaped = close.replace("\"", "\\\"");
        pattern.push_str(&format!("\"{}\" ", open_escaped));
        // Capture just the element, discard the separator
        pattern.push_str(&format!("<elems:(<{}> {})*> ", element_type, sep_pattern));
        pattern.push_str(&format!("<last:{}?> ", element_type));
        pattern.push_str(&format!("\"{}\"", close_escaped));
    } else {
        // Without delimiters: just the separated list
        // Use <> to only capture the element, not the separator
        // LALRPOP automatically handles whitespace between tokens
        pattern.push_str(&format!("<first:{}> ", element_type));
        pattern.push_str(&format!("<rest:({} <{}>)*>", sep_pattern, element_type));
    }

    // Build the action
    let mut action = String::from(" => {\n");
    action.push_str(&format!("        let mut coll = {}::new();\n", coll_constructor));

    if delimiters.is_some() {
        // With delimiters: use elems and last pattern
        action.push_str("        for e in elems {\n");
        match coll_type {
            CollectionType::HashBag => {
                action.push_str("            coll.insert(e);\n");
            },
            CollectionType::HashSet => {
                action.push_str("            coll.insert(e);\n");
            },
            CollectionType::Vec => {
                action.push_str("            coll.push(e);\n");
            },
        }
        action.push_str("        }\n");
        action.push_str("        if let Some(e) = last {\n");
        match coll_type {
            CollectionType::HashBag => {
                action.push_str("            coll.insert(e);\n");
            },
            CollectionType::HashSet => {
                action.push_str("            coll.insert(e);\n");
            },
            CollectionType::Vec => {
                action.push_str("            coll.push(e);\n");
            },
        }
        action.push_str("        }\n");
    } else {
        // Without delimiters: use first and rest pattern
        match coll_type {
            CollectionType::HashBag => {
                action.push_str("        coll.insert(first);\n");
                action.push_str("        for e in rest {\n");
                action.push_str("            coll.insert(e);\n");
                action.push_str("        }\n");
            },
            CollectionType::HashSet => {
                action.push_str("        coll.insert(first);\n");
                action.push_str("        for e in rest {\n");
                action.push_str("            coll.insert(e);\n");
                action.push_str("        }\n");
            },  
            CollectionType::Vec => {
                action.push_str("        coll.push(first);\n");
                action.push_str("        for e in rest {\n");
                action.push_str("            coll.push(e);\n");
                action.push_str("        }\n");
            },
        }
    }

    action.push_str(&format!("        {}::{}(coll)\n", category, label));
    action.push_str("    }");

    format!("{}{}", pattern.trim(), action)
}

#[cfg(test)]
mod tests {
    use super::*;
    use syn::parse_quote;

    #[test]
    fn test_automatic_var_in_parser() {
        // Tests theory without Var rules - they should be automatically generated in parser
        let theory = TheoryDef {
            name: parse_quote!(Test),
            params: vec![],
            exports: vec![
                Export {
                    name: parse_quote!(Proc),
                    native_type: None,
                },
                Export {
                    name: parse_quote!(Name),
                    native_type: None,
                },
            ],
            terms: vec![
                GrammarRule {
                    label: parse_quote!(PZero),
                    category: parse_quote!(Proc),
                    items: vec![GrammarItem::Terminal("0".to_string())],
                    bindings: vec![],
                    term_context: None,
                    syntax_pattern: None,
                },
                GrammarRule {
                    label: parse_quote!(NQuote),
                    category: parse_quote!(Name),
                    items: vec![
                        GrammarItem::Terminal("@".to_string()),
                        GrammarItem::NonTerminal(parse_quote!(Proc)),
                    ],
                    bindings: vec![],
                    term_context: None,
                    syntax_pattern: None,
                },
                // No Var rules explicitly defined
            ],
            equations: vec![],
            rewrites: vec![],
            semantics: vec![],
        };

        let grammar = generate_lalrpop_grammar(&theory);
        println!("Generated grammar:\n{}", grammar);

        // Checks that Var alternatives are automatically generated for each exported category
        // Proc -> PVar
        assert!(
            grammar.contains(
                "PVar(mettail_runtime::OrdVar(mettail_runtime::Var::Free(mettail_runtime::get_or_create_var(v))))"
            ),
            "Expected PVar parser alternative for Proc category"
        );
        // Name -> NVar
        assert!(
            grammar.contains(
                "NVar(mettail_runtime::OrdVar(mettail_runtime::Var::Free(mettail_runtime::get_or_create_var(v))))"
            ),
            "Expected NVar parser alternative for Name category"
        );

        // Verifies the grammar structure
        assert!(grammar.contains("pub Proc: Proc"));
        assert!(grammar.contains("pub Name: Name"));
        assert!(grammar.contains("<v:Ident>"));
    }

    #[test]
    fn test_automatic_var_in_parser_with_existing_var() {
        // Tests that if a Var rule already exists, we don't generate a duplicate
        let theory = TheoryDef {
            name: parse_quote!(Test),
            params: vec![],
            exports: vec![Export {
                name: parse_quote!(Proc),
                native_type: None,
            }],
            terms: vec![
                GrammarRule {
                    label: parse_quote!(PZero),
                    category: parse_quote!(Proc),
                    items: vec![GrammarItem::Terminal("0".to_string())],
                    bindings: vec![],
                    term_context: None,
                    syntax_pattern: None,
                },
                GrammarRule {
                    label: parse_quote!(PVar),
                    category: parse_quote!(Proc),
                    items: vec![GrammarItem::NonTerminal(parse_quote!(Var))],
                    bindings: vec![],
                    term_context: None,
                    syntax_pattern: None,
                },
                // Var rule explicitly defined
            ],
            equations: vec![],
            rewrites: vec![],
            semantics: vec![],
        };

        let grammar = generate_lalrpop_grammar(&theory);
        println!("Generated grammar:\n{}", grammar);

        // Should have exactly one PVar alternative (the explicitly defined one)
        let pvar_count = grammar.matches("PVar").count();
        assert_eq!(pvar_count, 1, "Expected exactly one PVar alternative, found {}", pvar_count);
        assert!(
            grammar.contains(
                "PVar(mettail_runtime::OrdVar(mettail_runtime::Var::Free(mettail_runtime::get_or_create_var(v))))"
            ),
            "Expected PVar parser alternative"
        );
    }

    #[test]
    fn test_var_label_generation() {
        // Tests that Var labels are generated correctly for different category names
        assert_eq!(generate_var_label(&parse_quote!(Proc)), "PVar");
        assert_eq!(generate_var_label(&parse_quote!(Name)), "NVar");
        assert_eq!(generate_var_label(&parse_quote!(Term)), "TVar");
        assert_eq!(generate_var_label(&parse_quote!(Expr)), "EVar");
        assert_eq!(generate_var_label(&parse_quote!(Type)), "TVar");
    }

    #[test]
    fn test_var_terminal_rule_detection() {
        // Test that rules starting with Var + terminal are detected
        let assign_rule = GrammarRule {
            label: parse_quote!(Assign),
            category: parse_quote!(Int),
            items: vec![
                GrammarItem::NonTerminal(parse_quote!(Var)),
                GrammarItem::Terminal("=".to_string()),
                GrammarItem::NonTerminal(parse_quote!(Int)),
            ],
            bindings: vec![],
            term_context: None,
            syntax_pattern: None,
        };

        println!("Testing Assign rule: items = {:?}", assign_rule.items);
        println!("Item 0: {:?}", assign_rule.items[0]);
        println!("Item 1: {:?}", assign_rule.items[1]);

        let is_var_term = is_var_terminal_rule(&assign_rule);
        println!("is_var_terminal_rule: {}", is_var_term);
        assert!(is_var_term, "Assign rule should be detected as var+terminal rule");

        // VarRef should NOT be detected as var+terminal (no terminal after Var)
        let varref_rule = GrammarRule {
            label: parse_quote!(VarRef),
            category: parse_quote!(Int),
            items: vec![GrammarItem::NonTerminal(parse_quote!(Var))],
            bindings: vec![],
            term_context: None,
            syntax_pattern: None,
        };

        assert!(
            !is_var_terminal_rule(&varref_rule),
            "VarRef should not be detected as var+terminal rule"
        );
    }

    #[test]
    fn test_calculator_like_grammar() {
        // Test a calculator-like grammar with assignment

        let theory = TheoryDef {
            name: parse_quote!(Calculator),
            params: vec![],
            exports: vec![Export {
                name: parse_quote!(Int),
                native_type: Some(parse_quote!(i32)),
            }],
            terms: vec![
                GrammarRule {
                    label: parse_quote!(VarRef),
                    category: parse_quote!(Int),
                    items: vec![GrammarItem::NonTerminal(parse_quote!(Var))],
                    bindings: vec![],
                    term_context: None,
                    syntax_pattern: None,
                },
                GrammarRule {
                    label: parse_quote!(NumLit),
                    category: parse_quote!(Int),
                    items: vec![GrammarItem::NonTerminal(parse_quote!(Integer))],
                    bindings: vec![],
                    term_context: None,
                    syntax_pattern: None,
                },
                GrammarRule {
                    label: parse_quote!(Add),
                    category: parse_quote!(Int),
                    items: vec![
                        GrammarItem::NonTerminal(parse_quote!(Int)),
                        GrammarItem::Terminal("+".to_string()),
                        GrammarItem::NonTerminal(parse_quote!(Int)),
                    ],
                    bindings: vec![],
                    term_context: None,
                    syntax_pattern: None,
                },
                GrammarRule {
                    label: parse_quote!(Assign),
                    category: parse_quote!(Int),
                    items: vec![
                        GrammarItem::NonTerminal(parse_quote!(Var)),
                        GrammarItem::Terminal("=".to_string()),
                        GrammarItem::NonTerminal(parse_quote!(Int)),
                    ],
                    bindings: vec![],
                    term_context: None,
                    syntax_pattern: None,
                },
            ],
            equations: vec![],
            rewrites: vec![],
            semantics: vec![],
        };

        let grammar = generate_lalrpop_grammar(&theory);
        println!("Generated Calculator grammar:\n{}", grammar);

        // Check that Assign is at the top level, not in IntAtom
        assert!(grammar.contains("pub Int: Int = {"), "Should have top-level Int rule");

        // The Assign rule should appear at the top level before IntInfix
        let int_rule_start = grammar.find("pub Int: Int = {").unwrap();
        let int_rule_end = grammar.find("IntInfix: Int = {").unwrap();
        let top_level_section = &grammar[int_rule_start..int_rule_end];

        println!("Top level section:\n{}", top_level_section);
        assert!(top_level_section.contains("Assign"), "Assign should be at the top level");
    }
}

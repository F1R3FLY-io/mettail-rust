//! Core language traits and types for MeTTaIL
//!
//! These types are shared between the macro-generated code and the REPL.

use std::any::Any;
use std::fmt;

use crate::LanguageMetadata;

// =============================================================================
// Type Inference Types
// =============================================================================

/// Runtime representation of inferred types for REPL display
///
/// This mirrors the compile-time `InferredType` but is available at runtime
/// for displaying types to users.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TermType {
    /// Base type: Name, Proc, etc.
    Base(String),
    /// Function type: [Domain -> Codomain]
    Arrow(Box<TermType>, Box<TermType>),
    /// Multi-argument function type: [Domain* -> Codomain]
    MultiArrow(Box<TermType>, Box<TermType>),
    /// Unknown type (inference failed or not applicable)
    Unknown,
}

impl fmt::Display for TermType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TermType::Base(name) => write!(f, "{}", name),
            TermType::Arrow(domain, codomain) => write!(f, "[{} -> {}]", domain, codomain),
            TermType::MultiArrow(domain, codomain) => write!(f, "[{}* -> {}]", domain, codomain),
            TermType::Unknown => write!(f, "?"),
        }
    }
}

impl TermType {
    /// Create a base type
    pub fn base(name: impl Into<String>) -> Self {
        TermType::Base(name.into())
    }

    /// Create a function type
    pub fn arrow(domain: TermType, codomain: TermType) -> Self {
        TermType::Arrow(Box::new(domain), Box::new(codomain))
    }

    /// Create a multi-argument function type
    pub fn multi_arrow(domain: TermType, codomain: TermType) -> Self {
        TermType::MultiArrow(Box::new(domain), Box::new(codomain))
    }

    /// Check if this is a function type
    pub fn is_function(&self) -> bool {
        matches!(self, TermType::Arrow(..) | TermType::MultiArrow(..))
    }

    /// Get the domain type if this is a function type
    pub fn domain(&self) -> Option<&TermType> {
        match self {
            TermType::Arrow(d, _) | TermType::MultiArrow(d, _) => Some(d),
            _ => None,
        }
    }

    /// Get the codomain type if this is a function type
    pub fn codomain(&self) -> Option<&TermType> {
        match self {
            TermType::Arrow(_, c) | TermType::MultiArrow(_, c) => Some(c),
            _ => None,
        }
    }
}

/// Information about a variable's type in a term
#[derive(Debug, Clone)]
pub struct VarTypeInfo {
    /// The variable name
    pub name: String,
    /// The inferred type
    pub ty: TermType,
}

impl fmt::Display for VarTypeInfo {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{} : {}", self.name, self.ty)
    }
}

/// A trait for terms (AST nodes) that can be manipulated generically
pub trait Term: fmt::Display + fmt::Debug + Send + Sync {
    /// Clone this term into a Box
    fn clone_box(&self) -> Box<dyn Term>;

    /// Get a unique identifier for this term (for equality comparison)
    fn term_id(&self) -> u64;

    /// Check if this term is equal to another
    fn term_eq(&self, other: &dyn Term) -> bool;

    /// Get this as Any for downcasting
    fn as_any(&self) -> &dyn Any;
}

/// A trait that all languages must implement
///
/// This trait is auto-generated by the `language!` macro.
pub trait Language: Send + Sync {
    /// Get the name of this language (e.g., "RhoCalc")
    fn name(&self) -> &'static str;

    /// Get static metadata for this language (types, terms, equations, rewrites)
    fn metadata(&self) -> &'static dyn LanguageMetadata;

    /// Parse a term from a string (clears var cache for fresh evaluation)
    fn parse_term(&self, input: &str) -> Result<Box<dyn Term>, String>;

    /// Parse a term for environment storage (does NOT clear var cache)
    fn parse_term_for_env(&self, input: &str) -> Result<Box<dyn Term>, String>;

    /// Run Ascent on a term and return results
    fn run_ascent(&self, term: &dyn Term) -> Result<AscentResults, String>;

    /// If the term is fully evaluable (no free variables), evaluate it and return the result term.
    /// Otherwise return `None` (e.g. term contains vars, or language has no native eval).
    /// Default: `None` so languages without native types need not implement.
    fn try_direct_eval(&self, term: &dyn Term) -> Option<Box<dyn Term>> {
        let _ = term;
        None
    }

    /// Format a term as a string
    fn format_term(&self, term: &dyn Term) -> String {
        format!("{}", term)
    }

    // === Environment Support ===

    /// Create a new empty environment for this language
    fn create_env(&self) -> Box<dyn Any + Send + Sync>;

    /// Add a term to the environment under the given name
    fn add_to_env(&self, env: &mut dyn Any, name: &str, term: &dyn Term) -> Result<(), String>;

    /// Remove a binding from the environment
    fn remove_from_env(&self, env: &mut dyn Any, name: &str) -> Result<bool, String>;

    /// Clear all bindings from the environment
    fn clear_env(&self, env: &mut dyn Any);

    /// Apply environment substitution to a term
    fn substitute_env(&self, term: &dyn Term, env: &dyn Any) -> Result<Box<dyn Term>, String>;

    /// List all environment bindings as (name, display, optional_comment) tuples
    ///
    /// Returns bindings in insertion order, with any associated comments.
    fn list_env(&self, env: &dyn Any) -> Vec<(String, String, Option<String>)>;

    /// Set a comment for a binding in the environment
    fn set_env_comment(&self, env: &mut dyn Any, name: &str, comment: String)
        -> Result<(), String>;

    /// Check if the environment is empty
    fn is_env_empty(&self, env: &dyn Any) -> bool;

    // === Type Inference Support ===

    /// Infer the type of a term
    ///
    /// For lambda expressions, returns the full function type (e.g., `[Name -> Proc]`).
    /// For other terms, returns their category (e.g., `Proc`, `Name`).
    fn infer_term_type(&self, term: &dyn Term) -> TermType;

    /// Get all free variables and their inferred types in a term
    ///
    /// Returns a list of variable names with their types, inferred from
    /// how they are used in the term.
    fn infer_var_types(&self, term: &dyn Term) -> Vec<VarTypeInfo>;

    /// Infer the type of a specific variable from its usage in a term
    ///
    /// Returns `None` if the variable is not found or its type cannot be inferred.
    fn infer_var_type(&self, term: &dyn Term, var_name: &str) -> Option<TermType>;
}

/// Results from running Ascent
#[derive(Debug, Clone)]
pub struct AscentResults {
    /// All reachable terms
    pub all_terms: Vec<TermInfo>,

    /// All rewrites (from -> to)
    pub rewrites: Vec<Rewrite>,

    /// Equivalence classes (terms related by equations)
    pub equivalences: Vec<EquivClass>,
}

/// Information about a term in the rewrite graph
#[derive(Debug, Clone)]
pub struct TermInfo {
    pub term_id: u64,
    pub display: String,
    pub is_normal_form: bool,
}

/// A rewrite from one term to another
#[derive(Debug, Clone)]
pub struct Rewrite {
    pub from_id: u64,
    pub to_id: u64,
    pub rule_name: Option<String>,
}

/// An equivalence class of terms
#[derive(Debug, Clone)]
pub struct EquivClass {
    pub term_ids: Vec<u64>,
}

impl AscentResults {
    /// Create empty results
    pub fn empty() -> Self {
        Self {
            all_terms: Vec::new(),
            rewrites: Vec::new(),
            equivalences: Vec::new(),
        }
    }

    /// Create minimal results for a single term (e.g. after direct eval). One term, no rewrites.
    pub fn from_single_term(term: &dyn Term) -> Self {
        Self {
            all_terms: vec![TermInfo {
                term_id: term.term_id(),
                display: format!("{}", term),
                is_normal_form: true,
            }],
            rewrites: Vec::new(),
            equivalences: Vec::new(),
        }
    }

    /// Get normal forms (terms with no outgoing rewrites)
    pub fn normal_forms(&self) -> Vec<&TermInfo> {
        self.all_terms.iter().filter(|t| t.is_normal_form).collect()
    }

    /// Get rewrites from a specific term
    pub fn rewrites_from(&self, term_id: u64) -> Vec<&Rewrite> {
        self.rewrites
            .iter()
            .filter(|r| r.from_id == term_id)
            .collect()
    }

    /// Find a normal form reachable from the given term by following rewrites.
    /// Returns the first normal form reached (BFS). If the start term is already
    /// a normal form, returns it. Returns `None` if the term is not in the graph.
    pub fn normal_form_reachable_from(&self, start_id: u64) -> Option<&TermInfo> {
        let term_by_id = |id: u64| self.all_terms.iter().find(|t| t.term_id == id);
        let start = term_by_id(start_id)?;
        if start.is_normal_form {
            return Some(start);
        }
        let mut visited = std::collections::HashSet::new();
        let mut queue = std::collections::VecDeque::from([start_id]);
        visited.insert(start_id);
        while let Some(id) = queue.pop_front() {
            for rw in self.rewrites_from(id) {
                let to_id = rw.to_id;
                if visited.insert(to_id) {
                    if let Some(info) = term_by_id(to_id) {
                        if info.is_normal_form {
                            return Some(info);
                        }
                        queue.push_back(to_id);
                    }
                }
            }
        }
        None
    }

    /// Get the equivalence class containing a term
    pub fn equiv_class(&self, term_id: u64) -> Option<&EquivClass> {
        self.equivalences
            .iter()
            .find(|ec| ec.term_ids.contains(&term_id))
    }
}

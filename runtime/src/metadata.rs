//! Language metadata types for REPL introspection
//!
//! These types are generated by the `language!` macro and provide
//! static metadata about a language's types, terms, equations, and rewrites.
//! The REPL uses this to display the `info` command output.

/// Trait for accessing static language metadata
///
/// Implemented by generated `{LanguageName}Metadata` structs.
pub trait LanguageMetadata: 'static + Send + Sync {
    /// The language name (e.g., "RhoCalc")
    fn name(&self) -> &'static str;

    /// Type definitions (first is primary)
    fn types(&self) -> &'static [TypeDef];

    /// Term (constructor) definitions
    fn terms(&self) -> &'static [TermDef];

    /// Equation definitions
    fn equations(&self) -> &'static [EquationDef];

    /// Rewrite rule definitions
    fn rewrites(&self) -> &'static [RewriteDef];

    /// Custom logic relation definitions
    fn logic_relations(&self) -> &'static [LogicRelationDef] {
        &[]
    }

    /// Custom logic rule definitions
    fn logic_rules(&self) -> &'static [LogicRuleDef] {
        &[]
    }

    /// Get the primary type (first type in the language)
    fn primary_type(&self) -> &'static TypeDef {
        self.types()
            .first()
            .expect("language must have at least one type")
    }

    /// Get terms for a specific type
    fn terms_for_type(&self, type_name: &str) -> Vec<&'static TermDef> {
        self.terms()
            .iter()
            .filter(|t| t.type_name == type_name)
            .collect()
    }
}

/// Definition of a type (category) in the language
#[derive(Debug, Clone, Copy)]
pub struct TypeDef {
    /// Type name (e.g., "Proc", "Name")
    pub name: &'static str,

    /// Native Rust type if this is a primitive (e.g., "i32")
    pub native_type: Option<&'static str>,

    /// Whether this is the primary type (first in declaration order)
    pub is_primary: bool,
}

/// Definition of a term (constructor) in the language
#[derive(Debug, Clone, Copy)]
pub struct TermDef {
    /// Constructor name (e.g., "PInput", "NQuote")
    pub name: &'static str,

    /// The type this constructor produces (e.g., "Proc")
    pub type_name: &'static str,

    /// User syntax representation (e.g., "n?x.{p}")
    pub syntax: &'static str,

    /// Optional description (from doc comments)
    pub description: Option<&'static str>,

    /// Field definitions
    pub fields: &'static [FieldDef],
}

/// Definition of a field in a term constructor
#[derive(Debug, Clone, Copy)]
pub struct FieldDef {
    /// Field name (e.g., "n", "p", "x")
    pub name: &'static str,

    /// Field type (e.g., "Name", "Proc", "[Name -> Proc]")
    pub ty: &'static str,

    /// Whether this field is a binder
    pub is_binder: bool,
}

/// Definition of an equation (axiom)
#[derive(Debug, Clone, Copy)]
pub struct EquationDef {
    /// Freshness conditions (e.g., ["x # P"])
    pub conditions: &'static [&'static str],

    /// Left-hand side in user syntax
    pub lhs: &'static str,

    /// Right-hand side in user syntax
    pub rhs: &'static str,
}

/// Definition of a rewrite rule
#[derive(Debug, Clone, Copy)]
pub struct RewriteDef {
    /// Optional rule name (e.g., "communication")
    pub name: Option<&'static str>,

    /// Freshness conditions
    pub conditions: &'static [&'static str],

    /// Congruence premise: if (S, T) then S ~> T
    pub premise: Option<(&'static str, &'static str)>,

    /// Left-hand side in user syntax
    pub lhs: &'static str,

    /// Right-hand side in user syntax
    pub rhs: &'static str,
}

impl RewriteDef {
    /// Check if this is a congruence rule (has a premise)
    pub fn is_congruence(&self) -> bool {
        self.premise.is_some()
    }

    /// Check if this is a base rewrite (no premise)
    pub fn is_base(&self) -> bool {
        self.premise.is_none()
    }
}

/// Definition of a custom logic relation
#[derive(Debug, Clone, Copy)]
pub struct LogicRelationDef {
    /// Relation name (e.g., "path", "can_send")
    pub name: &'static str,
    
    /// Parameter type names (e.g., ["Proc", "Proc"])
    pub param_types: &'static [&'static str],
    
    /// Optional description (from comment)
    pub description: Option<&'static str>,
}

/// Definition of a custom logic rule
#[derive(Debug, Clone, Copy)]
pub struct LogicRuleDef {
    /// The rule in Ascent syntax (formatted for display)
    pub rule: &'static str,
}
